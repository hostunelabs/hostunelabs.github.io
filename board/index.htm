<!doctype html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
      />
      <title>TuneBoard</title>
      <!-- Google Fonts - Caveat for handwriting-style text -->
      <link rel="preconnect" href="https://fonts.googleapis.com" />
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
      <link
         href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&display=swap"
         rel="stylesheet"
      />
      <link href="favicon.png" rel="icon" />
      <link rel="manifest" href="manifest.json" />
      <meta name="theme-color" content="#ffffff" />
      <script>
        if ('serviceWorker' in navigator) {
            // Check if running on file protocol
            if (window.location.protocol === 'file:') {
                console.warn('PWA features (Service Worker) require a local server (http/https) and do not work on file:// protocol.');
            } else {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('sw.js')
                        .then(reg => console.log('Service Worker registered', reg))
                        .catch(err => console.log('Service Worker registration failed', err));
                });
            }
        }
      </script>
      <script src="https://cdn.tailwindcss.com"></script>
      <!-- Updated Lucide Script to ensure UMD build is loaded -->
      <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
      <style>
         body {
            overscroll-behavior: none;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
         }
         canvas {
            touch-action: none;
            display: block;
         }
         .tool-btn {
            transition: all 0.2s ease;
            min-height: 36px;
            min-width: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            padding: 0.4rem !important;
         }
         @media (max-width: 640px) {
            .tool-btn {
               min-height: 44px;
               min-width: 44px;
               padding: 0.5rem !important;
            }
         }
         .tool-btn.active {
            background-color: #e5e7eb;
            color: #2563eb;
            transform: scale(1.05);
         }
         .color-swatch {
            transition: transform 0.2s ease;
            min-height: 20px;
            min-width: 20px;
            flex-shrink: 0;
         }
         @media (max-width: 640px) {
            .color-swatch {
               min-height: 24px;
               min-width: 24px;
            }
         }
         .color-swatch:hover,
         .color-swatch.active {
            transform: scale(1.2);
            box-shadow:
               0 0 0 2px white,
               0 0 0 4px #e5e7eb;
         }
         input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            height: 5px;
            flex-shrink: 0;
         }
         input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #2563eb;
            margin-top: -7px;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
         }
         input[type="range"]::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            border: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
         }
         input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 5px;
            background: #e5e7eb;
            border-radius: 2px;
         }
         input[type="range"]::-moz-range-track {
            background: #e5e7eb;
            border-radius: 2px;
            height: 5px;
         }
         .no-scrollbar::-webkit-scrollbar {
            display: none;
         }
         .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
         }

         #text-input {
            position: absolute;
            background: transparent;
            border: none;
            outline: none;
            padding: 0;
            margin: 0;
            font-family: "Caveat", cursive;
            font-weight: bold;
            color: black;
            z-index: 100;
            min-width: 50px;
            line-height: 1; /* Match canvas text rendering */
         }

         /* Context Menu Styles */
         #context-menu {
            position: absolute;
            z-index: 1000;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow:
               0 10px 15px -3px rgba(0, 0, 0, 0.1),
               0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 4px;
            min-width: 160px;
            max-width: calc(100vw - 16px);
         }
         .context-menu-item {
            padding: 10px 12px;
            font-size: 14px;
            color: #374151;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            border-radius: 4px;
            white-space: nowrap;
            touch-action: manipulation;
            flex-shrink: 0;
         }
         @media (max-width: 640px) {
            .context-menu-item {
               padding: 12px 14px;
               font-size: 15px;
               min-height: 44px;
            }
         }
         .context-menu-item:hover,
         .context-menu-item:active {
            background-color: #f3f4f6;
            color: #111827;
         }

         .color-swatch.transparent-swatch {
            background: repeating-conic-gradient(#ddd 0% 25%, #fff 0% 50%) 50% / 8px 8px;
            position: relative;
            overflow: hidden;
         }
         .color-swatch.transparent-swatch::after {
            content: "";
            position: absolute;
            top: 50%;
            left: -20%;
            width: 140%;
            height: 1px;
            background: red;
            transform: rotate(45deg);
         }

         /* Responsive toolbar */
         .toolbar-main {
            display: flex;
            flex-wrap: nowrap;
            align-items: center;
            gap: 1px;
            gap: 1px;
            overflow: visible;
            max-height: 56px;
         }

         .toolbar-group {
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 0 4px;
            flex-shrink: 0;
            border-right: 1px solid #e5e7eb;
         }

         .toolbar-group:last-child {
            border-right: none;
         }

         /* Tablet styles (768px - 1024px) */
         @media (min-width: 768px) and (max-width: 1024px) {
            .toolbar-main {
               max-width: 95%;
               overflow-x: auto;
               overflow-y: hidden;
               -webkit-overflow-scrolling: touch;
               scrollbar-width: none;
               -ms-overflow-style: none;
            }
            .toolbar-main::-webkit-scrollbar {
               display: none;
            }
            .tool-btn {
               min-height: 40px;
               min-width: 40px;
               padding: 0.5rem !important;
            }
            .tool-btn i {
               width: 18px !important;
               height: 18px !important;
            }
            .color-swatch {
               min-height: 22px;
               min-width: 22px;
            }
         }

         /* Mobile styles (<768px) */
         @media (max-width: 767px) {
            .toolbar-main {
               bottom: 8px !important;
               width: calc(100% - 16px) !important;
               left: 8px !important;
               transform: none !important;
               padding: 8px 10px !important;
               border-radius: 16px !important;
               max-height: none;
               overflow-x: auto;
               overflow-y: hidden;
               -webkit-overflow-scrolling: touch;
               scrollbar-width: none;
               -ms-overflow-style: none;
               gap: 2px !important;
            }
            .toolbar-main::-webkit-scrollbar {
               display: none;
            }
            .toolbar-group {
               gap: 4px !important;
               padding: 0 6px !important;
               flex-shrink: 0;
            }
            .tool-btn {
               min-height: 44px;
               min-width: 44px;
               padding: 0.5rem !important;
            }
            .tool-btn i {
               width: 20px !important;
               height: 20px !important;
            }
            .color-swatch {
               min-height: 24px;
               min-width: 24px;
            }
            /* Hide some less-used items on very small screens */
            .toolbar-group.colors-group .flex {
               gap: 3px !important;
            }
         }

         /* Very small mobile (<480px) - compact mode */
         @media (max-width: 480px) {
            .toolbar-main {
               bottom: 6px !important;
               width: calc(100% - 12px) !important;
               left: 6px !important;
               padding: 6px 8px !important;
            }
            .toolbar-group {
               gap: 2px !important;
               padding: 0 4px !important;
            }
            .tool-btn {
               min-height: 40px;
               min-width: 40px;
            }
            .tool-btn i {
               width: 18px !important;
               height: 18px !important;
            }
            .color-swatch {
               min-height: 20px;
               min-width: 20px;
            }
         }

         /* Ensure touch targets are 44x44 minimum on touch devices */
         @media (max-width: 1024px) and (pointer: coarse) {
            button {
               min-height: 44px;
               min-width: 44px;
            }
         }

         /* Mobile viewport optimization */
         @media (orientation: landscape) and (max-height: 600px) {
            .toolbar-main {
               bottom: 8px !important;
               max-height: 90px !important;
            }
            .toolbar-group {
               gap: 2px !important;
            }
         }

         /* Secondary Actions Toolbar - Small edit bar positioned at top-left of main toolbar */
         .toolbar-secondary {
            display: flex;
            align-items: center;
            gap: 12px;
            position: absolute;
            z-index: 21;
            padding: 4px 10px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            border-radius: 20px;
            box-shadow:
               0 4px 6px -1px rgba(0, 0, 0, 0.1),
               0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid rgba(229, 231, 235, 0.5);
         }

         .toolbar-secondary .tool-btn {
            min-height: auto;
            min-width: auto;
            padding: 2px !important;
            color: #6b7280; /* Gray-500 */
         }

         .toolbar-secondary .tool-btn:hover {
            color: #111827; /* Gray-900 */
            background: transparent; /* Remove background on hover for cleaner look, or maybe subtle? */
         }

         .toolbar-secondary .tool-btn svg,
         .toolbar-secondary .tool-btn i {
            width: 14px !important;
            height: 14px !important;
            stroke-width: 2.5px; /* Make them slightly bolder at small size */
         }

         /* Desktop: Position at top-left of main toolbar */
         @media (min-width: 768px) {
            .toolbar-secondary {
               bottom: calc(100% + 5px);
               left: 0;
            }
         }

         /* Mobile: Position at top-left of main toolbar */
         /* Mobile: Position at top-left of main toolbar */
         @media (max-width: 767px) {
            .toolbar-secondary {
               bottom: calc(100% + 4px);
               left: 8px;
               padding: 3px 6px;
               gap: 8px;
            }
            .toolbar-secondary .tool-btn svg,
            .toolbar-secondary .tool-btn i {
               width: 14px !important;
               height: 14px !important;
            }
         }

         /* Very small mobile */
         @media (max-width: 480px) {
            .toolbar-secondary {
               left: 6px;
               padding: 2px 5px;
            }
         }

         /* Plus icon tooltip styling */
         #plus-icon-tooltip {
            position: absolute;
            z-index: 1000;
            background: rgba(100, 116, 139, 0.75);
            color: rgba(255, 255, 255, 0.9);
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 400;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
            white-space: nowrap;
         }
         #plus-icon-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
         }
         #plus-icon-tooltip kbd {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 5px;
            border-radius: 3px;
            font-family: ui-monospace, monospace;
            font-size: 11px;
            margin-left: 6px;
         }

         /* Shape dropdown menu styles */
         .shape-dropdown {
            position: relative;
         }
         .shape-dropdown-menu {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow:
               0 10px 15px -3px rgba(0, 0, 0, 0.1),
               0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 4px;
            margin-bottom: 8px;
            min-width: 120px;
            z-index: 2000;
            display: none;
         }
         .shape-dropdown-menu.visible {
            display: block;
         }
         .shape-dropdown-item {
            padding: 8px 12px;
            font-size: 13px;
            color: #374151;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            border-radius: 4px;
            white-space: nowrap;
         }
         .shape-dropdown-item:hover {
            background-color: #f3f4f6;
            color: #111827;
         }
         .shape-dropdown-item.active {
            background-color: #e5e7eb;
            color: #2563eb;
         }
         /* Tool Lock Button */
         #tool-lock-btn {
            position: fixed;
            left: 250px; /* Positioned to the right of the secondary toolbar */
            bottom: 24px;
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 1px solid #e5e7eb;
            color: #4b5563;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 40;
         }

         #tool-lock-btn:hover {
            background: #f3f4f6;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
         }

         #tool-lock-btn.locked {
            background: #fee2e2;
            color: #ef4444;
            border-color: #fecaca;
         }

         #tool-lock-btn svg {
            width: 20px;
            height: 20px;
         }

         @media (max-width: 768px) {
            #tool-lock-btn {
               left: auto;
               right: 24px;
               bottom: 100px; /* Above the mobile toolbar */
            }
         }

         /* Optimized Floating Toolbar for Mobile & Tablet (< 1024px) */
         @media (max-width: 1024px) {
            #floating-toolbar {
               position: fixed !important;
               top: 50% !important;
               bottom: auto !important;
               left: auto !important;
               right: 12px !important; /* Right side placement */
               transform: translateY(-50%) !important;
               margin: 0 !important;
               
               /* Vertical Column Layout */
               flex-direction: column !important;
               width: auto !important;
               min-width: 52px !important;
               max-width: 72px !important;
               height: auto !important;
               max-height: 80vh !important;
               overflow-y: auto !important;
               overflow-x: hidden !important;
               
               /* Styling */
               background-color: rgba(255, 255, 255, 0.95) !important;
               backdrop-filter: blur(8px) !important;
               border: 1px solid #e5e7eb !important;
               border-radius: 16px !important;
               box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05) !important;
               opacity: 1 !important; /* Force full visibility */
               
               padding: 12px 6px !important;
               gap: 12px !important;
               z-index: 9999 !important;
            }

            /* Hide scrollbar */
            #floating-toolbar::-webkit-scrollbar {
               display: none;
            }

            /* Stack sections vertically */
            #ft-actions-row, 
            #ft-arrows-row, 
            #ft-conversion-row {
               flex-direction: column !important;
               width: 100% !important;
               border-right: none !important;
               border-bottom: 1px solid #e5e7eb !important;
               padding-right: 0 !important;
               margin-right: 0 !important;
               padding-bottom: 8px !important;
               margin-bottom: 8px !important;
               gap: 8px !important;
            }
            
            /* Remove borders from last items */
            #ft-actions-row:last-child, 
            #ft-arrows-row:last-child, 
            #ft-conversion-row:last-child {
               border-bottom: none !important;
               margin-bottom: 0 !important;
               padding-bottom: 0 !important;
            }

            /* Transform vertical separators into horizontal */
             #ft-actions-row > .w-px, 
             #ft-arrows-row > .w-px {
                width: 100% !important;
                height: 1px !important;
                margin: 4px 0 !important;
             }

            /* Color Section layout */
            #floating-toolbar .flex-col {
               gap: 8px !important;
               width: 100% !important;
            }
            /* Grid layout for colors */
            #floating-toolbar .flex-col > div.flex {
               flex-wrap: wrap !important;
               justify-content: center !important;
               width: 100% !important;
               gap: 6px !important;
            }
            
            /* Larger targets for touch */
            #floating-toolbar .tool-btn {
                min-width: 40px !important;
                min-height: 40px !important;
            }
         }
      </style>
   </head>
   <body
      class="bg-gray-50 h-screen w-screen overflow-hidden flex flex-col font-sans"
      oncontextmenu="return false;"
   >
      <!-- Tool Lock Button -->
      <button id="tool-lock-btn" onclick="toggleToolLock()" title="Lock Tool">
         <i data-lucide="lock-open"></i>
      </button>

      <!-- App Menu -->
      <div class="absolute top-3 left-4 z-50">
         <button
            id="app-menu-btn"
            class="p-2 rounded-lg bg-white/90 shadow-md hover:bg-gray-100 border border-gray-200 flex items-center justify-center transition-all h-8 w-8 md:h-9 md:w-9"
            onclick="toggleAppMenu()"
            title="Menu"
         >
            <i data-lucide="menu" class="w-5 h-5 text-gray-700"></i>
         </button>

         <div
            id="app-menu-dropdown"
            class="hidden absolute top-full left-0 mt-2 w-48 bg-white rounded-lg shadow-xl border border-gray-200 py-1 overflow-hidden"
         >
            <div class="px-4 py-2 border-b border-gray-100 flex items-center justify-between bg-gray-50">
               <span class="font-bold text-gray-700 text-sm">TuneBoard</span>
               <button onclick="toggleAppMenu()" class="text-gray-400 hover:text-gray-600">
                  <i data-lucide="x" class="w-4 h-4"></i>
               </button>
            </div>
            <button
               class="w-full text-left px-4 py-3 hover:bg-gray-50 flex items-center gap-3 text-gray-700 transition-colors border-b border-gray-50"
               onclick="importCanvas()"
            >
               <i data-lucide="upload" class="w-4 h-4"></i> 
               <span class="font-medium">Import</span>
            </button>
            <input
               type="file"
               id="import-file-input"
               accept=".tboard"
               class="hidden"
               onchange="handleImportFile(this.files[0])"
            />
            <button
               class="w-full text-left px-4 py-3 hover:bg-gray-50 flex items-center gap-3 text-gray-700 transition-colors"
               onclick="exportCanvas()"
            >
               <i data-lucide="download" class="w-4 h-4"></i> 
               <span class="font-medium">Export</span>
            </button>
            <div class="h-px bg-gray-100 my-1"></div>
            <a
               href="mailto:dev.hostune@gmail.com"
               class="w-full text-left px-4 py-3 hover:bg-gray-50 flex items-start gap-3 text-gray-500 text-xs transition-colors no-underline"
               onclick="toggleAppMenu()"
            >
               <i data-lucide="mail" class="w-3 h-3 mt-0.5"></i>
               <div class="flex flex-col">
                  <span class="font-medium">Feedback / Request Feature / Report Bug</span>
                  <span class="opacity-75">dev.hostune@gmail.com</span>
               </div>
            </a>
         </div>
      </div>

      <!-- Logo -->
      <img
         src="tuneboard.png"
         alt="TuneBoard Logo"
         class="absolute top-3 left-16 md:top-4 md:left-20 z-20 h-4 md:h-5 w-auto select-none pointer-events-none"
      />

      <!-- Main Toolbar (Drawing Tools) -->
      <div
         class="toolbar-main absolute bottom-4 left-1/2 transform -translate-x-1/2 z-20 p-2 bg-white/95 backdrop-blur-md rounded-2xl shadow-xl border border-gray-200 w-[95%] max-w-4xl md:left-[calc(50%+60px)] md:-translate-x-1/2"
      >
         <!-- Tools Group 1: Basics -->
         <div class="toolbar-group">
            <button
               class="tool-btn active p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-select"
               onclick="setTool('select')"
               title="Select (S)"
            >
               <i data-lucide="mouse-pointer-2" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-pencil"
               onclick="setTool('pencil')"
               title="Pencil (P)"
            >
               <i data-lucide="pencil" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-pencil-arrow"
               onclick="setTool('pencil-arrow')"
               title="Freehand Arrow (F)"
            >
               <i data-lucide="trending-up" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-laser"
               onclick="setTool('laser')"
               title="Laser Tool (Z)"
            >
               <i data-lucide="zap" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-eraser"
               onclick="setTool('eraser')"
               title="Eraser (E)"
            >
               <i data-lucide="eraser" class="w-4 h-4"></i>
            </button>
         </div>

         <!-- Tools Group 2: Lines & Text -->
         <div class="toolbar-group">
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-line"
               onclick="setTool('line')"
               title="Line (L)"
            >
               <i data-lucide="minus" class="w-4 h-4 transform -rotate-45"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-arrow"
               onclick="setTool('arrow')"
               title="Curved Arrow (A)"
            >
               <i data-lucide="move-up-right" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-text"
               onclick="setTool('text')"
               title="Text (T)"
            >
               <i data-lucide="type" class="w-4 h-4"></i>
            </button>
         </div>

         <!-- Tools Group 3: Shapes -->
         <div class="toolbar-group">
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-rect"
               onclick="setTool('rect')"
               title="Rectangle (R)"
            >
               <i data-lucide="square" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-circle"
               onclick="setTool('circle')"
               title="Circle (C)"
            >
               <i data-lucide="circle" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-triangle"
               onclick="setTool('triangle')"
               title="Triangle (N)"
            >
               <i data-lucide="triangle" class="w-4 h-4"></i>
            </button>
            <!-- More Shapes Dropdown -->
            <div class="shape-dropdown">
               <button
                  class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
                  id="btn-more-shapes"
                  onclick="toggleShapeDropdown()"
                  title="More Shapes"
               >
                  <i data-lucide="more-horizontal" class="w-4 h-4"></i>
               </button>
               <div id="shape-dropdown-menu" class="shape-dropdown-menu">
                  <div
                     class="shape-dropdown-item"
                     id="btn-oval"
                     onclick="
                        setTool('oval');
                        hideShapeDropdown();
                     "
                  >
                     <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="5" ry="5"/></svg>
                     <span>Oval</span>
                  </div>
                  <div
                     class="shape-dropdown-item"
                     id="btn-rhombus"
                     onclick="
                        setTool('rhombus');
                        hideShapeDropdown();
                     "
                  >
                     <svg class="w-4 h-4" viewBox="0 0 24 24"><path d="M 5.1308594 3 L 0.82226562 17 L 1.5 17 L 14.869141 17 L 19.177734 3 L 5.1308594 3 z M 5.8691406 4 L 17.822266 4 L 14.130859 16 L 2.1777344 16 L 5.8691406 4 z " style="fill:currentColor; fill-opacity:1; stroke:currentColor; stroke-width:1;"/></svg>
                     <span>Rhombus</span>
                  </div>
                  <div
                     class="shape-dropdown-item"
                     id="btn-diamond"
                     onclick="
                        setTool('diamond');
                        hideShapeDropdown();
                     "
                  >
                     <i data-lucide="diamond" class="w-4 h-4"></i>
                     <span>Diamond</span>
                  </div>
               </div>
            </div>
         </div>

         <!-- Colors -->
         <!-- Modified to 2 rows: Top Stroke, Bottom Fill -->
         <div class="toolbar-group flex flex-col justify-center py-1" style="gap: 2px">
            <!-- Row 1: Stroke (Outline) -->
            <div class="flex items-center gap-1">
               <button
                  class="color-swatch w-4 h-4 rounded-full transparent-swatch border border-gray-300"
                  onclick="setCurrentStrokeColor('transparent')"
                  title="Stroke: Transparent"
               ></button>
               <button
                  class="color-swatch w-4 h-4 rounded-full bg-transparent border-[3px] border-black"
                  onclick="setCurrentStrokeColor('#000000')"
                  title="Stroke: Black"
               ></button>
               <button
                  class="color-swatch w-4 h-4 rounded-full bg-transparent border-[3px] border-red-500"
                  onclick="setCurrentStrokeColor('#ef4444')"
                  title="Stroke: Red"
               ></button>
               <button
                  class="color-swatch w-4 h-4 rounded-full bg-transparent border-[3px] border-blue-500"
                  onclick="setCurrentStrokeColor('#3b82f6')"
                  title="Stroke: Blue"
               ></button>
               <button
                  class="color-swatch w-4 h-4 rounded-full bg-transparent border-[3px] border-green-500"
                  onclick="setCurrentStrokeColor('#22c55e')"
                  title="Stroke: Green"
               ></button>
               <!-- Custom Stroke -->
               <div class="relative group color-swatch w-4 h-4 rounded-full">
                  <input
                     type="color"
                     class="opacity-0 absolute inset-0 w-full h-full cursor-pointer"
                     oninput="setCurrentStrokeColor(this.value)"
                     title="Custom Stroke Color"
                  />
                  <div
                     class="w-full h-full rounded-full bg-transparent border-[3px] border-gray-800 flex items-center justify-center"
                  >
                     <i data-lucide="plus" class="w-2 h-2 text-gray-800"></i>
                  </div>
               </div>
            </div>

            <!-- Row 2: Fill (Background) -->
            <div class="flex items-center gap-1">
               <button
                  class="color-swatch w-4 h-4 rounded-full transparent-swatch border border-gray-300"
                  onclick="setCurrentFillColor('transparent')"
                  title="Fill: Transparent"
               ></button>
               <!-- Very Light Gray for Black -->
               <button
                  class="color-swatch w-4 h-4 rounded-full bg-gray-200 border border-gray-200"
                  onclick="setCurrentFillColor('#e5e7eb')"
                  title="Fill: Light Gray"
               ></button>
               <!-- Very Light Red -->
               <button
                  class="color-swatch w-4 h-4 rounded-full bg-red-100 border border-gray-200"
                  onclick="setCurrentFillColor('#fee2e2')"
                  title="Fill: Light Red"
               ></button>
               <!-- Very Light Blue -->
               <button
                  class="color-swatch w-4 h-4 rounded-full bg-blue-100 border border-gray-200"
                  onclick="setCurrentFillColor('#dbeafe')"
                  title="Fill: Light Blue"
               ></button>
               <!-- Very Light Green -->
               <button
                  class="color-swatch w-4 h-4 rounded-full bg-green-100 border border-gray-200"
                  onclick="setCurrentFillColor('#dcfce7')"
                  title="Fill: Light Green"
               ></button>
               <!-- Custom Fill -->
               <div class="relative group color-swatch w-4 h-4 rounded-full">
                  <input
                     type="color"
                     class="opacity-0 absolute inset-0 w-full h-full cursor-pointer"
                     oninput="setCurrentFillColor(this.value)"
                     title="Custom Fill Color"
                  />
                  <div
                     class="w-full h-full rounded-full bg-gradient-to-br from-purple-100 to-pink-100 border border-gray-200 flex items-center justify-center"
                  >
                     <i data-lucide="plus" class="w-2 h-2 text-gray-500"></i>
                  </div>
               </div>
            </div>
         </div>

         <!-- Brush Size (Desktop) -->
         <div class="toolbar-group hidden md:flex" style="gap: 6px">
            <i data-lucide="circle-dot" class="w-4 h-4 text-gray-400 flex-shrink-0"></i>
            <input
               type="range"
               min="1"
               max="50"
               value="2"
               id="width-slider-desk"
               class="w-20"
               oninput="setLineWidth(this.value)"
               title="Thickness ([ / ])"
            />
            <span id="width-val-desk" class="text-xs text-gray-500 w-4 flex-shrink-0">2</span>
         </div>

         <!-- Actions Group 1: Files -->
         <div class="toolbar-group">
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               onclick="document.getElementById('imageInput').click()"
               title="Add Image"
            >
               <i data-lucide="image" class="w-4 h-4"></i>
            </button>
            <input
               type="file"
               id="imageInput"
               accept="image/*"
               class="hidden"
               onchange="handleImageFile(this.files[0])"
            />
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               onclick="downloadImage()"
               title="Download (Ctrl+S)"
            >
               <i data-lucide="download" class="w-4 h-4"></i>
            </button>
         </div>
      </div>

      <!-- Context Toolbar (Alignment) - Floats below main toolbar -->
      <div
         id="alignment-bar"
         class="absolute bottom-24 left-1/2 transform -translate-x-1/2 z-10 flex items-center gap-1 p-2 bg-white/90 backdrop-blur-sm rounded-xl shadow-lg border border-gray-200 hidden transition-all duration-200"
      >
         <button
            class="tool-btn p-2 rounded-xl text-gray-600 hover:bg-gray-100"
            onclick="alignSelected('left')"
            title="Align Left (L)"
         >
            <i data-lucide="arrow-left-to-line" class="w-4 h-4"></i>
         </button>
         <button
            class="tool-btn p-2 rounded-xl text-gray-600 hover:bg-gray-100"
            onclick="alignSelected('center-h')"
            title="Align Center Horizontal (H / E)"
         >
            <i data-lucide="align-center-vertical" class="w-4 h-4"></i>
         </button>
         <button
            class="tool-btn p-2 rounded-xl text-gray-600 hover:bg-gray-100"
            onclick="alignSelected('right')"
            title="Align Right (R)"
         >
            <i data-lucide="arrow-right-to-line" class="w-4 h-4"></i>
         </button>
         <div class="w-px h-6 bg-gray-200 mx-1"></div>
         <button
            class="tool-btn p-2 rounded-xl text-gray-600 hover:bg-gray-100"
            onclick="alignSelected('top')"
            title="Align Top (T)"
         >
            <i data-lucide="arrow-up-to-line" class="w-4 h-4"></i>
         </button>
         <button
            class="tool-btn p-2 rounded-xl text-gray-600 hover:bg-gray-100"
            onclick="alignSelected('middle-v')"
            title="Align Middle Vertical (C / V)"
         >
            <i data-lucide="align-center-horizontal" class="w-4 h-4"></i>
         </button>
         <button
            class="tool-btn p-2 rounded-xl text-gray-600 hover:bg-gray-100"
            onclick="alignSelected('bottom')"
            title="Align Bottom (B)"
         >
            <i data-lucide="arrow-down-to-line" class="w-4 h-4"></i>
         </button>
      </div>

      <!-- Mobile Size Slider -->
      <div
         id="mobile-size-slider"
         class="absolute bottom-[70px] right-2 z-20 md:hidden bg-white/90 backdrop-blur-sm p-3 rounded-2xl shadow-lg border border-gray-200 flex items-center gap-3 flex-shrink-0"
         style="max-width: 60%; min-width: min(150px, 60%)"
      >
         <i data-lucide="circle-dot-dashed" class="w-4 h-4 text-gray-400 flex-shrink-0"></i>
         <input
            type="range"
            min="1"
            max="30"
            value="2"
            id="width-slider-mob"
            class="flex-grow min-w-0"
            oninput="setLineWidth(this.value)"
         />
         <span id="width-val-mob" class="text-xs text-gray-500 font-bold w-5 flex-shrink-0">2</span>
      </div>

      <!-- Reset Zoom Button -->
      <div class="absolute top-3 md:top-4 right-4 md:right-6 z-20 flex items-center gap-2">
         <button
            class="tool-btn p-2 md:p-3 bg-white/95 backdrop-blur-md rounded-2xl shadow-xl border border-gray-200 text-gray-600 hover:bg-gray-100 flex items-center gap-2"
            onclick="resetView()"
            title="Reset View (Esc)"
         >
            <i data-lucide="refresh-cw" class="w-4 md:w-5 h-4 md:h-5"></i>
            <span class="text-xs font-bold hidden sm:inline" id="zoom-percentage">100%</span>
         </button>
      </div>

      <canvas id="canvas"></canvas>

      <div
         id="toast"
         class="absolute top-20 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-full shadow-lg opacity-0 transition-opacity duration-300 pointer-events-none z-50 text-xs sm:text-sm"
      >
         Action Completed
      </div>

      <!-- Shape Recognition Undo Panel -->
      <div
         id="shape-recognition-panel"
         class="absolute top-4 left-1/2 transform -translate-x-1/2 bg-white rounded-lg shadow-xl border border-gray-200 px-4 py-3 z-50 hidden transition-all duration-300"
         style="opacity: 0; transform: translate(-50%, -10px)"
      >
         <div class="flex items-center gap-2">
            <button
               id="undo-shape-btn"
               class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-md text-sm font-medium text-gray-700 transition-colors"
               onclick="undoShapeRecognition()"
            >
               Undo
            </button>
            <div class="w-px h-6 bg-gray-300"></div>
            <button
               id="convert-rectangle-btn"
               class="px-4 py-2 bg-blue-50 hover:bg-blue-100 rounded-md text-sm font-medium text-blue-700 transition-colors"
               onclick="convertToShape('rectangle')"
            >
               Rectangle
            </button>
            <button
               id="convert-circle-btn"
               class="px-4 py-2 bg-blue-50 hover:bg-blue-100 rounded-md text-sm font-medium text-blue-700 transition-colors"
               onclick="convertToShape('circle')"
            >
               Circle
            </button>
            <button
               id="convert-triangle-btn"
               class="px-4 py-2 bg-blue-50 hover:bg-blue-100 rounded-md text-sm font-medium text-blue-700 transition-colors"
               onclick="convertToShape('triangle')"
            >
               Triangle
            </button>
         </div>
      </div>

      <!-- Context Menu -->
      <div
         id="context-menu"
         class="absolute bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50 hidden overflow-y-auto"
         style="max-height: 90vh"
      >
         <div
            class="context-menu-item"
            id="paste-menu-item"
            style="display: none"
            onclick="
               pasteFromClipboard();
               hideContextMenu();
            "
         >
            <i data-lucide="clipboard-paste" class="w-4 h-4 flex-shrink-0"></i>
            <span>Paste</span>
         </div>
         <div
            class="context-menu-separator"
            id="paste-separator"
            style="display: none; height: 1px; background-color: #e5e7eb; margin: 4px 0"
         ></div>
         <div
            class="context-menu-item"
            id="to-dotted-line-item"
            style="display: none"
            onclick="
               toggleDottedLine();
               hideContextMenu();
            "
         >
            <i data-lucide="circle-dot-dashed" class="w-4 h-4 flex-shrink-0"></i>
            <span>Toggle Dotted Line</span>
         </div>
         <div id="arrow-toggles-container" style="display: none; padding: 2px 4px">
            <div style="display: flex; gap: 4px">
               <div
                  class="context-menu-item"
                  id="toggle-start-arrow-item"
                  style="flex: 1; justify-content: center; padding: 8px 4px; gap: 6px;"
                  onclick="
                     toggleStartArrow();
                     hideContextMenu();
                  "
                  title="Toggle Start Arrow"
               >
                  <i data-lucide="arrow-left" class="w-4 h-4 flex-shrink-0"></i>
                  <div id="start-arrow-indicator" style="width: 6px; height: 6px; background-color: #22c55e; border-radius: 50%; display: none;"></div>
                  <span>Start</span>
               </div>
               <div
                  class="context-menu-item"
                  id="toggle-end-arrow-item"
                  style="flex: 1; justify-content: center; padding: 8px 4px; gap: 6px;"
                  onclick="
                     toggleEndArrow();
                     hideContextMenu();
                  "
                  title="Toggle End Arrow"
               >
                  <div id="end-arrow-indicator" style="width: 6px; height: 6px; background-color: #22c55e; border-radius: 50%; display: none;"></div>
                  <span>End</span>
                  <i data-lucide="arrow-right" class="w-4 h-4 flex-shrink-0"></i>
               </div>
            </div>
         </div>
         <div
            class="context-menu-separator"
            id="editing-layering-separator"
            style="display: none; height: 1px; background-color: #e5e7eb; margin: 4px 0"
         ></div>
         <div id="layering-actions-container" style="display: none; padding: 2px 4px">
            <div style="display: flex; gap: 4px">
               <div
                  class="context-menu-item"
                  id="send-to-back-item"
                  style="flex: 1; justify-content: center; padding: 8px 4px"
                  onclick="
                     sendToBack();
                     hideContextMenu();
                  "
                  title="Send to Back"
               >
                  <i data-lucide="chevrons-down" class="w-4 h-4 flex-shrink-0"></i>
                  <span>Back</span>
               </div>
               <div
                  class="context-menu-item"
                  id="bring-to-front-item"
                  style="flex: 1; justify-content: center; padding: 8px 4px"
                  onclick="
                     bringToFront();
                     hideContextMenu();
                  "
                  title="Bring to Front"
               >
                  <i data-lucide="chevrons-up" class="w-4 h-4 flex-shrink-0"></i>
                  <span>Front</span>
               </div>
            </div>
         </div>
         <div
            class="context-menu-separator"
            id="layering-delete-separator"
            style="display: none; height: 1px; background-color: #e5e7eb; margin: 4px 0"
         ></div>
         <div
            class="context-menu-item"
            id="duplicate-item"
            style="display: none"
            onclick="
               duplicateSelected();
               hideContextMenu();
            "
         >
            <i data-lucide="copy" class="w-4 h-4 flex-shrink-0"></i>
            <span>Duplicate</span>
         </div>
         <div
            class="context-menu-item text-red-500"
            id="delete-item"
            style="display: none"
            onclick="
               deleteSelected();
               hideContextMenu();
            "
         >
            <i data-lucide="trash-2" class="w-4 h-4 flex-shrink-0"></i>
            <span>Delete</span>
         </div>
         <!-- Shape conversion items (appended after existing context menu items) -->
         <div
            class="context-menu-separator"
            id="shape-conversion-separator"
            style="display: none; height: 1px; background-color: #e5e7eb; margin: 4px 0"
         ></div>
         <div
            class="context-menu-item"
            id="change-to-rectangle-item"
            style="display: none"
            onclick="
               changeSelectedShapesType('rect');
               hideContextMenu();
            "
         >
            <i data-lucide="square" class="w-4 h-4 flex-shrink-0"></i>
            <span>To Rectangle</span>
         </div>
         <div
            class="context-menu-item"
            id="change-to-circle-item"
            style="display: none"
            onclick="
               changeSelectedShapesType('circle');
               hideContextMenu();
            "
         >
            <i data-lucide="circle" class="w-4 h-4 flex-shrink-0"></i>
            <span>To Circle</span>
         </div>
         <div
            class="context-menu-item"
            id="change-to-triangle-item"
            style="display: none"
            onclick="
               changeSelectedShapesType('triangle');
               hideContextMenu();
            "
         >
            <i data-lucide="triangle" class="w-4 h-4 flex-shrink-0"></i>
            <span>To Triangle</span>
         </div>
         <div
            class="context-menu-item"
            id="change-to-oval-item"
            style="display: none"
            onclick="
               changeSelectedShapesType('oval');
               hideContextMenu();
            "
         >
            <svg class="w-4 h-4 flex-shrink-0" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="5" ry="5"/></svg>
            <span>To Oval</span>
         </div>
         <div
            class="context-menu-item"
            id="change-to-rhombus-item"
            style="display: none"
            onclick="
               changeSelectedShapesType('rhombus');
               hideContextMenu();
            "
         >
            <svg class="w-4 h-4 flex-shrink-0" viewBox="0 0 24 24"><path d="M 5.1308594 3 L 0.82226562 17 L 1.5 17 L 14.869141 17 L 19.177734 3 L 5.1308594 3 z M 5.8691406 4 L 17.822266 4 L 14.130859 16 L 2.1777344 16 L 5.8691406 4 z " style="fill:currentColor; fill-opacity:1; stroke:currentColor; stroke-width:1;"/></svg>
            <span>To Rhombus</span>
         </div>
         <div
            class="context-menu-item"
            id="change-to-diamond-item"
            style="display: none"
            onclick="
               changeSelectedShapesType('diamond');
               hideContextMenu();
            "
         >
            <i data-lucide="diamond" class="w-4 h-4 flex-shrink-0"></i>
            <span>To Diamond</span>
         </div>
      </div>

      <!-- Floating Toolbar (Intelligent Menu) -->
      <div
         id="floating-toolbar"
         class="absolute z-30 p-2 bg-transparent hover:bg-white/95 hover:backdrop-blur-md rounded-xl shadow-none hover:shadow-xl border border-transparent hover:border-gray-200 hidden flex items-center gap-2 transition-opacity duration-200 opacity-40 hover:opacity-100"
         style="left: 0; top: 0; transform: translate(-50%, -100%); margin-top: -15px"
      >
         <!-- Actions Row -->
         <div class="flex items-center gap-1 pr-2 mr-0 border-r border-gray-100 justify-center flex-wrap" id="ft-actions-row">
            <button
               class="tool-btn p-1.5 rounded-lg text-gray-600 hover:bg-gray-100 h-8 w-8"
               onclick="duplicateSelected()"
               title="Duplicate"
            >
               <i data-lucide="copy" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-1.5 rounded-lg text-red-500 hover:bg-red-50 h-8 w-8"
               onclick="deleteSelected()"
               title="Delete"
            >
               <i data-lucide="trash-2" class="w-4 h-4"></i>
            </button>
            <div class="w-px h-5 bg-gray-200 mx-1"></div>
            <button
               class="tool-btn p-1.5 rounded-lg text-gray-600 hover:bg-gray-100 h-8 w-8"
               onclick="bringToFront()"
               title="Bring to Front"
            >
               <i data-lucide="chevrons-up" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-1.5 rounded-lg text-gray-600 hover:bg-gray-100 h-8 w-8"
               onclick="sendToBack()"
               title="Send to Back"
            >
               <i data-lucide="chevrons-down" class="w-4 h-4"></i>
            </button>
            <div class="w-px h-5 bg-gray-200 mx-1"></div>
            <button
               class="tool-btn p-1.5 rounded-lg text-gray-600 hover:bg-gray-100 h-8 w-8"
               onclick="toggleDottedLine()"
               title="Toggle Dotted Line"
               id="ft-btn-dotted"
            >
               <i data-lucide="circle-dot-dashed" class="w-4 h-4"></i>
            </button>
            <div class="hidden w-px h-5 bg-gray-200 mx-1" id="ft-bold-separator"></div>
            <button
               class="hidden tool-btn p-1.5 rounded-lg text-gray-600 hover:bg-gray-100 h-8 w-8"
               onclick="toggleBold()"
               title="Toggle Bold"
               id="ft-btn-bold"
            >
               <i data-lucide="bold" class="w-4 h-4"></i>
            </button>
         </div>

         <!-- Arrow Toggles Row -->
         <div class="hidden items-center gap-1 pr-2 mr-0 border-r border-gray-100 justify-center" id="ft-arrows-row">
            <button
               class="tool-btn p-1.5 rounded-lg text-gray-600 hover:bg-gray-100 h-8 w-8 relative"
               onclick="toggleStartArrow()"
               title="Toggle Start Arrow"
               id="ft-btn-start-arrow"
            >
               <i data-lucide="arrow-left" class="w-4 h-4"></i>
               <div id="ft-start-arrow-indicator" class="absolute top-0.5 right-0.5 w-1.5 h-1.5 bg-green-500 rounded-full hidden"></div>
            </button>
            <button
               class="tool-btn p-1.5 rounded-lg text-gray-600 hover:bg-gray-100 h-8 w-8 relative"
               onclick="toggleEndArrow()"
               title="Toggle End Arrow"
               id="ft-btn-end-arrow"
            >
               <i data-lucide="arrow-right" class="w-4 h-4"></i>
               <div id="ft-end-arrow-indicator" class="absolute top-0.5 right-0.5 w-1.5 h-1.5 bg-green-500 rounded-full hidden"></div>
            </button>
         </div>

         <!-- Shape Conversion Row -->
         <div class="hidden items-center gap-1 pr-2 mr-0 border-r border-gray-100 justify-center flex-wrap" id="ft-conversion-row">
            <button class="tool-btn p-1.5 rounded-lg text-gray-600 hover:bg-gray-100 h-8 w-8" onclick="changeSelectedShapesType('rect')" title="To Rectangle"><i data-lucide="square" class="w-4 h-4"></i></button>
            <button class="tool-btn p-1.5 rounded-lg text-gray-600 hover:bg-gray-100 h-8 w-8" onclick="changeSelectedShapesType('circle')" title="To Circle"><i data-lucide="circle" class="w-4 h-4"></i></button>
            <button class="tool-btn p-1.5 rounded-lg text-gray-600 hover:bg-gray-100 h-8 w-8" onclick="changeSelectedShapesType('triangle')" title="To Triangle"><i data-lucide="triangle" class="w-4 h-4"></i></button>
            <button class="tool-btn p-1.5 rounded-lg text-gray-600 hover:bg-gray-100 h-8 w-8" onclick="changeSelectedShapesType('oval')" title="To Oval">
               <svg class="w-4 h-4 flex-shrink-0" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="5" ry="5"/></svg>
            </button>
            <button class="tool-btn p-1.5 rounded-lg text-gray-600 hover:bg-gray-100 h-8 w-8" onclick="changeSelectedShapesType('rhombus')" title="To Rhombus">
               <svg class="w-4 h-4 flex-shrink-0" viewBox="0 0 24 24"><path d="M 5.1308594 3 L 0.82226562 17 L 1.5 17 L 14.869141 17 L 19.177734 3 L 5.1308594 3 z M 5.8691406 4 L 17.822266 4 L 14.130859 16 L 2.1777344 16 L 5.8691406 4 z " style="fill:currentColor; fill-opacity:1; stroke:currentColor; stroke-width:1;"/></svg>
            </button>
            <button class="tool-btn p-1.5 rounded-lg text-gray-600 hover:bg-gray-100 h-8 w-8" onclick="changeSelectedShapesType('diamond')" title="To Diamond"><i data-lucide="diamond" class="w-4 h-4"></i></button>
         </div>

         <!-- Colors Row (Mixed compact) -->
         <div class="flex flex-col gap-1.5">
            <!-- Stroke Colors -->
            <div class="flex items-center gap-1 justify-center">
               <!-- <div class="text-[10px] text-gray-400 font-bold w-3">S</div> -->
               <button
                  class="color-swatch w-5 h-5 rounded-full transparent-swatch border border-gray-300"
                  onclick="setCurrentStrokeColor('transparent')"
                  title="Stroke: Transparent"
               ></button>
               <button
                  class="color-swatch w-5 h-5 rounded-full bg-transparent border-[3px] border-black"
                  onclick="setCurrentStrokeColor('#000000')"
                  title="Stroke: Black"
               ></button>
               <button
                  class="color-swatch w-5 h-5 rounded-full bg-transparent border-[3px] border-red-500"
                  onclick="setCurrentStrokeColor('#ef4444')"
                  title="Stroke: Red"
               ></button>
               <button
                  class="color-swatch w-5 h-5 rounded-full bg-transparent border-[3px] border-blue-500"
                  onclick="setCurrentStrokeColor('#3b82f6')"
                  title="Stroke: Blue"
               ></button>
               <button
                  class="color-swatch w-5 h-5 rounded-full bg-transparent border-[3px] border-green-500"
                  onclick="setCurrentStrokeColor('#22c55e')"
                  title="Stroke: Green"
               ></button>
               <div class="relative group w-5 h-5">
                  <input
                     type="color"
                     class="opacity-0 absolute inset-0 w-full h-full cursor-pointer"
                     oninput="setCurrentStrokeColor(this.value)"
                     title="Custom Stroke"
                  />
                  <div
                     class="w-full h-full rounded-full bg-transparent border-[3px] border-gray-800 flex items-center justify-center"
                  >
                     <i data-lucide="plus" class="w-3 h-3 text-gray-800"></i>
                  </div>
               </div>
            </div>
            <!-- Fill Colors -->
            <div class="flex items-center gap-1 justify-center">
               <!-- <div class="text-[10px] text-gray-400 font-bold w-3">F</div> -->
               <button
                  class="color-swatch w-5 h-5 rounded-full transparent-swatch border border-gray-300"
                  onclick="setCurrentFillColor('transparent')"
                  title="Fill: Transparent"
               ></button>
               <button
                  class="color-swatch w-5 h-5 rounded-full bg-gray-200 border border-gray-200"
                  onclick="setCurrentFillColor('#e5e7eb')"
                  title="Fill: Gray"
               ></button>
               <button
                  class="color-swatch w-5 h-5 rounded-full bg-red-100 border border-gray-200"
                  onclick="setCurrentFillColor('#fee2e2')"
                  title="Fill: Light Red"
               ></button>
               <button
                  class="color-swatch w-5 h-5 rounded-full bg-blue-100 border border-gray-200"
                  onclick="setCurrentFillColor('#dbeafe')"
                  title="Fill: Blue"
               ></button>
               <button
                  class="color-swatch w-5 h-5 rounded-full bg-green-100 border border-gray-200"
                  onclick="setCurrentFillColor('#dcfce7')"
                  title="Fill: Green"
               ></button>
               <div class="relative group w-5 h-5">
                  <input
                     type="color"
                     class="opacity-0 absolute inset-0 w-full h-full cursor-pointer"
                     oninput="setCurrentFillColor(this.value)"
                     title="Custom Fill"
                  />
                  <div
                     class="w-full h-full rounded-full bg-gradient-to-br from-purple-100 to-pink-100 border border-gray-200 flex items-center justify-center"
                  >
                     <i data-lucide="plus" class="w-3 h-3 text-gray-500"></i>
                  </div>
               </div>
            </div>
         </div>
      </div>

      <!-- Plus Icon Tooltip -->
      <div id="plus-icon-tooltip">Add connected shape <kbd>+</kbd></div>

      <script>
         // Wait for Lucide to load
         window.addEventListener("load", function () {
            if (typeof lucide !== "undefined") {
               lucide.createIcons();
            }
         });

         const canvas = document.getElementById("canvas");
         const ctx = canvas.getContext("2d");
         const toastEl = document.getElementById("toast");
         const btnDeleteSelected = document.getElementById("btn-delete-selected");
         const alignmentBar = document.getElementById("alignment-bar");
         const floatingToolbar = document.getElementById("floating-toolbar");

         // Add hover listeners to keep toolbars alive
         function pauseAutoHide() {
            if (floatingToolbarIdleTimer) clearTimeout(floatingToolbarIdleTimer);
            if (floatingToolbarMoveAwayTimer) clearTimeout(floatingToolbarMoveAwayTimer);
         }

         function resumeAutoHide() {
            // Restart 3s timer
            if (floatingToolbarIdleTimer) clearTimeout(floatingToolbarIdleTimer);
            floatingToolbarIdleTimer = setTimeout(() => {
               isFloatingToolbarForceHidden = true;
               render();
            }, 3000);
         }

         [alignmentBar, floatingToolbar].forEach((el) => {
            if (el) {
               el.addEventListener("mouseenter", pauseAutoHide);
               el.addEventListener("mouseleave", resumeAutoHide);
            }
         });

         const plusIconTooltip = document.getElementById("plus-icon-tooltip");

         // --- Application State ---
         let shapes = [];
         let historyStack = [];
         let historyStep = -1;
         const MAX_HISTORY = 40;

         let currentTool = "select";
         let isToolLocked = false;
         let isBold = true;
         let currentColor = "#000000";
         let currentFillColor = "transparent";
         let currentWidth = 2;

         let isDragging = false;
         let startPos = { x: 0, y: 0 };

         // Interaction State
         let currentShape = null;
         let selectedIndices = new Set();
         let selectionQueue = []; // Explicit chronological order
         let selectionBox = null;

         function clearSelection() {
            selectedIndices.clear();
            selectionQueue = [];
            // Reset hover state when selection is cleared
            hoveredSide = null;
            hoveredRectIndex = null;
         }

         // Floating Toolbar Auto-Hide State
         let floatingToolbarIdleTimer = null;
         let floatingToolbarMoveAwayTimer = null;
         let prevFloatingToolbarDist = Infinity;
         let isFloatingToolbarForceHidden = false;

         function addToSelection(idx) {
            // Reset auto-hide state when selection changes
            isFloatingToolbarForceHidden = false;
            prevFloatingToolbarDist = Infinity;
            if (floatingToolbarIdleTimer) clearTimeout(floatingToolbarIdleTimer);
            if (floatingToolbarMoveAwayTimer) clearTimeout(floatingToolbarMoveAwayTimer);

            // Start idle timer immediately
            floatingToolbarIdleTimer = setTimeout(() => {
               isFloatingToolbarForceHidden = true;
               render();
            }, 3000);

            if (!selectedIndices.has(idx)) {
               selectedIndices.add(idx);
               // Ensure unique in queue
               if (!selectionQueue.includes(idx)) {
                  selectionQueue.push(idx);
               }
            }
         }

         function removeFromSelection(idx) {
            selectedIndices.delete(idx);
            selectionQueue = selectionQueue.filter((i) => i !== idx);
         }

         let arrowCreationPhase = "idle";

         // Laser Tool State
         let laserShapes = []; // Array to store laser shapes with timestamps
         const LASER_LIFETIME = 2000; // Laser lines last 2 seconds
         const LASER_DELETE_DELAY = 500; // Start deleting after 0.5 seconds
         const LASER_DELETE_DURATION = 1000; // Delete over 1 second
         const LASER_MAX_TAIL = 100; // Maximum points in laser tail

         // Shape Recognition Undo Panel State
         let originalPencilShape = null; // Store original pencil shape for undo
         let convertedShapeIndex = -1; // Index of the converted shape in shapes array
         let shapeRecognitionPanelTimer = null; // Timer for auto-hiding panel

         // Manipulation State
         let isManipulatingHandle = false;
         let isMovingSelection = false;
         let isBoxSelecting = false;
         let isDuplicating = false;
         let activeHandle = null;
         let moveOffset = { x: 0, y: 0 };
         let initialShapeState = null;
         let temporarilyDisconnectedShapes = new Map(); // Store broken connections during movement

         // Rotation State
         let isRotating = false;
         let rotationStartAngle = 0;
         let groupRotationAngle = 0;
         let rotationCenter = { x: 0, y: 0 };
         let initialShapeAngle = 0;
         let initialAngles = new Map();

         // Rectangle Plus Icon State (for creating connected rectangles)
         let hoveredSide = null; // 'top', 'right', 'bottom', 'left', or null
         let hoveredRectIndex = null; // Index of rectangle being hovered

         // Connection hover state
         let connectionHoverShape = null; // Shape being hovered during line/arrow connection

         // Context Menu State
         let contextMenuTarget = null;

         // Text Editing
         let isTyping = false;
         let isFinishingText = false;
         let activeInput = null;

         // Touch Debounce State
         let lastConnectorClickTime = 0; // Prevent ghost clicks on connectors

         // --- Camera / Transformation State ---
         let camera = {
            x: 0,
            y: 0,
            scale: 1,
            isPanning: false,
         };

         // Pinch-to-Zoom State (for mobile/tablet)
         let isPinching = false;
         let pinchStartDistance = 0;
         let pinchStartScale = 1;
         let pinchStartCenter = { x: 0, y: 0 };
         let pinchStartCameraX = 0;
         let pinchStartCameraY = 0;

         function toWorld(screenX, screenY) {
            return {
               x: (screenX - camera.x) / camera.scale,
               y: (screenY - camera.y) / camera.scale,
            };
         }

         function toScreen(worldX, worldY) {
            return {
               x: worldX * camera.scale + camera.x,
               y: worldY * camera.scale + camera.y,
            };
         }

         function generateId() {
            return "shape_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
         }

         // --- Core Engine ---

         function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + "px";
            canvas.style.height = window.innerHeight + "px";
            ctx.scale(dpr, dpr);
            render();
         }
         window.addEventListener("resize", resizeCanvas);

         // --- Interaction Logic ---

         canvas.addEventListener(
            "wheel",
            (e) => {
               if (e.ctrlKey) {
                  e.preventDefault();
                  const zoomSpeed = 0.001;
                  const delta = -e.deltaY;
                  const factor = Math.pow(1.1, delta / 100);

                  const rect = canvas.getBoundingClientRect();
                  const mouseX = e.clientX - rect.left;
                  const mouseY = e.clientY - rect.top;

                  // Position before zoom
                  const worldPos = toWorld(mouseX, mouseY);

                  camera.scale *= factor;
                  // Limit scale
                  camera.scale = Math.min(Math.max(0.1, camera.scale), 20);

                  // Re-position after zoom to keep mouse fixed in world
                  const newScreenPos = toScreen(worldPos.x, worldPos.y);
                  camera.x -= newScreenPos.x - mouseX;
                  camera.y -= newScreenPos.y - mouseY;

                  render();
               }
            },
            { passive: false },
         );

         function render() {
            const dpr = window.devicePixelRatio || 1;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawGrid();

            // Apply Camera Transform
            ctx.setTransform(
               camera.scale * dpr,
               0,
               0,
               camera.scale * dpr,
               camera.x * dpr,
               camera.y * dpr,
            );

            // Draw Shapes
            shapes.forEach((shape, index) => {
               const isSelected = selectedIndices.has(index);
               const isConnectionHover =
                  connectionHoverShape && connectionHoverShape.id === shape.id;
               drawShape(shape, isSelected);

               // Draw highlight effect for connection hover
               if (isConnectionHover && !isSelected) {
                  const b = getBoundingBox(shape);
                  ctx.save();
                  ctx.strokeStyle = "#3b82f6";
                  ctx.lineWidth = 3 / camera.scale;
                  ctx.setLineDash([]);
                  ctx.globalAlpha = 0.6;

                  if (shape.type === "circle") {
                     const centerX = b.x + b.w / 2;
                     const centerY = b.y + b.h / 2;
                     const radiusX = Math.abs(b.w) / 2;
                     const radiusY = Math.abs(b.h) / 2;
                     ctx.beginPath();
                     ctx.ellipse(
                        centerX,
                        centerY,
                        radiusX + 4 / camera.scale,
                        radiusY + 4 / camera.scale,
                        0,
                        0,
                        Math.PI * 2,
                     );
                     ctx.stroke();
                  } else if (shape.type === "rhombus") {
                     // Rhombus (Parallelogram) highlight with padding
                     const padding = 4 / camera.scale;
                     const x = shape.x;
                     const y = shape.y;
                     const w = shape.w;
                     const h = shape.h;
                     const skew = w * 0.1;

                     ctx.beginPath();
                     // Calculate vertices of the shape and shift them outward by padding
                     if (w > 0) {
                        // Slanted Right
                        // P1 (TL), P2 (TR), P3 (BR), P4 (BL)
                        ctx.moveTo(x + skew - padding, y - padding); // TL: left-up
                        ctx.lineTo(x + w + padding, y - padding); // TR: right-up
                        ctx.lineTo(x + w - skew + padding, y + h + padding); // BR: right-down
                        ctx.lineTo(x - padding, y + h + padding); // BL: left-down
                     } else {
                        // Slanted Left (w is negative, skew is negative)
                        // P2 (TL), P1 (TR), P4 (BR), P3 (BL) in visual space?
                        // Let's stick to the points order in drawShape but apply correct offsets
                        // P1 (x+skew, y): Top-Right visual (closer to 0). Offset: (+p, -p)
                        // P2 (x+w, y): Top-Left visual (furthest neg). Offset: (-p, -p)
                        // P3 (x+w-skew, y+h): Bot-Left visual. Offset: (-p, +p)
                        // P4 (x, y+h): Bot-Right visual. Offset: (+p, +p)

                        ctx.moveTo(x + skew + padding, y - padding); // P1 (TR)
                        ctx.lineTo(x + w - padding, y - padding); // P2 (TL)
                        ctx.lineTo(x + w - skew - padding, y + h + padding); // P3 (BL)
                        ctx.lineTo(x + padding, y + h + padding); // P4 (BR)
                     }
                     ctx.closePath();
                     ctx.stroke();
                  } else if (shape.type === "triangle") {
                     const padding = 4 / camera.scale;
                     const signX = shape.w >= 0 ? 1 : -1;
                     const signY = shape.h >= 0 ? 1 : -1;

                     ctx.beginPath();
                     ctx.moveTo(shape.x + shape.w / 2, shape.y - padding * signY);
                     ctx.lineTo(
                        shape.x + shape.w + padding * signX,
                        shape.y + shape.h + padding * signY,
                     );
                     ctx.lineTo(shape.x - padding * signX, shape.y + shape.h + padding * signY);
                     ctx.closePath();
                     ctx.stroke();
                  } else if (shape.type === "diamond") {
                     const centerX = b.x + b.w / 2;
                     const centerY = b.y + b.h / 2;
                     const hw = Math.abs(b.w) / 2 + 4 / camera.scale;
                     const hh = Math.abs(b.h) / 2 + 4 / camera.scale;
                     ctx.beginPath();
                     ctx.moveTo(centerX, centerY - hh);
                     ctx.lineTo(centerX + hw, centerY);
                     ctx.lineTo(centerX, centerY + hh);
                     ctx.lineTo(centerX - hw, centerY);
                     ctx.closePath();
                     ctx.stroke();
                  } else {
                     const padding = 4 / camera.scale;
                     ctx.strokeRect(
                        b.x - padding,
                        b.y - padding,
                        b.w + padding * 2,
                        b.h + padding * 2,
                     );
                  }

                  ctx.restore();
               }
            });

            // Draw Group Selection Handles
            if (currentTool === "select" && selectedIndices.size > 1) {
               if (isRotating && initialGroupBounds) {
                  drawSelectionHandles({
                     ...initialGroupBounds,
                     angle: groupRotationAngle,
                     type: "group_handle_drawing",
                  });
               } else {
                  const groupBounds = getSelectionBounds();
                  if (groupBounds) {
                     drawSelectionHandles({
                        ...groupBounds,
                        type: "group_handle_drawing",
                     });
                  }
               }
            }

            // Draw Laser Shapes (temporary, auto-deleting)
            laserShapes.forEach((laserShape) => {
               drawShape(laserShape, false);
            });

            // Draw Ghost Shape
            if (currentShape) {
               drawShape(currentShape, false);
            }

            // Draw Selection Box
            if (selectionBox) {
               ctx.save();
               ctx.strokeStyle = "#3b82f6";
               ctx.fillStyle = "rgba(59, 130, 246, 0.1)";
               ctx.lineWidth = 1 / camera.scale; // Adjust width for zoom
               ctx.setLineDash([4 / camera.scale, 4 / camera.scale]);
               const x = Math.min(selectionBox.start.x, selectionBox.end.x);
               const y = Math.min(selectionBox.start.y, selectionBox.end.y);
               const w = Math.abs(selectionBox.end.x - selectionBox.start.x);
               const h = Math.abs(selectionBox.end.y - selectionBox.start.y);
               ctx.fillRect(x, y, w, h);
               ctx.strokeRect(x, y, w, h);
               ctx.restore();
            }

            // Draw plus icons for selected rectangles and circles
            if (currentTool === "select" && selectedIndices.size === 1) {
               const idx = selectedIndices.values().next().value;
               const shape = shapes[idx];

               // Check if device is likely touch (no fine pointer)
               const isTouchDevice =
                  window.matchMedia("(pointer: coarse)").matches || "ontouchstart" in window;

               if (
                  shape &&
                  (shape.type === "rect" ||
                     shape.type === "circle" ||
                     shape.type === "oval" ||
                     shape.type === "rhombus" ||
                     shape.type === "diamond")
               ) {
                  const sides = ["top", "bottom", "left", "right"];
                  let tooltipVisible = false;

                  sides.forEach((side) => {
                     const iconPos = getPlusIconPosition(shape, side);
                     if (iconPos) {
                        if (hoveredSide === side) {
                           drawPlusIcon(ctx, iconPos.x, iconPos.y, side);

                           if (!isTouchDevice) {
                              const shortcuts = {
                                 top: "Ctrl+",
                                 bottom: "Ctrl+",
                                 left: "Ctrl+",
                                 right: "Ctrl+",
                              };
                              plusIconTooltip.textContent = shortcuts[side] || "";

                              const screenPos = toScreen(iconPos.x, iconPos.y);
                              const tooltipOffset = 20;

                              if (side === "top") {
                                 plusIconTooltip.style.left = screenPos.x + "px";
                                 plusIconTooltip.style.top = screenPos.y - tooltipOffset + "px";
                                 plusIconTooltip.style.transform = "translate(-50%, -100%)";
                              } else if (side === "bottom") {
                                 plusIconTooltip.style.left = screenPos.x + "px";
                                 plusIconTooltip.style.top = screenPos.y + tooltipOffset + "px";
                                 plusIconTooltip.style.transform = "translateX(-50%)";
                              } else if (side === "left") {
                                 plusIconTooltip.style.left = screenPos.x - tooltipOffset + "px";
                                 plusIconTooltip.style.top = screenPos.y + "px";
                                 plusIconTooltip.style.transform = "translate(-100%, -50%)";
                              } else if (side === "right") {
                                 plusIconTooltip.style.left = screenPos.x + tooltipOffset + "px";
                                 plusIconTooltip.style.top = screenPos.y + "px";
                                 plusIconTooltip.style.transform = "translateY(-50%)";
                              }

                              plusIconTooltip.classList.add("visible");
                              tooltipVisible = true;
                           }
                        } else {
                           if (isTouchDevice) {
                              drawPlusIcon(ctx, iconPos.x, iconPos.y, side);
                           } else {
                              drawDot(ctx, iconPos.x, iconPos.y);
                           }
                        }
                     }
                  });

                  if (!tooltipVisible) {
                     plusIconTooltip.classList.remove("visible");
                  }
               } else {
                  plusIconTooltip.classList.remove("visible");
               }
            } else {
               plusIconTooltip.classList.remove("visible");
            }

            // Update Zoom Display
            const zoomEl = document.getElementById("zoom-percentage");
            if (zoomEl) {
               zoomEl.textContent = Math.round(camera.scale * 100) + "%";
            }

            // Update UI (buttons and bars) remains in screen coordinates
            // Reset transform for UI-like logic if needed, but here it's just toggling classes

            if (selectedIndices.size > 1 && !isFloatingToolbarForceHidden) {
               alignmentBar.classList.remove("hidden");
               alignmentBar.classList.add("flex");
            } else {
               alignmentBar.classList.add("hidden");
               alignmentBar.classList.remove("flex");
            }

            updateFloatingToolbar();
         }

         function drawGrid() {
            const dpr = window.devicePixelRatio || 1;
            const gridSize = 50 * camera.scale * dpr;
            const offsetX = (camera.x * dpr) % gridSize;
            const offsetY = (camera.y * dpr) % gridSize;

            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.beginPath();
            ctx.strokeStyle = "#fafbfc"; // Very light grid color
            ctx.lineWidth = 0.5;
            ctx.globalAlpha = 0.4;

            // Vertical lines
            for (let x = offsetX; x <= canvas.width; x += gridSize) {
               ctx.moveTo(x, 0);
               ctx.lineTo(x, canvas.height);
            }

            // Horizontal lines
            for (let y = offsetY; y <= canvas.height; y += gridSize) {
               ctx.moveTo(0, y);
               ctx.lineTo(canvas.width, y); // Corrected from canvas.height to canvas.width for horizontal lines
            }
            ctx.stroke();
            ctx.restore();
         }

         // Catmull-Rom spline interpolation for ultra-smooth curves
         function catmullRom(p0, p1, p2, p3, t) {
            const t2 = t * t;
            const t3 = t2 * t;
            return (
               0.5 *
               (2 * p1 +
                  (-p0 + p2) * t +
                  (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
                  (-p0 + 3 * p1 - 3 * p2 + p3) * t3)
            );
         }

         function drawShape(shape, isSelected) {
            ctx.save();
            // Apply Rotation
            if (shape.angle) {
               const b = getBoundingBox(shape);
               const cx = b.x + b.w / 2;
               const cy = b.y + b.h / 2;
               ctx.translate(cx, cy);
               ctx.rotate(shape.angle);
               ctx.translate(-cx, -cy);
            }

            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            // Apply eraser fade-out opacity if shape is being erased
            if (shape.eraserOpacity !== undefined && shape.eraserOpacity < 1) {
               ctx.globalAlpha = shape.eraserOpacity;
            }

            ctx.strokeStyle = shape.color;
            ctx.lineWidth = shape.width;
            ctx.fillStyle = shape.fillColor || "transparent";

            // Apply dotted line style if shape is marked as dotted
            if (shape.isDotted) {
               ctx.setLineDash([4 / camera.scale, 12 / camera.scale]);
            }

            const isFilled = shape.fillColor && shape.fillColor !== "transparent";
            const isStroked = shape.color && shape.color !== "transparent";

            if (shape.type === "laser") {
               // Draw laser with ultra-smooth Catmull-Rom splines
               if (shape.points.length > 1) {
                  const deletedCount = shape.deletedCount || 0;
                  const visiblePoints = shape.points.slice(deletedCount);
                  const tailOpacity = shape.tailOpacity !== undefined ? shape.tailOpacity : 1;

                  if (visiblePoints.length > 1) {
                     // Use Catmull-Rom for ultra-smooth interpolation
                     const r = parseInt(shape.color.slice(1, 3), 16);
                     const g = parseInt(shape.color.slice(3, 5), 16);
                     const b = parseInt(shape.color.slice(5, 7), 16);

                     // Draw segments with interpolation
                     for (let i = 0; i < visiblePoints.length - 1; i++) {
                        const p0 = visiblePoints[Math.max(0, i - 1)];
                        const p1 = visiblePoints[i];
                        const p2 = visiblePoints[i + 1];
                        const p3 = visiblePoints[Math.min(visiblePoints.length - 1, i + 2)];

                        const progress = i / Math.max(1, visiblePoints.length - 1);
                        const alpha = Math.max(
                           0,
                           Math.min(0.8, 0.8 * Math.sin(progress * Math.PI)) * tailOpacity,
                        );

                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        ctx.lineWidth = shape.width * (0.7 + 0.6 * progress);

                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);

                        // Interpolate with 10 sub-segments for smoothness
                        for (let t = 0.1; t <= 1; t += 0.1) {
                           const x = catmullRom(p0.x, p1.x, p2.x, p3.x, t);
                           const y = catmullRom(p0.y, p1.y, p2.y, p3.y, t);
                           ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                     }
                  }
               }
            } else if (shape.type === "pencil" || shape.type === "pencil-arrow") {
               if (shape.points.length > 1) {
                  // Use Catmull-Rom for ultra-smooth interpolation
                  // Draw segments with interpolation
                  for (let i = 0; i < shape.points.length - 1; i++) {
                     const p0 = shape.points[Math.max(0, i - 1)];
                     const p1 = shape.points[i];
                     const p2 = shape.points[i + 1];
                     const p3 = shape.points[Math.min(shape.points.length - 1, i + 2)];

                     if (i === 0) {
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                     }

                     // Interpolate with 10 sub-segments for smoothness
                     for (let t = 0.1; t <= 1; t += 0.1) {
                        const x = catmullRom(p0.x, p1.x, p2.x, p3.x, t);
                        const y = catmullRom(p0.y, p1.y, p2.y, p3.y, t);
                        ctx.lineTo(x, y);
                     }
                  }
                  if (isStroked) ctx.stroke();
               } else if (shape.points.length === 1) {
                  ctx.beginPath();
                  ctx.moveTo(shape.points[0].x, shape.points[0].y);
                  ctx.lineTo(shape.points[0].x, shape.points[0].y);
                  if (isStroked) ctx.stroke();
               }

               // Draw start arrow if hasStartArrow is enabled
               if (shape.hasStartArrow && shape.points.length > 1) {
                  const points = shape.points;
                  const first = points[0];

                  // Calculate direction from first few points
                  let angleSum = 0;
                  let validAngles = 0;
                  const lookAheadCount = Math.min(5, points.length - 1);

                  for (let j = 1; j <= lookAheadCount; j++) {
                     const next = points[j];
                     if (next.x !== first.x || next.y !== first.y) {
                        const angle = Math.atan2(next.y - first.y, next.x - first.x);
                        angleSum += angle;
                        validAngles++;
                     }
                  }

                  if (validAngles > 0) {
                     const avgAngle = angleSum / validAngles;
                     ctx.fillStyle =
                        shape.color && shape.color !== "transparent" ? shape.color : "#000000";
                     drawArrowHead(ctx, first.x, first.y, avgAngle + Math.PI, shape.width * 5);
                  }
               }

               // Draw Arrow Head for Freehand Arrow (end arrow)
               const showEndArrow =
                  shape.hasEndArrow !== undefined
                     ? shape.hasEndArrow
                     : shape.type === "pencil-arrow";
               if (showEndArrow && shape.points.length > 1) {
                  const points = shape.points;
                  const last = points[points.length - 1];

                  // Calculate average direction from last 3-5 points for stable angle
                  let angleSum = 0;
                  let validAngles = 0;
                  const lookBackCount = Math.min(5, points.length - 1);

                  for (let j = 1; j <= lookBackCount; j++) {
                     const idx = Math.max(0, points.length - 1 - j);
                     const prev = points[idx];

                     if (prev.x !== last.x || prev.y !== last.y) {
                        const angle = Math.atan2(last.y - prev.y, last.x - prev.x);
                        angleSum += angle;
                        validAngles++;
                     }
                  }

                  if (validAngles > 0) {
                     const avgAngle = angleSum / validAngles;
                     // Ensure fillStyle is set for arrowhead
                     ctx.fillStyle =
                        shape.color && shape.color !== "transparent" ? shape.color : "#000000";
                     drawArrowHead(ctx, last.x, last.y, avgAngle, shape.width * 5);
                  }
               }
            } else if (shape.type === "line") {
               ctx.beginPath();
               ctx.moveTo(shape.start.x, shape.start.y);
               ctx.lineTo(shape.end.x, shape.end.y);
               if (isStroked) ctx.stroke();

               // Draw arrows if enabled
               ctx.fillStyle =
                  shape.color && shape.color !== "transparent" ? shape.color : "#000000";
               if (shape.hasStartArrow) {
                  const dx = shape.end.x - shape.start.x;
                  const dy = shape.end.y - shape.start.y;
                  const angle = Math.atan2(dy, dx) + Math.PI;
                  drawArrowHead(ctx, shape.start.x, shape.start.y, angle, shape.width * 5);
               }
               if (shape.hasEndArrow) {
                  const dx = shape.end.x - shape.start.x;
                  const dy = shape.end.y - shape.start.y;
                  const angle = Math.atan2(dy, dx);
                  drawArrowHead(ctx, shape.end.x, shape.end.y, angle, shape.width * 5);
               }
            } else if (shape.type === "arrow") {
               ctx.beginPath();
               ctx.moveTo(shape.start.x, shape.start.y);
               const cp = shape.control || {
                  x: (shape.start.x + shape.end.x) / 2,
                  y: (shape.start.y + shape.end.y) / 2,
               };
               ctx.quadraticCurveTo(cp.x, cp.y, shape.end.x, shape.end.y);
               if (isStroked) ctx.stroke();

               // Ensure fillStyle is set for arrowheads
               ctx.fillStyle =
                  shape.color && shape.color !== "transparent" ? shape.color : "#000000";

               // Start Arrow
               if (shape.hasStartArrow) {
                  const dxS = cp.x - shape.start.x;
                  const dyS = cp.y - shape.start.y;
                  let angleS = Math.atan2(dyS, dxS) + Math.PI;
                  if (dxS === 0 && dyS === 0) {
                     angleS =
                        Math.atan2(shape.end.y - shape.start.y, shape.end.x - shape.start.x) +
                        Math.PI;
                  }
                  drawArrowHead(ctx, shape.start.x, shape.start.y, angleS, shape.width * 5);
               }

               // End Arrow
               const showEndArrow = shape.hasEndArrow !== undefined ? shape.hasEndArrow : true;
               if (showEndArrow) {
                  const dx = shape.end.x - cp.x;
                  const dy = shape.end.y - cp.y;
                  let angle = Math.atan2(dy, dx);
                  if (dx === 0 && dy === 0) {
                     angle = Math.atan2(shape.end.y - shape.start.y, shape.end.x - shape.start.x);
                  }
                  drawArrowHead(ctx, shape.end.x, shape.end.y, angle, shape.width * 5);
               }
            } else if (shape.type === "rect") {
               // Apply minor curve on corners
               const radius = 8;
               const r = Math.min(radius, Math.abs(shape.w) / 2, Math.abs(shape.h) / 2);

               ctx.beginPath();
               ctx.roundRect(shape.x, shape.y, shape.w, shape.h, r);
               if (isFilled) ctx.fill();
               if (isStroked) ctx.stroke();
            } else if (shape.type === "circle") {
               ctx.beginPath();
               const rx = Math.abs(shape.w / 2);
               const ry = Math.abs(shape.h / 2);
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
               if (isFilled) ctx.fill();
               if (isStroked) ctx.stroke();
            } else if (shape.type === "triangle") {
               ctx.beginPath();
               ctx.moveTo(shape.x + shape.w / 2, shape.y);
               ctx.lineTo(shape.x + shape.w, shape.y + shape.h);
               ctx.lineTo(shape.x, shape.y + shape.h);
               ctx.closePath();
               if (isFilled) ctx.fill();
               if (isStroked) ctx.stroke();
            } else if (shape.type === "oval") {
               ctx.beginPath();
               // Stadium shape using roundRect
               const radius = Math.min(Math.abs(shape.w), Math.abs(shape.h)) / 2;
               ctx.roundRect(shape.x, shape.y, shape.w, shape.h, radius);
               if (isFilled) ctx.fill();
               if (isStroked) ctx.stroke();
            } else if (shape.type === "rhombus") {
               ctx.beginPath();
               // Parallelogram shape (skewed rectangle)
               const skew = shape.w * 0.1;
               // Ensure skew direction works well with negative width/height
               // Or just normalize coordinates. We use shape.x, shape.w directly.

               // Points: Top-Left(skewed), Top-Right, Bottom-Right(skewed), Bottom-Left
               const x = shape.x;
               const y = shape.y;
               const w = shape.w;
               const h = shape.h;

               // To make it look right regardless of drag direction, we should probably normalize.
               // But existing shapes handle negative w/h gracefully by ctx.rect logic mostly.
               // Let's manually calculate vertices.

               ctx.moveTo(x + skew, y);
               ctx.lineTo(x + w, y);
               ctx.lineTo(x + w - skew, y + h);
               ctx.lineTo(x, y + h);
               ctx.closePath();

               if (isFilled) ctx.fill();
               if (isStroked) ctx.stroke();
            } else if (shape.type === "diamond") {
               ctx.beginPath();
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               ctx.moveTo(cx, shape.y); // Top
               ctx.lineTo(shape.x + shape.w, cy); // Right
               ctx.lineTo(cx, shape.y + shape.h); // Bottom
               ctx.lineTo(shape.x, cy); // Left
               ctx.closePath();
               if (isFilled) ctx.fill();
               if (isStroked) ctx.stroke();
            } else if (shape.type === "text") {
               const fontWeight = shape.isBold !== false ? "bold" : "normal";
               ctx.font = `${fontWeight} ${shape.size}px 'Caveat', cursive`;
               ctx.textBaseline = "top";
               ctx.fillStyle = shape.color; // Text uses 'color' (stroke) for filling characters
               if (isStroked) {
                  const lines = shape.text.split("\n");
                  const lineHeight = shape.size;
                  lines.forEach((line, i) => {
                     ctx.fillText(line, shape.x, shape.y + i * lineHeight);
                     
                     // Enhance visibility for both bold and normal text
                     ctx.strokeStyle = shape.color;
                     const isBold = shape.isBold !== false;
                     // Thicker stroke for bold, lighter stroke for normal to reduce narrowness
                     const strokeDivisor = isBold ? 40 : 100; 
                     ctx.lineWidth = Math.max(isBold ? 0.5 : 0.3, shape.size / strokeDivisor);
                     ctx.strokeText(line, shape.x, shape.y + i * lineHeight);
                  });
               }
            } else if (shape.type === "image") {
               if (shape.image && shape.image.complete) {
                  ctx.drawImage(shape.image, shape.x, shape.y, shape.w, shape.h);
               } else {
                  // Placeholder while loading
                  ctx.fillStyle = "#e5e7eb";
                  ctx.fillRect(shape.x, shape.y, shape.w, shape.h);
                  ctx.strokeStyle = "#9ca3af";
                  ctx.strokeRect(shape.x, shape.y, shape.w, shape.h);
               }
            }

            // Draw inner text for shapes (rect, circle, triangle, oval, rhombus, diamond)
            if (
               (shape.type === "rect" ||
                  shape.type === "circle" ||
                  shape.type === "triangle" ||
                  shape.type === "oval" ||
                  shape.type === "rhombus" ||
                  shape.type === "diamond" ||
                  shape.type === "line" ||
                  shape.type === "arrow") &&
               !shape.isEditingText
            ) {
               if (shape.innerText) {
                  ctx.save();
                  const fontWeight = shape.isBold !== false ? "bold" : "normal";
                  ctx.font = `${fontWeight} ${shape.innerTextSize || 20}px 'Caveat', cursive`;
                  ctx.textBaseline = "middle";
                  ctx.textAlign = "center";
                  ctx.fillStyle = shape.innerTextColor || "#000000";

                  // Calculate position (offset from center for lines/arrows to avoid obstruction)
                  let centerX, centerY;
                  if (shape.type === "line") {
                     const t = 0.35; // Place text at 35% of the line "before" the center
                     centerX = shape.start.x + (shape.end.x - shape.start.x) * t;
                     centerY = shape.start.y + (shape.end.y - shape.start.y) * t;
                  } else if (shape.type === "arrow") {
                     const t = 0.35; // Place text at 35% of the curve
                     const mt = 1 - t;
                     const cp = shape.control || {
                        x: (shape.start.x + shape.end.x) / 2,
                        y: (shape.start.y + shape.end.y) / 2,
                     };
                     centerX = mt * mt * shape.start.x + 2 * mt * t * cp.x + t * t * shape.end.x;
                     centerY = mt * mt * shape.start.y + 2 * mt * t * cp.y + t * t * shape.end.y;
                  } else {
                     centerX = shape.x + shape.w / 2;
                     centerY = shape.y + shape.h / 2;
                  }

                  // Draw white halo/padding behind text ONLY for lines and arrows
                  if (shape.type === "line" || shape.type === "arrow") {
                     ctx.lineJoin = "round";
                     ctx.miterLimit = 2;
                     ctx.strokeStyle = "#ffffff";
                     ctx.lineWidth = 6;
                     // ctx.strokeText(shape.innerText, centerX, centerY);
                  }

                  // ctx.fillText(shape.innerText, centerX, centerY);
                  
                  const lines = shape.innerText.split('\n');
                  const fontSize = shape.innerTextSize || 20;
                  const lineHeight = fontSize;
                  const startY = centerY - ((lines.length - 1) * lineHeight) / 2;
                  
                  lines.forEach((line, i) => {
                     const lineY = startY + i * lineHeight;
                     if (shape.type === "line" || shape.type === "arrow") {
                        // Ensure halo style is set/restored for each line
                        ctx.strokeStyle = "#ffffff";
                        ctx.lineWidth = 6;
                        ctx.strokeText(line, centerX, lineY);
                     }
                     ctx.fillText(line, centerX, lineY);

                     // Enhance text visibility
                     ctx.strokeStyle = shape.innerTextColor || "#000000";
                     const isBold = shape.isBold !== false;
                     // Thicker stroke for bold, lighter stroke for normal
                     const strokeDivisor = isBold ? 40 : 100;
                     ctx.lineWidth = Math.max(isBold ? 0.5 : 0.3, fontSize / strokeDivisor);
                     ctx.strokeText(line, centerX, lineY);
                  });

                  ctx.restore();
               } else if (isSelected) {
                   ctx.save();
                   // Placeholder caption
                   ctx.font = `italic 10px sans-serif`; 
                   ctx.textBaseline = "middle";
                   ctx.textAlign = "center";
                   ctx.fillStyle = "rgba(156, 163, 175, 0.6)"; // Very light color

                   let centerX, centerY;
                   if (shape.type === "line") {
                      const t = 0.5; // Center for placeholder
                      centerX = shape.start.x + (shape.end.x - shape.start.x) * t;
                      centerY = shape.start.y + (shape.end.y - shape.start.y) * t;
                   } else if (shape.type === "arrow") {
                      const t = 0.5; // Center for placeholder
                      const mt = 1 - t;
                      const cp = shape.control || {
                         x: (shape.start.x + shape.end.x) / 2,
                         y: (shape.start.y + shape.end.y) / 2,
                      };
                      centerX = mt * mt * shape.start.x + 2 * mt * t * cp.x + t * t * shape.end.x;
                      centerY = mt * mt * shape.start.y + 2 * mt * t * cp.y + t * t * shape.end.y;
                   } else {
                      centerX = shape.x + shape.w / 2;
                      centerY = shape.y + shape.h / 2;
                   }
                   
                   ctx.fillText("Add Text", centerX, centerY);
                   ctx.restore();
               }
            }

            ctx.restore();

            if (isSelected) {
               if (selectedIndices.size === 1) {
                  drawSelectionHandles(shape);
               } else {
                  // Only draw individual bounds if not rotating, to treat group as single object visually
                  if (!isRotating) {
                     drawSimpleBoundingBox(shape);
                  }
               }
            }
         }

         function drawArrowHead(ctx, x, y, angle, size) {
            ctx.save();
            ctx.setLineDash([]); // Force solid line for arrowheads
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            // Draw minimal line arrow (two lines forming a V shape)
            ctx.moveTo(-size, -size / 2);
            ctx.lineTo(0, 0);
            ctx.lineTo(-size, size / 2);
            ctx.stroke();
            ctx.restore();
         }

         function drawSimpleBoundingBox(shape) {
            ctx.save();
            if (shape.angle) {
               const b = getBoundingBox(shape);
               const cx = b.x + b.w / 2;
               const cy = b.y + b.h / 2;
               ctx.translate(cx, cy);
               ctx.rotate(shape.angle);
               ctx.translate(-cx, -cy);
            }
            ctx.strokeStyle = "#3b82f6";
            ctx.lineWidth = 2 / camera.scale; // Adjust for zoom
            ctx.setLineDash([4 / camera.scale, 4 / camera.scale]); // Adjust dash for zoom
            const b = getBoundingBox(shape);
            const padding = 5 / camera.scale; // Adjust padding for zoom
            if (
               shape.type === "pencil" ||
               shape.type === "pencil-arrow" ||
               shape.type === "line" ||
               shape.type === "arrow"
            ) {
               ctx.strokeRect(b.x - padding, b.y - padding, b.w + padding * 2, b.h + padding * 2);
            } else if (shape.type === "text") {
               const fontWeight = shape.isBold !== false ? "bold" : "normal";
               ctx.font = `${fontWeight} ${shape.size}px 'Caveat', cursive`;
               ctx.textBaseline = "top";
               // const m = ctx.measureText(shape.text);
               const lines = shape.text.split('\n');
               let maxWidth = 0;
               lines.forEach(line => {
                   const m = ctx.measureText(line);
                   maxWidth = Math.max(maxWidth, m.width);
               });
               const totalHeight = lines.length * shape.size;

               ctx.strokeRect(
                  shape.x - padding,
                  shape.y - padding,
                  maxWidth + padding * 2,
                  totalHeight + padding * 2,
               );
            } else {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);
               ctx.strokeRect(x - padding, y - padding, w + padding * 2, h + padding * 2);
            }
            ctx.restore();
         }

         function drawSelectionHandles(shape) {
            ctx.save();
            if (shape.angle) {
               const b = getBoundingBox(shape);
               const cx = b.x + b.w / 2;
               const cy = b.y + b.h / 2;
               ctx.translate(cx, cy);
               ctx.rotate(shape.angle);
               ctx.translate(-cx, -cy);
            }
            ctx.fillStyle = "#ffffff";
            ctx.strokeStyle = "#3b82f6";
            ctx.lineWidth = 2 / camera.scale; // Adjust for zoom

            if (shape.type === "arrow" || shape.type === "line") {
               const cp = shape.control || {
                  x: (shape.start.x + shape.end.x) / 2,
                  y: (shape.start.y + shape.end.y) / 2,
               };
               drawHandle(shape.start.x, shape.start.y);
               drawHandle(shape.end.x, shape.end.y);
               if (shape.type === "arrow") {
                  if (!(shape.startConnected && shape.endConnected)) {
                     ctx.fillStyle = "#fcd34d";
                     drawHandle(cp.x, cp.y);
                     ctx.setLineDash([4 / camera.scale, 4 / camera.scale]);
                     ctx.beginPath();
                     ctx.moveTo(shape.start.x, shape.start.y);
                     ctx.lineTo(cp.x, cp.y);
                     ctx.lineTo(shape.end.x, shape.end.y);
                     ctx.stroke();
                  }
               } else if (shape.type === "line") {
                  // Draw bend handle at midpoint ONLY if not connected at both ends
                  if (!(shape.startConnected && shape.endConnected)) {
                     ctx.fillStyle = "#fcd34d"; // Same yellow as control point
                     drawHandle(cp.x, cp.y);
                  }
               }
            } else {
               // Rect, Triangle, Circle, Text, Pencil, Pencil-Arrow, Image
               let x, y, w, h;

               if (
                  shape.type === "text" ||
                  shape.type === "pencil" ||
                  shape.type === "pencil-arrow" ||
                  shape.type === "image"
               ) {
                  const b = getBoundingBox(shape);
                  x = b.x;
                  y = b.y;
                  w = b.w;
                  h = b.h;
               } else {
                  x = shape.x;
                  y = shape.y;
                  w = shape.w;
                  h = shape.h;
               }

               const padding = 5 / camera.scale; // Adjust padding for zoom
               ctx.setLineDash([4 / camera.scale, 4 / camera.scale]);
               ctx.strokeRect(x - padding, y - padding, w + padding * 2, h + padding * 2);

               // Check visual size for Single Handle Mode
               const minVisualDim = Math.min(Math.abs(w), Math.abs(h)) * camera.scale;
               const isSmall = minVisualDim < 30;

               if (isSmall) {
                  // Single Handle Mode (Bottom-Right only)
                  drawHandle(x + w, y + h);
               } else {
                  // Corner handles
                  drawHandle(x, y);
                  drawHandle(x + w, y);
                  drawHandle(x, y + h);
                  drawHandle(x + w, y + h);
               }
            }
            ctx.restore();
         }

         function drawHandle(x, y) {
            const handleSize = 6 / camera.scale; // Adjust handle size for zoom
            ctx.beginPath();
            ctx.arc(x, y, handleSize, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
         }

         function drawSquareHandle(x, y, size) {
            ctx.fillRect(x - size, y - size, size * 2, size * 2);
            ctx.strokeRect(x - size, y - size, size * 2, size * 2);
         }

         // --- Rectangle & Circle Plus Icon Functions ---

         function detectHoveredSide(pos, shape) {
            let testPos = pos;
            if (shape.angle) {
               const b = getBoundingBox(shape);
               const cx = b.x + b.w / 2;
               const cy = b.y + b.h / 2;
               testPos = rotatePoint(pos, { x: cx, y: cy }, -shape.angle);
            }

            if (
               shape.type === "rect" ||
               shape.type === "rhombus" ||
               shape.type === "diamond" ||
               shape.type === "oval"
            ) {
               return detectHoveredSideForRect(testPos, shape);
            } else if (shape.type === "circle") {
               return detectHoveredSideForCircle(testPos, shape);
            }
            return null;
         }

         function detectHoveredSideForRect(pos, rectShape) {
            if (
               rectShape.type !== "rect" &&
               rectShape.type !== "rhombus" &&
               rectShape.type !== "diamond" &&
               rectShape.type !== "oval"
            )
               return null;

            const x = Math.min(rectShape.x, rectShape.x + rectShape.w);
            const y = Math.min(rectShape.y, rectShape.y + rectShape.h);
            const w = Math.abs(rectShape.w);
            const h = Math.abs(rectShape.h);

            const hoverThreshold = 30 / camera.scale; // Distance threshold for detecting hover
            const edgeThreshold = 10 / camera.scale; // Distance from edge to consider "near"

            // Check if point is near the rectangle
            const isNearRect =
               pos.x >= x - hoverThreshold &&
               pos.x <= x + w + hoverThreshold &&
               pos.y >= y - hoverThreshold &&
               pos.y <= y + h + hoverThreshold;

            if (!isNearRect) return null;

            // Calculate distances to each side
            const distToTop = Math.abs(pos.y - y);
            const distToBottom = Math.abs(pos.y - (y + h));
            const distToLeft = Math.abs(pos.x - x);
            const distToRight = Math.abs(pos.x - (x + w));

            // Check if point is within the rectangle bounds (exclude interior)
            const isInside =
               pos.x > x + edgeThreshold &&
               pos.x < x + w - edgeThreshold &&
               pos.y > y + edgeThreshold &&
               pos.y < y + h - edgeThreshold;

            if (isInside) return null;

            // Determine which side is closest
            const minDist = Math.min(distToTop, distToBottom, distToLeft, distToRight);

            if (minDist > hoverThreshold) return null;

            // Check if point is near the middle portion of a side (not corners)
            // Use dimension-specific thresholds to handle aspect ratios correctly
            const sideMiddleThresholdX = Math.max(w * 0.3, 15 / camera.scale);
            const sideMiddleThresholdY = Math.max(h * 0.3, 15 / camera.scale);

            if (distToTop === minDist) {
               const centerX = x + w / 2;
               if (Math.abs(pos.x - centerX) < sideMiddleThresholdX) {
                  return "top";
               }
            } else if (distToBottom === minDist) {
               const centerX = x + w / 2;
               if (Math.abs(pos.x - centerX) < sideMiddleThresholdX) {
                  return "bottom";
               }
            } else if (distToLeft === minDist) {
               const centerY = y + h / 2;
               if (Math.abs(pos.y - centerY) < sideMiddleThresholdY) {
                  return "left";
               }
            } else if (distToRight === minDist) {
               const centerY = y + h / 2;
               if (Math.abs(pos.y - centerY) < sideMiddleThresholdY) {
                  return "right";
               }
            }

            return null;
         }

         function drawPlusIcon(ctx, x, y, side) {
            const iconSize = 20 / camera.scale;
            const lineWidth = 2 / camera.scale;
            const radius = iconSize / 2;

            ctx.save();
            ctx.fillStyle = "#ffffff";
            ctx.strokeStyle = "#3b82f6";
            ctx.lineWidth = lineWidth;

            // Draw circle background
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            // Draw plus sign
            ctx.strokeStyle = "#3b82f6";
            ctx.lineWidth = lineWidth * 1.5;
            ctx.lineCap = "round";

            const plusSize = radius * 0.6;
            ctx.beginPath();
            ctx.moveTo(x - plusSize, y);
            ctx.lineTo(x + plusSize, y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x, y - plusSize);
            ctx.lineTo(x, y + plusSize);
            ctx.stroke();

            ctx.restore();
         }

         function drawDot(ctx, x, y) {
            const dotSize = 8 / camera.scale;
            const radius = dotSize / 2;

            ctx.save();
            ctx.fillStyle = "#3b82f6"; // Blue color
            
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.restore();
         }

         function detectHoveredSideForCircle(pos, circleShape) {
            if (circleShape.type !== "circle") return null;

            const cx = circleShape.x + circleShape.w / 2;
            const cy = circleShape.y + circleShape.h / 2;
            const rx = Math.abs(circleShape.w / 2);
            const ry = Math.abs(circleShape.h / 2);

            // Calculate distance from center
            const dx = pos.x - cx;
            const dy = pos.y - cy;
            const distFromCenter = Math.hypot(dx / rx, dy / ry);

            const hoverThreshold = 30 / camera.scale; // Distance threshold for detecting hover
            const edgeThreshold = 0.1; // Distance from edge (normalized) to consider "near"

            // Check if point is near the circle edge
            const isNearEdge = Math.abs(distFromCenter - 1) * Math.max(rx, ry) < hoverThreshold;
            const isInside = distFromCenter < 1 - edgeThreshold;

            if (!isNearEdge || isInside) return null;

            // Determine which side based on angle
            // Math.atan2(dy, dx) returns: top=-90(270), right=0, bottom=90, left=180(-180)
            const angle = Math.atan2(dy, dx);
            let angleDeg = (angle * 180) / Math.PI;
            if (angleDeg < 0) angleDeg += 360; // Normalize to 0-360

            // Check if point is near the middle portion of a side (not corners)
            const cornerThreshold = 30; // degrees from cardinal directions

            // Top: around 270 (or -90 normalized to 270)
            if (angleDeg >= 270 - cornerThreshold && angleDeg <= 270 + cornerThreshold) {
               return "top";
            }
            // Right: around 0 (or 360)
            else if (angleDeg >= 360 - cornerThreshold || angleDeg <= cornerThreshold) {
               return "right";
            }
            // Bottom: around 90
            else if (angleDeg >= 90 - cornerThreshold && angleDeg <= 90 + cornerThreshold) {
               return "bottom";
            }
            // Left: around 180
            else if (angleDeg >= 180 - cornerThreshold && angleDeg <= 180 + cornerThreshold) {
               return "left";
            }

            return null;
         }

         function getPlusIconPosition(shape, side) {
            const pos = getUnrotatedPlusIconPosition(shape, side);
            if (!pos) return null;
            
            if (shape.angle) {
               const b = getBoundingBox(shape);
               const cx = b.x + b.w / 2;
               const cy = b.y + b.h / 2;
               return rotatePoint(pos, { x: cx, y: cy }, shape.angle);
            }
            return pos;
         }

         function getUnrotatedPlusIconPosition(shape, side) {
            const offset = 30 / camera.scale; // Distance from shape edge

            if (shape.type === "rect" || shape.type === "diamond" || shape.type === "oval") {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);

               switch (side) {
                  case "top":
                     return { x: x + w / 2, y: y - offset };
                  case "right":
                     return { x: x + w + offset, y: y + h / 2 };
                  case "bottom":
                     return { x: x + w / 2, y: y + h + offset };
                  case "left":
                     return { x: x - offset, y: y + h / 2 };
                  default:
                     return null;
               }
            } else if (shape.type === "rhombus") {
               // Parallelogram plus icons
               const x = shape.x;
               const y = shape.y;
               const w = shape.w;
               const h = shape.h;
               const skew = w * 0.1;

               // Note: coordinates might be negative if drawn backwards, but shape.x is start.
               // Assuming standard drawing for now, or normalization.
               // Let's use bounding box center logic but shifted.

               // Top edge center: x + skew + (w-skew)/2 = x + skew/2 + w/2
               // Bottom edge center: x + (w-skew)/2 = x + w/2 - skew/2
               // Left edge vertical center: y + h/2. X at center height: x + skew * 0.5? No.
               // Left edge goes from (x, y+h) to (x+skew, y).
               // At y+h/2, x is (x + (x+skew))/2 = x + skew/2.
               // Right edge goes from (x+w-skew, y+h) to (x+w, y).
               // At y+h/2, x is x + w - skew/2.

               switch (side) {
                  case "top":
                     return { x: x + w / 2 + skew / 2, y: y - offset };
                  case "bottom":
                     return { x: x + w / 2 - skew / 2, y: y + h + offset };
                  case "left":
                     return { x: x + skew / 2 - offset, y: y + h / 2 };
                  case "right":
                     return { x: x + w - skew / 2 + offset, y: y + h / 2 };
                  default:
                     return null;
               }
            } else if (shape.type === "circle") {
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               const rx = Math.abs(shape.w / 2);
               const ry = Math.abs(shape.h / 2);
               const radius = Math.max(rx, ry);

               switch (side) {
                  case "top":
                     return { x: cx, y: cy - radius - offset };
                  case "right":
                     return { x: cx + radius + offset, y: cy };
                  case "bottom":
                     return { x: cx, y: cy + radius + offset };
                  case "left":
                     return { x: cx - radius - offset, y: cy };
                  default:
                     return null;
               }
            }

            return null;
         }

         function isPointOnPlusIcon(pos, iconPos) {
            if (!iconPos) return false;
            const iconSize = 20 / camera.scale;
            const radius = iconSize / 2;
            return Math.hypot(pos.x - iconPos.x, pos.y - iconPos.y) < radius * 1.5;
         }

         // Create a new linked shape (rect/circle) on a given side of the selected shape
         function createLinkedShapeOnSide(side) {
            if (!side) return false;
            if (selectedIndices.size !== 1) return false;

            const idx = selectedIndices.values().next().value;
            const shape = shapes[idx];
            if (
               !shape ||
               (shape.type !== "rect" &&
                  shape.type !== "circle" &&
                  shape.type !== "oval" &&
                  shape.type !== "rhombus" &&
                  shape.type !== "diamond")
            )
               return false;

            const offset = 60 / camera.scale; // Distance from original shape
            let newShapeX, newShapeY, newShapeW, newShapeH;
            let arrowStartX, arrowStartY, arrowEndX, arrowEndY;

            if (
               shape.type === "rect" ||
               shape.type === "rhombus" ||
               shape.type === "diamond" ||
               shape.type === "oval"
            ) {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);

               const newRectWidth = w;
               const newRectHeight = h;

               switch (side) {
                  case "top":
                     newShapeX = x + w / 2 - newRectWidth / 2;
                     newShapeY = y - offset - newRectHeight;
                     arrowStartX = x + w / 2;
                     arrowStartY = y;
                     arrowEndX = newShapeX + newRectWidth / 2;
                     arrowEndY = newShapeY + newRectHeight;
                     break;
                  case "right":
                     newShapeX = x + w + offset;
                     newShapeY = y + h / 2 - newRectHeight / 2;
                     arrowStartX = x + w;
                     arrowStartY = y + h / 2;
                     arrowEndX = newShapeX;
                     arrowEndY = newShapeY + newRectHeight / 2;
                     break;
                  case "bottom":
                     newShapeX = x + w / 2 - newRectWidth / 2;
                     newShapeY = y + h + offset;
                     arrowStartX = x + w / 2;
                     arrowStartY = y + h;
                     arrowEndX = newShapeX + newRectWidth / 2;
                     arrowEndY = newShapeY;
                     break;
                  case "left":
                     newShapeX = x - offset - newRectWidth;
                     newShapeY = y + h / 2 - newRectHeight / 2;
                     arrowStartX = x;
                     arrowStartY = y + h / 2;
                     arrowEndX = newShapeX + newRectWidth;
                     arrowEndY = newShapeY + newRectHeight / 2;
                     break;
                  default:
                     return false;
               }

               newShapeW = newRectWidth;
               newShapeH = newRectHeight;
            } else if (shape.type === "circle" || shape.type === "oval") {
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               const absW = Math.abs(shape.w);
               const absH = Math.abs(shape.h);
               const rx = absW / 2;
               const ry = absH / 2;

               let newCenterX = cx;
               let newCenterY = cy;

               switch (side) {
                  case "top":
                     newCenterX = cx;
                     newCenterY = cy - ry - offset - ry;
                     arrowStartX = cx;
                     arrowStartY = cy - ry;
                     arrowEndX = newCenterX;
                     arrowEndY = newCenterY + ry;
                     break;
                  case "right":
                     newCenterX = cx + rx + offset + rx;
                     newCenterY = cy;
                     arrowStartX = cx + rx;
                     arrowStartY = cy;
                     arrowEndX = newCenterX - rx;
                     arrowEndY = newCenterY;
                     break;
                  case "bottom":
                     newCenterX = cx;
                     newCenterY = cy + ry + offset + ry;
                     arrowStartX = cx;
                     arrowStartY = cy + ry;
                     arrowEndX = newCenterX;
                     arrowEndY = newCenterY - ry;
                     break;
                  case "left":
                     newCenterX = cx - rx - offset - rx;
                     newCenterY = cy;
                     arrowStartX = cx - rx;
                     arrowStartY = cy;
                     arrowEndX = newCenterX + rx;
                     arrowEndY = newCenterY;
                     break;
                  default:
                     return false;
               }

               newShapeX = newCenterX - rx;
               newShapeY = newCenterY - ry;
               // New circle should be identical size to original
               newShapeW = shape.w;
               newShapeH = shape.h;
            } else {
               return false;
            }

            // Apply rotation if source shape is rotated
            let newAngle = shape.angle || 0;
            if (newAngle) {
               const b = getBoundingBox(shape);
               const cx = b.x + b.w / 2;
               const cy = b.y + b.h / 2;
               const center = { x: cx, y: cy };

               const as = rotatePoint({ x: arrowStartX, y: arrowStartY }, center, newAngle);
               arrowStartX = as.x;
               arrowStartY = as.y;

               const ae = rotatePoint({ x: arrowEndX, y: arrowEndY }, center, newAngle);
               arrowEndX = ae.x;
               arrowEndY = ae.y;

               // For the new shape, we want to orbit its center around the source center
               // The unrotated center of the new shape:
               const ncx = newShapeX + newShapeW / 2;
               const ncy = newShapeY + newShapeH / 2;
               const newCenter = rotatePoint({ x: ncx, y: ncy }, center, newAngle);
               
               // Set new top-left based on rotated center
               newShapeX = newCenter.x - newShapeW / 2;
               newShapeY = newCenter.y - newShapeH / 2;
            }

            const newShapeId = generateId();
            const newShape = {
               id: newShapeId,
               type: shape.type,
               x: newShapeX,
               y: newShapeY,
               w: newShapeW,
               h: newShapeH,
               angle: newAngle, // Inherit angle
               color: shape.color || currentColor,
               fillColor: shape.fillColor || currentFillColor,
               width: shape.width || currentWidth,
               innerTextColor: shape.innerTextColor,
               innerTextSize: shape.innerTextSize,
               isBold: shape.isBold,
            };

            shapes.push(newShape);
            const newShapeIndex = shapes.length - 1;

            const arrowId = generateId();
            const arrowMidX = (arrowStartX + arrowEndX) / 2;
            const arrowMidY = (arrowStartY + arrowEndY) / 2;
            const arrow = {
               id: arrowId,
               type: "arrow",
               start: { x: arrowStartX, y: arrowStartY },
               end: { x: arrowEndX, y: arrowEndY },
               control: { x: arrowMidX, y: arrowMidY },
               color: shape.color || currentColor,
               fillColor: shape.fillColor || currentFillColor,
               width: shape.width || currentWidth,
               startConnected: attachToShape({ x: arrowStartX, y: arrowStartY }, shape, idx),
               endConnected: attachToShape({ x: arrowEndX, y: arrowEndY }, newShape, newShapeIndex),
            };

            shapes.push(arrow);
            updateConnections();

            clearSelection();
            addToSelection(newShapeIndex);

            hoveredSide = null;
            hoveredRectIndex = null;

            saveHistory();
            render();
            return true;
         }

         // --- Interaction Logic ---

         function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches
               ? e.touches[0]
                  ? e.touches[0].clientX
                  : e.changedTouches[0].clientX
               : e.clientX;
            const clientY = e.touches
               ? e.touches[0]
                  ? e.touches[0].clientY
                  : e.changedTouches[0].clientY
               : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
         }

         function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
         }

         let initialGroupBounds = null;

         function getSelectionBounds() {
            if (selectedIndices.size === 0) return null;
            let minX = Infinity,
               minY = Infinity,
               maxX = -Infinity,
               maxY = -Infinity;
            selectedIndices.forEach((idx) => {
               // Use Rotated Bounding Box for world-space selection bounds
               const b = getRotatedBoundingBox(shapes[idx]);
               minX = Math.min(minX, b.x);
               minY = Math.min(minY, b.y);
               maxX = Math.max(maxX, b.x + b.w);
               maxY = Math.max(maxY, b.y + b.h);
            });
            if (minX === Infinity) return null;
            return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
         }

         function updateFloatingToolbar() {
            // Check forced hidden state first
            if (isFloatingToolbarForceHidden) {
               floatingToolbar.classList.add("hidden");
               floatingToolbar.classList.remove("flex");
               return;
            }

            // Only show when selecting, not dragging/panning/box-selecting
            if (
               selectedIndices.size > 0 &&
               currentTool === "select" &&
               !isDragging &&
               !isBoxSelecting &&
               !isManipulatingHandle &&
               !camera.isPanning
            ) {
               // --- Floating Toolbar Logic for Contextual Items ---
               const ftArrowsRow = document.getElementById("ft-arrows-row");
               const ftConversionRow = document.getElementById("ft-conversion-row");
               const ftBtnDotted = document.getElementById("ft-btn-dotted");
               const ftBtnBold = document.getElementById("ft-btn-bold");
               const ftBoldSeparator = document.getElementById("ft-bold-separator");
               const ftStartArrowInd = document.getElementById("ft-start-arrow-indicator");
               const ftEndArrowInd = document.getElementById("ft-end-arrow-indicator");

               let hasLine = false;
               let hasConvertible = false;
               let hasNonText = false;
               let hasTextSupport = false;
               let isSelectionBold = false;
               let boldCheckDone = false;
               
               let showStartInd = false;
               let showEndInd = false;

               if (selectedIndices.size > 0) {
                  // Check first selected shape for arrow state priority
                  // (Logic: if any selected is a line, we show row. For indicator, we pick first found line)
                  let lineShapeFound = false;

                  for (let idx of selectedIndices) {
                     const s = shapes[idx];
                     if (s) {
                        if (['line', 'arrow', 'pencil', 'pencil-arrow'].includes(s.type)) {
                           hasLine = true;
                           if (!lineShapeFound) {
                               lineShapeFound = true;
                               // Check Start Arrow
                               if (s.hasStartArrow) showStartInd = true;
                               // Check End Arrow
                               const isArrowType = (s.type === 'arrow' || s.type === 'pencil-arrow');
                               // If hasEndArrow is explicitly defined, use it. Otherwise, fallback to type check.
                               if (s.hasEndArrow !== undefined) {
                                   if (s.hasEndArrow) showEndInd = true;
                               } else if (isArrowType) {
                                   showEndInd = true;
                               }
                           }
                        }
                        if (['rect', 'circle', 'triangle', 'oval', 'rhombus', 'diamond', 'pencil'].includes(s.type)) {
                           hasConvertible = true;
                        }
                        if (s.type !== 'text' && s.type !== 'image') {
                           hasNonText = true;
                        }
                        if (['rect', 'circle', 'triangle', 'oval', 'rhombus', 'diamond', 'line', 'arrow', 'text'].includes(s.type)) {
                           hasTextSupport = true;
                           if (!boldCheckDone) {
                               isSelectionBold = (s.isBold !== false);
                               boldCheckDone = true;
                           }
                        }
                     }
                  }
               }

               if (ftArrowsRow) {
                   if (hasLine) {
                       ftArrowsRow.style.display = 'flex';
                       ftArrowsRow.classList.remove('hidden');
                       
                       // Update Indicators
                       if (ftStartArrowInd) {
                           if (showStartInd) ftStartArrowInd.classList.remove('hidden');
                           else ftStartArrowInd.classList.add('hidden');
                       }
                       if (ftEndArrowInd) {
                           if (showEndInd) ftEndArrowInd.classList.remove('hidden');
                           else ftEndArrowInd.classList.add('hidden');
                       }

                   } else {
                       ftArrowsRow.style.display = 'none';
                       ftArrowsRow.classList.add('hidden');
                   }
               }
               if (ftConversionRow) {
                   if (hasConvertible) {
                       ftConversionRow.style.display = 'flex';
                       ftConversionRow.classList.remove('hidden');
                   } else {
                       ftConversionRow.style.display = 'none';
                       ftConversionRow.classList.add('hidden');
                   }
               }
               if (ftBtnDotted) {
                   // Toggle button visibility
                   if (hasNonText) {
                       ftBtnDotted.style.display = ''; // Reset inline display
                       ftBtnDotted.classList.remove('hidden');
                   } else {
                       ftBtnDotted.style.display = 'none';
                       ftBtnDotted.classList.add('hidden');
                   }
               }

               if (ftBtnBold) {
                   if (hasTextSupport) {
                       ftBtnBold.style.display = '';
                       ftBtnBold.classList.remove('hidden');
                       if (ftBoldSeparator) {
                           ftBoldSeparator.style.display = '';
                           ftBoldSeparator.classList.remove('hidden');
                       }
                       if (isSelectionBold) ftBtnBold.classList.add('active');
                       else ftBtnBold.classList.remove('active');
                       isBold = isSelectionBold;
                   } else {
                       ftBtnBold.style.display = 'none';
                       ftBtnBold.classList.add('hidden');
                       if (ftBoldSeparator) {
                           ftBoldSeparator.style.display = 'none';
                           ftBoldSeparator.classList.add('hidden');
                       }
                   }
               }
               // ---------------------------------------------------

               const bounds = getSelectionBounds();
               if (bounds) {
                  const screenPos = toScreen(bounds.x, bounds.y);
                  const screenWidth = bounds.w * camera.scale;
                  const screenHeight = bounds.h * camera.scale;

                  // Measure toolbar dimensions
                  // We must make it visible briefly to measure (using visibility:hidden to avoid flicker)
                  floatingToolbar.style.visibility = "hidden";
                  floatingToolbar.classList.remove("hidden");
                  floatingToolbar.classList.add("flex");

                  const tbWidth = floatingToolbar.offsetWidth;
                  const tbHeight = floatingToolbar.offsetHeight;

                  // Increased gap to 60px to avoid overlap with rotation handles and connection points
                  const gap = 60;
                  
                  // Reset margin-top to avoid confusion (we handle spacing manually)
                  floatingToolbar.style.marginTop = "0px";

                  // Target: Top Center
                  // Top means: bounds.y - tbHeight - gap
                  // Center means: (bounds.x + width/2) - (tbWidth/2)
                  
                  let top = screenPos.y - tbHeight - gap;
                  let left = screenPos.x + (screenWidth / 2) - (tbWidth / 2);

                  let placement = 'top';

                  // 1. Check Top collision
                  if (top < 0) {
                     // Try Bottom Center
                     top = screenPos.y + screenHeight + gap;
                     placement = 'bottom';
                     
                     // 2. Check Bottom collision
                     if (top + tbHeight > window.innerHeight) {
                        // Try Right
                        left = screenPos.x + screenWidth + gap;
                        top = screenPos.y + (screenHeight / 2) - (tbHeight / 2);
                        placement = 'right';

                        // 3. Check Right collision
                        if (left + tbWidth > window.innerWidth) {
                           // Try Left
                           left = screenPos.x - tbWidth - gap;
                           top = screenPos.y + (screenHeight / 2) - (tbHeight / 2);
                           placement = 'left';

                            // 4. Check Left collision
                            if (left < 0) {
                               // Fallback: Clamp to screen logic if shape is essentially filling screen
                               // Force Top Left inside screen
                               left = Math.max(10, Math.min(window.innerWidth - tbWidth - 10, left));
                               top = Math.max(10, Math.min(window.innerHeight - tbHeight - 10, top));
                            }
                        }
                     }
                  }

                  // Constraint horizontal for Top/Bottom placement to keep within screen
                  if (placement === 'top' || placement === 'bottom') {
                      left = Math.max(10, Math.min(window.innerWidth - tbWidth - 10, left));
                  }
                  // Constraint vertical for Left/Right placement
                  if (placement === 'left' || placement === 'right') {
                      top = Math.max(10, Math.min(window.innerHeight - tbHeight - 10, top));
                  }

                  floatingToolbar.style.transform = `none`; // Reset any transforms
                  floatingToolbar.style.left = left + "px";
                  floatingToolbar.style.top = top + "px";

                  floatingToolbar.style.visibility = "visible";
                  return;
               }
            }
            floatingToolbar.classList.add("hidden");
            floatingToolbar.classList.remove("flex");
         }

         function resizeGroup(handle, initBounds, initShapesMap, pos) {
            const dx = pos.x - startPos.x;
            const dy = pos.y - startPos.y;

            let newX = initBounds.x;
            let newY = initBounds.y;
            let newW = initBounds.w;
            let newH = initBounds.h;

            if (handle === "br") {
               newW = initBounds.w + dx;
               newH = initBounds.h + dy;
            } else if (handle === "bl") {
               newX = initBounds.x + dx;
               newW = initBounds.w - dx;
               newH = initBounds.h + dy;
            } else if (handle === "tr") {
               newY = initBounds.y + dy;
               newW = initBounds.w + dx;
               newH = initBounds.h - dy;
            } else if (handle === "tl") {
               newX = initBounds.x + dx;
               newY = initBounds.y + dy;
               newW = initBounds.w - dx;
               newH = initBounds.h - dy;
            } else if (handle === "top") {
               newY = initBounds.y + dy;
               newH = initBounds.h - dy;
            } else if (handle === "bottom") {
               newH = initBounds.h + dy;
            } else if (handle === "left") {
               newX = initBounds.x + dx;
               newW = initBounds.w - dx;
            } else if (handle === "right") {
               newW = initBounds.w + dx;
            }

            const scaleX = initBounds.w === 0 ? 1 : newW / initBounds.w;
            const scaleY = initBounds.h === 0 ? 1 : newH / initBounds.h;

            selectedIndices.forEach((idx) => {
               const shape = shapes[idx];
               const initShape = initShapesMap.get(idx);
               if (!initShape) return;

               if (
                  shape.type === "pencil" ||
                  shape.type === "pencil-arrow" ||
                  shape.type === "laser"
               ) {
                  shape.points = initShape.points.map((p) => ({
                     x: newX + (p.x - initBounds.x) * scaleX,
                     y: newY + (p.y - initBounds.y) * scaleY,
                  }));
               } else if (shape.type === "line" || shape.type === "arrow") {
                  shape.start.x = newX + (initShape.start.x - initBounds.x) * scaleX;
                  shape.start.y = newY + (initShape.start.y - initBounds.y) * scaleY;
                  shape.end.x = newX + (initShape.end.x - initBounds.x) * scaleX;
                  shape.end.y = newY + (initShape.end.y - initBounds.y) * scaleY;
                  if (shape.control && initShape.control) {
                     shape.control.x = newX + (initShape.control.x - initBounds.x) * scaleX;
                     shape.control.y = newY + (initShape.control.y - initBounds.y) * scaleY;
                  }
               } else if (shape.type === "text") {
                  shape.x = newX + (initShape.x - initBounds.x) * scaleX;
                  shape.y = newY + (initShape.y - initBounds.y) * scaleY;
                  shape.size = Math.max(5, Math.abs(initShape.size * scaleY));
               } else {
                  shape.x = newX + (initShape.x - initBounds.x) * scaleX;
                  shape.y = newY + (initShape.y - initBounds.y) * scaleY;
                  shape.w = initShape.w * scaleX;
                  shape.h = initShape.h * scaleY;
               }
            });
         }

         function onMouseDown(e) {
            if (isTyping || isFinishingText) return;

            // Check if this is a touch event (no button property) vs mouse event
            const isTouchEvent = e.touches !== undefined || e.changedTouches !== undefined;

            // --- Handle 2-finger touch for pinch-to-zoom ---
            if (isTouchEvent && e.touches && e.touches.length === 2) {
               e.preventDefault();
               isPinching = true;
               isDragging = false;

               const rect = canvas.getBoundingClientRect();
               const touch1 = e.touches[0];
               const touch2 = e.touches[1];

               // Calculate initial distance between fingers
               const dx = touch2.clientX - touch1.clientX;
               const dy = touch2.clientY - touch1.clientY;
               pinchStartDistance = Math.hypot(dx, dy);

               // Store initial scale
               pinchStartScale = camera.scale;

               // Calculate center point of the two touches (in screen coordinates)
               pinchStartCenter = {
                  x: (touch1.clientX + touch2.clientX) / 2 - rect.left,
                  y: (touch1.clientY + touch2.clientY) / 2 - rect.top,
               };

               // Store starting camera position
               pinchStartCameraX = camera.x;
               pinchStartCameraY = camera.y;

               return;
            }

            const screenPos = getPointerPos(e);
            const pos = toWorld(screenPos.x, screenPos.y);

            // Middle button or Ctrl+Left click for Panning (mouse only)
            if (!isTouchEvent && (e.button === 1 || (e.ctrlKey && e.button === 0))) {
               camera.isPanning = true;
               startPos = screenPos; // Store screen pos for panning delta
               canvas.style.cursor = "grabbing";
               return;
            }

            // Block right-click (button 2) and middle-click (button 1) for drawing
            // Only allow left-click (button 0) for mouse events, allow all touch events
            if (!isTouchEvent && e.button !== 0) {
               return;
            }

            // (Previous "bending" phase code removed as it is no longer used)

            startPos = pos; // World start pos
            isDragging = true;

            // --- SELECT TOOL LOGIC ---
            if (currentTool === "select") {
               // 0. Check for plus icon click (create new rectangle/circle with arrow)
               if (selectedIndices.size === 1) {
                  const idx = selectedIndices.values().next().value; // Use safe getter or iterate
                  const shape = shapes[idx] || shapes[Array.from(selectedIndices)[0]]; // Fallback

                  // Case A: Hovered side logic (Desktop/Mouse)
                  if (hoveredSide && hoveredRectIndex !== null && hoveredRectIndex === idx) {
                     const iconPos = getPlusIconPosition(shape, hoveredSide);
                     if (iconPos && isPointOnPlusIcon(pos, iconPos)) {
                        // Debounce check
                        if (Date.now() - lastConnectorClickTime < 500) return;

                        if (createLinkedShapeOnSide(hoveredSide)) {
                           lastConnectorClickTime = Date.now();
                           isDragging = false;
                           return;
                        }
                     }
                  }
                  // Case B: Touch device logic (Check all 4 sides if no specific hover)
                  else {
                     const sides = ["top", "bottom", "left", "right"];
                     for (const side of sides) {
                        const iconPos = getPlusIconPosition(shape, side);
                        if (iconPos && isPointOnPlusIcon(pos, iconPos)) {
                           // Debounce: Prevent ghost clicks
                           if (Date.now() - lastConnectorClickTime < 500) return;

                           if (createLinkedShapeOnSide(side)) {
                              lastConnectorClickTime = Date.now();
                              isDragging = false;
                              return;
                           }
                        }
                     }
                  }
               }

               // 1. Check Resizing Handles
               if (selectedIndices.size === 1) {
                  const idx = selectedIndices.values().next().value;
                  const handle = getHitHandle(pos, shapes[idx]);
                  if (handle) {
                     if (handle.startsWith("rot-")) {
                        isRotating = true;
                        activeHandle = handle;
                        const shape = shapes[idx];
                        const b = getBoundingBox(shape);
                        rotationCenter = { x: b.x + b.w / 2, y: b.y + b.h / 2 };
                        rotationStartAngle = Math.atan2(pos.y - rotationCenter.y, pos.x - rotationCenter.x);
                        initialShapeAngle = shape.angle || 0;
                        return;
                     }

                     isManipulatingHandle = true;
                     activeHandle = handle;
                     initialShapeState = JSON.parse(JSON.stringify(shapes[idx]));

                     // Disconnect arrow endpoints when dragging them so they can be moved freely
                     // (otherwise updateConnections will immediately snap them back)
                     if (shapes[idx].type === "arrow" || shapes[idx].type === "line") {
                        if (handle === "start") shapes[idx].startConnected = null;
                        if (handle === "end") shapes[idx].endConnected = null;
                     }

                     // Store world start pos for delta calculations during resize
                     startPos = pos;
                     return;
                  }
               } else if (selectedIndices.size > 1) {
                  const groupBounds = getSelectionBounds();
                  if (groupBounds) {
                     const dummyShape = {
                        x: groupBounds.x,
                        y: groupBounds.y,
                        w: groupBounds.w,
                        h: groupBounds.h,
                        type: "group_selection",
                     };
                     const handle = getHitHandle(pos, dummyShape);
                     if (handle) {
                        if (handle.startsWith("rot-")) {
                           isRotating = true;
                           activeHandle = handle;
                           initialGroupBounds = groupBounds;
                           groupRotationAngle = 0;
                           rotationCenter = { x: groupBounds.x + groupBounds.w / 2, y: groupBounds.y + groupBounds.h / 2 };
                           rotationStartAngle = Math.atan2(pos.y - rotationCenter.y, pos.x - rotationCenter.x);
                           
                           initialAngles.clear();
                           selectedIndices.forEach((idx) => {
                              const s = shapes[idx];
                              const sb = getBoundingBox(s);
                              initialAngles.set(idx, {
                                 angle: s.angle || 0,
                                 center: { x: sb.x + sb.w / 2, y: sb.y + sb.h / 2 },
                                 origX: s.x,
                                 origY: s.y,
                                 origStart: s.start ? { ...s.start } : null, // For lines/arrows
                                 origEnd: s.end ? { ...s.end } : null,
                                 origControl: s.control ? { ...s.control } : null,
                                 origPoints: s.points ? s.points.map(p => ({...p})) : null // For pencil
                              });
                           });
                           return;
                        }

                        isManipulatingHandle = true;
                        activeHandle = handle;
                        initialGroupBounds = groupBounds;
                        initialShapeState = new Map();
                        selectedIndices.forEach((idx) => {
                           initialShapeState.set(idx, JSON.parse(JSON.stringify(shapes[idx])));
                        });
                        startPos = pos;
                        return;
                     }
                  }
               }

               // 2. Check Hit on Shapes
               let hitIndex = -1;
               for (let i = shapes.length - 1; i >= 0; i--) {
                  let isHit = isPointInShape(pos, shapes[i]);

                  // Priority check: If the shape is currently selected, use its full bounding box
                  // This ensures that clicking inside a selected empty frame drags the frame
                  // instead of selecting the object behind it.
                  if (!isHit && selectedIndices.has(i)) {
                     const b = getBoundingBox(shapes[i]);
                     // Using a slightly more generous hit area for selected objects to allow easy grabbing
                     if (pos.x >= b.x && pos.x <= b.x + b.w && pos.y >= b.y && pos.y <= b.y + b.h) {
                        isHit = true;
                     }
                  }

                  if (isHit) {
                     hitIndex = i;
                     break;
                  }
               }

               // Fix: Allow dragging selected objects by clicking anywhere inside their bounds
               // even if the shape is unfilled (which normally only catches clicks on the border)
               if (hitIndex === -1 && selectedIndices.size > 0) {
                  if (selectedIndices.size === 1) {
                     const idx = selectedIndices.values().next().value;
                     const shape = shapes[idx];

                     const b = getBoundingBox(shape);
                     // Simple bounding box check
                     if (pos.x >= b.x && pos.x <= b.x + b.w && pos.y >= b.y && pos.y <= b.y + b.h) {
                        hitIndex = idx;
                     }
                  } else {
                     // For groups, if clicking inside the group bounds
                     const b = getSelectionBounds();
                     if (
                        b &&
                        pos.x >= b.x &&
                        pos.x <= b.x + b.w &&
                        pos.y >= b.y &&
                        pos.y <= b.y + b.h
                     ) {
                        // Use the first selected index to trigger the move logic
                        hitIndex = selectedIndices.values().next().value;
                     }
                  }
               }

               // New Fix: Allow clicking and dragging UNSELECTED objects too
               // If we still haven't found a hit, check all shapes for bounding box hits
               // prioritizing top-most shapes (reverse order)
               if (hitIndex === -1) {
                  for (let i = shapes.length - 1; i >= 0; i--) {
                     const shape = shapes[i];

                     // Skip loose bounding box check for pencil/line drawings to avoid selecting empty space
                     // This prevents selecting a U-shape when clicking inside the empty U area
                     if (
                        shape.type === "pencil" ||
                        shape.type === "line" ||
                        shape.type === "arrow" ||
                        shape.type === "pencil-arrow"
                     ) {
                        continue;
                     }

                     const b = getBoundingBox(shape);
                     // Relaxed check: is point inside the bounding box + padding?
                     const padding = 5 / camera.scale;
                     if (
                        pos.x >= b.x - padding &&
                        pos.x <= b.x + b.w + padding &&
                        pos.y >= b.y - padding &&
                        pos.y <= b.y + b.h + padding
                     ) {
                        hitIndex = i;
                        break;
                     }
                  }
               }

               if (hitIndex !== -1) {
                  // ALT KEY LOGIC - Duplicate objects
                  if (e.altKey) {
                     // Ensure the clicked shape is selected
                     if (!selectedIndices.has(hitIndex)) {
                        selectedIndices.forEach((idx) => restoreConnectionsForShape(shapes[idx]));
                        clearSelection();
                        addToSelection(hitIndex);
                     }

                     // Duplicate all selected shapes
                     const duplicatedShapes = [];
                     const oldToNewIndexMap = new Map();

                     selectedIndices.forEach((idx) => {
                        const original = shapes[idx];
                        const duplicate = JSON.parse(
                           JSON.stringify(original, (key, value) => {
                              if (key === "image") return undefined; // Don't stringify Image objects
                              return value;
                           }),
                        );

                        // Generate new ID for duplicate
                        duplicate.id = generateId();

                        // Re-hydrate image if needed
                        if (original.type === "image" && original.src) {
                           const img = new Image();
                           img.src = original.src;
                           duplicate.image = img;
                        }

                        duplicatedShapes.push(duplicate);
                        oldToNewIndexMap.set(idx, shapes.length + duplicatedShapes.length - 1);
                     });

                     // Add duplicates to shapes array
                     shapes.push(...duplicatedShapes);

                     // Update selection to the new duplicates
                     clearSelection();
                     for (let i = shapes.length - duplicatedShapes.length; i < shapes.length; i++) {
                        addToSelection(i);
                     }

                     // Start moving the duplicates
                     isDuplicating = true;
                     isMovingSelection = true;
                     moveOffset = pos;

                     // Temporarily break connections for duplicated shapes
                     // selectedIndices.forEach((idx) => temporarilyBreakConnections(shapes[idx]));
                  }
                  // SHIFT KEY LOGIC
                  else if (e.shiftKey) {
                     if (selectedIndices.has(hitIndex)) {
                        removeFromSelection(hitIndex);
                        isMovingSelection = false;
                        // Restore connections if this shape was temporarily disconnected
                        restoreConnectionsForShape(shapes[hitIndex]);
                     } else {
                        addToSelection(hitIndex);
                        isMovingSelection = true;
                        moveOffset = pos;
                        // Temporarily break connections for shapes being moved
                        // temporarilyBreakConnections(shapes[hitIndex]);
                     }
                  } else {
                     // Check if the hit shape is already in selection
                     const wasAlreadySelected = selectedIndices.has(hitIndex);

                     if (!wasAlreadySelected) {
                        // Restore connections for previously selected shapes
                        selectedIndices.forEach((idx) => restoreConnectionsForShape(shapes[idx]));
                        clearSelection();
                        addToSelection(hitIndex);
                     }

                     // Always allow moving when clicking on any shape (filled or not)
                     isMovingSelection = true;
                     moveOffset = pos;

                     // Temporarily break connections for all selected shapes
                     // selectedIndices.forEach((idx) => temporarilyBreakConnections(shapes[idx]));
                  }
               } else {
                  let handled = false;
                  // Group bounds selection logic removed to prevent "rectangular area" selection issue.
                  // Users must click on an actual shape to drag the group.

                  // Dragging group by clicking bounds is no longer supported to prevent "rectangular area" selection issue.

                  if (!handled) {
                     if (!e.shiftKey) {
                        // Restore connections for previously selected shapes
                        selectedIndices.forEach((idx) => restoreConnectionsForShape(shapes[idx]));
                        clearSelection();
                     }
                     isBoxSelecting = true;
                     selectionBox = { start: pos, end: pos };
                  }
               }
               render();
            }
            // --- OTHER TOOLS ---
            else if (currentTool === "eraser") {
               handleEraser(pos);
            } else if (currentTool === "text") {
               createTextInput(pos.x, pos.y);
               isDragging = false;
            } else {
               clearSelection();
               const newId = generateId();
               let startConn = null;

               if (
                  currentTool === "line" ||
                  currentTool === "arrow" ||
                  currentTool === "pencil" ||
                  currentTool === "pencil-arrow"
               ) {
                  for (let i = shapes.length - 1; i >= 0; i--) {
                     if (isPointInShape(pos, shapes[i])) {
                        startConn = attachToShape(pos, shapes[i], i);
                        connectionHoverShape = shapes[i];
                        break;
                     }
                  }
                  render(); // Render to show highlight immediately
               }

               // Hide shape recognition panel when starting a new drawing
               hideShapeRecognitionPanel();

               if (currentTool === "pencil") {
                  currentShape = {
                     id: newId,
                     type: "pencil",
                     points: [pos],
                     color: currentColor,
                     fillColor: currentFillColor,
                     width: currentWidth,
                     startConnected: startConn,
                  };
               } else if (currentTool === "pencil-arrow") {
                  currentShape = {
                     id: newId,
                     type: "pencil-arrow",
                     points: [pos],
                     color: currentColor,
                     fillColor: currentFillColor,
                     width: currentWidth,
                     startConnected: startConn,
                     hasEndArrow: true,
                  };
               } else if (currentTool === "laser") {
                  currentShape = {
                     id: newId,
                     type: "laser",
                     points: [pos],
                     color: "#ff0000", // Pure red for laser
                     width: currentWidth,
                     createdAt: Date.now(),
                  };
               } else if (currentTool === "line") {
                  currentShape = {
                     id: newId,
                     type: "line",
                     start: pos,
                     end: pos,
                     color: currentColor,
                     fillColor: currentFillColor,
                     width: currentWidth,
                     startConnected: startConn,
                     isBold: isBold,
                  };
               } else if (currentTool === "arrow") {
                  arrowCreationPhase = "drawing_line";
                  currentShape = {
                     id: newId,
                     type: "arrow",
                     start: pos,
                     end: pos,
                     control: pos,
                     color: currentColor,
                     fillColor: currentFillColor,
                     width: currentWidth,
                     startConnected: startConn,
                     hasEndArrow: true,
                     isBold: isBold,
                  };
               } else {
                  currentShape = {
                     id: newId,
                     type: currentTool,
                     x: pos.x,
                     y: pos.y,
                     w: 0,
                     h: 0,
                     color: currentColor,
                     fillColor: currentFillColor,
                     width: currentWidth,
                     isBold: isBold,
                  };
               }
            }
         }

         function getHoverCursor(pos) {
            for (let i = shapes.length - 1; i >= 0; i--) {
               const shape = shapes[i];
               if (isPointInShape(pos, shape)) return "move";

               // Skip loose bounding box check for pencil/line drawings UNLESS selected
               // This prevents showing "move" cursor when hovering empty space of unselected U-shape
               const isSelected = selectedIndices.has(i);
               if (
                  !isSelected &&
                  (shape.type === "pencil" ||
                     shape.type === "line" ||
                     shape.type === "arrow" ||
                     shape.type === "pencil-arrow")
               ) {
                  continue;
               }

               // Relaxed check for unfilled shapes
               const b = getBoundingBox(shape);
               const padding = 5 / (camera.scale || 1);
               if (
                  pos.x >= b.x - padding &&
                  pos.x <= b.x + b.w + padding &&
                  pos.y >= b.y - padding &&
                  pos.y <= b.y + b.h + padding
               ) {
                  return "move";
               }
            }
            return "default";
         }

         function onMouseMove(e) {
            // Check if this is a touch event
            const isTouchEvent = e.touches !== undefined || e.changedTouches !== undefined;

            // --- Handle pinch-to-zoom gesture ---
            if (isPinching && isTouchEvent && e.touches && e.touches.length === 2) {
               e.preventDefault();

               const rect = canvas.getBoundingClientRect();
               const touch1 = e.touches[0];
               const touch2 = e.touches[1];

               // Calculate current distance between fingers
               const dx = touch2.clientX - touch1.clientX;
               const dy = touch2.clientY - touch1.clientY;
               const currentDistance = Math.hypot(dx, dy);

               // Calculate scale factor
               const scaleFactor = currentDistance / pinchStartDistance;
               let newScale = pinchStartScale * scaleFactor;

               // Limit scale
               newScale = Math.min(Math.max(0.1, newScale), 20);

               // Calculate current center point of the two touches
               const currentCenter = {
                  x: (touch1.clientX + touch2.clientX) / 2 - rect.left,
                  y: (touch1.clientY + touch2.clientY) / 2 - rect.top,
               };

               // Calculate how much the center has moved (for panning while zooming)
               const centerDx = currentCenter.x - pinchStartCenter.x;
               const centerDy = currentCenter.y - pinchStartCenter.y;

               // Get world position at the pinch center before zoom
               const worldPinchCenter = {
                  x: (pinchStartCenter.x - pinchStartCameraX) / pinchStartScale,
                  y: (pinchStartCenter.y - pinchStartCameraY) / pinchStartScale,
               };

               // Apply the new scale
               camera.scale = newScale;

               // Calculate new camera position to keep the pinch center stable
               camera.x = currentCenter.x - worldPinchCenter.x * camera.scale;
               camera.y = currentCenter.y - worldPinchCenter.y * camera.scale;

               render();
               return;
            }

            const screenPos = getPointerPos(e);
            const pos = toWorld(screenPos.x, screenPos.y);

            // --- Auto-Hide Floating Toolbar Logic ---
            if (!floatingToolbar.classList.contains("hidden")) {
               // Don't hide if hovering over the toolbar itself
               if (floatingToolbar.contains(e.target)) {
                  if (floatingToolbarIdleTimer) clearTimeout(floatingToolbarIdleTimer);
                  if (floatingToolbarMoveAwayTimer) clearTimeout(floatingToolbarMoveAwayTimer);
               } else {
                  // Reset 3s idle timer ONLY if moving TOWARDS the toolbar
                  // or if we just showed it (handled in addToSelection)

                  // "Moving towards" detector
                  const tbRect = floatingToolbar.getBoundingClientRect();
                  const tbCx = tbRect.left + tbRect.width / 2;
                  const tbCy = tbRect.top + tbRect.height / 2;

                  const dist = Math.hypot(e.clientX - tbCx, e.clientY - tbCy);

                  if (dist < prevFloatingToolbarDist - 2) {
                     // Moving towards - Reset timer to keep it alive
                     if (floatingToolbarIdleTimer) clearTimeout(floatingToolbarIdleTimer);
                     floatingToolbarIdleTimer = setTimeout(() => {
                        isFloatingToolbarForceHidden = true;
                        render();
                     }, 3000);

                     if (floatingToolbarMoveAwayTimer) {
                        clearTimeout(floatingToolbarMoveAwayTimer);
                        floatingToolbarMoveAwayTimer = null;
                     }
                  } else if (dist > prevFloatingToolbarDist + 2) {
                     // Moving away - Don't reset main timer (let 3s countdown continues)
                     // Optional: Accelerate hiding if moving away fast?
                     if (!floatingToolbarMoveAwayTimer) {
                        floatingToolbarMoveAwayTimer = setTimeout(() => {
                           isFloatingToolbarForceHidden = true;
                           render();
                        }, 1000);
                     }
                  }

                  prevFloatingToolbarDist = dist;
               }
            }

            if (camera.isPanning) {
               const dx = screenPos.x - startPos.x;
               const dy = screenPos.y - startPos.y;
               camera.x += dx;
               camera.y += dy;
               startPos = screenPos;
               render();
               return;
            }

            // Update cursor for resize handles when in select tool
            if (currentTool === "select" && !isDragging && selectedIndices.size > 0) {
               let handle = null;
               let activeShape = null;
               let idx = null;

               if (selectedIndices.size === 1) {
                  idx = selectedIndices.values().next().value;
                  activeShape = shapes[idx];
                  handle = getHitHandle(pos, activeShape);
               } else {
                  const groupBounds = getSelectionBounds();
                  if (groupBounds) {
                     handle = getHitHandle(pos, {
                        x: groupBounds.x,
                        y: groupBounds.y,
                        w: groupBounds.w,
                        h: groupBounds.h,
                        type: "group_selection",
                     });
                  }
               }

               if (handle) {
                  // Set appropriate cursor based on handle position
                  if (handle.startsWith("rot-")) {
                     // Determine rotation angle based on handle position
                     // Logic: "Cup" faces away from shape center (consistent with user preference for TL)
                     let angle = 0;
                     if (handle === "rot-tr") angle = 90;
                     else if (handle === "rot-br") angle = 180;
                     else if (handle === "rot-bl") angle = 270;

                     // Add shape rotation
                     if (activeShape && activeShape.angle) {
                        angle += (activeShape.angle * 180) / Math.PI;
                     }

                     // Use a custom SVG cursor for rotation (Curved Double Arrow style) - Ultra Small (16x16)
                     const rotateCursor = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                           <g transform="rotate(${angle}, 12, 12)">
                              <!-- White halo -->
                              <g stroke="white" stroke-width="5" opacity="0.9">
                                 <path d="M 4 20 A 12 12 0 0 1 20 4" />
                                 <path d="M 1 16 L 4 20 L 7 16" />
                                 <path d="M 16 1 L 20 4 L 16 7" />
                              </g>
                              <!-- Black stroke -->
                              <g stroke="black" stroke-width="2">
                                 <path d="M 4 20 A 12 12 0 0 1 20 4" />
                                 <path d="M 1 16 L 4 20 L 7 16" />
                                 <path d="M 16 1 L 20 4 L 16 7" />
                              </g>
                           </g>
                        </svg>
                     `;
                     // Encode as data URI
                     const cursorUrl = "data:image/svg+xml;base64," + btoa(rotateCursor);
                     // Set cursor with hotspot at center (8,8 for 16px size)
                     canvas.style.cursor = `url('${cursorUrl}') 8 8, alias`;
                  } else if (handle === "tl" || handle === "br") {
                     // Check orientation for shapes with negative width/height
                     let isStandard = true;
                     if (activeShape && activeShape.type !== "group_selection") {
                        // XOR logic: reversed if exactly one dimension is negative
                        if (
                           (activeShape.w < 0 && activeShape.h >= 0) ||
                           (activeShape.w >= 0 && activeShape.h < 0)
                        ) {
                           isStandard = false;
                        }
                     }
                     canvas.style.cursor = isStandard ? "nwse-resize" : "nesw-resize";
                  } else if (handle === "tr" || handle === "bl") {
                     // Check orientation
                     let isStandard = true;
                     if (activeShape && activeShape.type !== "group_selection") {
                        if (
                           (activeShape.w < 0 && activeShape.h >= 0) ||
                           (activeShape.w >= 0 && activeShape.h < 0)
                        ) {
                           isStandard = false;
                        }
                     }
                     canvas.style.cursor = isStandard ? "nesw-resize" : "nwse-resize";
                  } else if (handle === "top" || handle === "bottom") {
                     canvas.style.cursor = "ns-resize";
                  } else if (handle === "left" || handle === "right") {
                     canvas.style.cursor = "ew-resize";
                  } else if (handle === "start" || handle === "end" || handle === "control") {
                     canvas.style.cursor = "move";
                  }
                  // Reset hover state when over handle
                  hoveredSide = null;
                  hoveredRectIndex = null;
               } else if (activeShape) {
                  // Check for hover over rectangle/circle sides (only for single selection)
                  if (
                     activeShape &&
                     (activeShape.type === "rect" ||
                        activeShape.type === "circle" ||
                        activeShape.type === "oval" ||
                        activeShape.type === "rhombus" ||
                        activeShape.type === "diamond")
                  ) {
                     let side = detectHoveredSide(pos, activeShape);
                     
                     // Fallback: If not detecting side via border proximity, check if we are directly on the plus icon/dot
                     if (!side) {
                        const sides = ["top", "right", "bottom", "left"];
                        for (const s of sides) {
                           const iconPos = getPlusIconPosition(activeShape, s);
                           if (iconPos && isPointOnPlusIcon(pos, iconPos)) {
                              side = s;
                              break;
                           }
                        }
                     }

                     if (side) {
                        // Update state if changed
                        if (hoveredSide !== side || hoveredRectIndex !== idx) {
                           hoveredSide = side;
                           hoveredRectIndex = idx;
                           render(); // Re-render to show plus icon
                        }
                        canvas.style.cursor = "pointer";
                     } else {
                        // Clear state if neither on border nor on icon
                        if (hoveredSide !== null || hoveredRectIndex !== null) {
                           hoveredSide = null;
                           hoveredRectIndex = null;
                           render(); // Re-render to hide plus icon
                        }
                        canvas.style.cursor = getHoverCursor(pos);
                     }
                  } else {
                     if (hoveredSide !== null || hoveredRectIndex !== null) {
                        hoveredSide = null;
                        hoveredRectIndex = null;
                        render(); // Re-render to hide plus icon
                     }
                     canvas.style.cursor = getHoverCursor(pos);
                  }
               } else {
                  // Only for group selection: check if hovering inside the group bounds
                  // (Single selection drag is handled by default hover logic because activeShape is set and shape hit test passes later?
                  // No, shape hit test for cursor is separate. But single shape drag works because cursor is default and click hits shape.)
                  // But for group selection empty space, we want to indicate it's draggable.
                  if (selectedIndices.size > 1) {
                     const groupBounds = getSelectionBounds();
                     if (
                        groupBounds &&
                        pos.x >= groupBounds.x &&
                        pos.x <= groupBounds.x + groupBounds.w &&
                        pos.y >= groupBounds.y &&
                        pos.y <= groupBounds.y + groupBounds.h
                     ) {
                        canvas.style.cursor = "move";
                     } else {
                        canvas.style.cursor = getHoverCursor(pos);
                     }
                  } else {
                     canvas.style.cursor = getHoverCursor(pos);
                  }
               }
            } else if (currentTool !== "select" || isDragging) {
               // Reset to default cursor for non-select tool or when dragging
               if (!isDragging && currentTool !== "select") {
                  updateCursor();
               }
               // Reset hover state when not in select tool or when dragging
               if (hoveredSide !== null || hoveredRectIndex !== null) {
                  hoveredSide = null;
                  hoveredRectIndex = null;
                  render();
               }
            } else {
               // Reset hover state when no selection
               if (hoveredSide !== null || hoveredRectIndex !== null) {
                  hoveredSide = null;
                  hoveredRectIndex = null;
                  render();
               }
               canvas.style.cursor = getHoverCursor(pos);
            }

            // Check for connection hover even when not dragging yet (for visual feedback)
            // Also check when manipulating handles of lines/arrows in select mode
            let isConnectorHandle = false;
            let selectedShapeId = null;
            if (currentTool === "select" && isManipulatingHandle && selectedIndices.size === 1) {
               const idx = selectedIndices.values().next().value;
               const shape = shapes[idx];
               if (
                  shape &&
                  (shape.type === "line" ||
                     shape.type === "arrow" ||
                     shape.type === "pencil" ||
                     shape.type === "pencil-arrow")
               ) {
                  // Only if manipulating start/end handles (not control)
                  if (activeHandle === "start" || activeHandle === "end") {
                     isConnectorHandle = true;
                     selectedShapeId = shape.id;
                  }
               }
            }

            if (
               currentTool === "line" ||
               currentTool === "arrow" ||
               currentTool === "pencil" ||
               currentTool === "pencil-arrow" ||
               isConnectorHandle
            ) {
               let foundHover = false;
               for (let i = shapes.length - 1; i >= 0; i--) {
                  if (selectedShapeId && shapes[i].id === selectedShapeId) continue;

                  if (
                     shapes[i].type === "line" ||
                     shapes[i].type === "arrow" ||
                     shapes[i].type === "pencil" ||
                     shapes[i].type === "pencil-arrow"
                  ) {
                     continue;
                  }

                  if (isPointInShape(pos, shapes[i], 20)) {
                     if (connectionHoverShape !== shapes[i]) {
                        connectionHoverShape = shapes[i];
                        render();
                     }
                     foundHover = true;
                     break;
                  }
               }
               if (!foundHover && connectionHoverShape !== null) {
                  connectionHoverShape = null;
                  render();
               }
            }

            if (!isDragging) return;
            e.preventDefault();

            if (currentTool === "select") {
               if (isRotating) {
                  const currentAngle = Math.atan2(pos.y - rotationCenter.y, pos.x - rotationCenter.x);
                  const deltaAngle = currentAngle - rotationStartAngle;
                  groupRotationAngle = deltaAngle;

                  if (selectedIndices.size === 1) {
                     const idx = selectedIndices.values().next().value;
                     const shape = shapes[idx];
                     shape.angle = initialShapeAngle + deltaAngle;
                  } else {
                     selectedIndices.forEach((idx) => {
                        const s = shapes[idx];
                        const init = initialAngles.get(idx);
                        if (!init) return;

                        s.angle = (init.angle || 0) + deltaAngle;

                        const newCenter = rotatePoint(init.center, rotationCenter, deltaAngle);
                        
                        // For ALL shapes, we simply Translate their position.
                        // The Rotation is handled by adding deltaAngle to s.angle.
                        // This prevents internal geometry deformation for point-based shapes
                        // and correctly handles the orbit-plus-spin behavior for all shapes.
                        
                        // Calculate how much the center moved due to orbit
                        const dx = newCenter.x - init.center.x;
                        const dy = newCenter.y - init.center.y;

                        if (s.type === "line" || s.type === "arrow") {
                           // Move points by the orbit offset (Translate)
                           s.start.x = init.origStart.x + dx;
                           s.start.y = init.origStart.y + dy;
                           s.end.x = init.origEnd.x + dx;
                           s.end.y = init.origEnd.y + dy;
                           if (s.control && init.origControl) {
                              s.control.x = init.origControl.x + dx;
                              s.control.y = init.origControl.y + dy;
                           }
                        } else if (s.type === "pencil" || s.type === "pencil-arrow") {
                           // Translate all points
                           if (init.origPoints) {
                              s.points = init.origPoints.map((p) => ({
                                 x: p.x + dx,
                                 y: p.y + dy
                              }));
                           }
                        } else {
                           // For rects/images/text, translate top-left corner
                           s.x = init.origX + dx;
                           s.y = init.origY + dy;
                        }
                     });
                  }

                  // Update cursor rotation while rotating
                  let cursorAngle = 0;
                  // Base angle from handle
                  if (activeHandle === "rot-tr") cursorAngle = 90;
                  else if (activeHandle === "rot-br") cursorAngle = 180;
                  else if (activeHandle === "rot-bl") cursorAngle = 270;

                  // Add current rotation
                  if (selectedIndices.size === 1) {
                     cursorAngle += ((initialShapeAngle + deltaAngle) * 180) / Math.PI;
                  } else {
                     cursorAngle += (deltaAngle * 180) / Math.PI;
                  }

                  const rotateCursor = `
                     <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <g transform="rotate(${cursorAngle}, 12, 12)">
                           <!-- White halo -->
                           <g stroke="white" stroke-width="5" opacity="0.9">
                              <path d="M 4 20 A 12 12 0 0 1 20 4" />
                              <path d="M 1 16 L 4 20 L 7 16" />
                              <path d="M 16 1 L 20 4 L 16 7" />
                           </g>
                           <!-- Black stroke -->
                           <g stroke="black" stroke-width="2">
                              <path d="M 4 20 A 12 12 0 0 1 20 4" />
                              <path d="M 1 16 L 4 20 L 7 16" />
                              <path d="M 16 1 L 20 4 L 16 7" />
                           </g>
                        </g>
                     </svg>
                  `;
                  const cursorUrl = "data:image/svg+xml;base64," + btoa(rotateCursor);
                  canvas.style.cursor = `url('${cursorUrl}') 8 8, alias`;

                  // disable connection updates during rotation to prevent snapping to unrotated bounds
                  // updateConnections();
                  render();
                  return;
               } else if (isManipulatingHandle) {
                  if (selectedIndices.size > 1) {
                     resizeGroup(activeHandle, initialGroupBounds, initialShapeState, pos);
                  } else {
                     const idx = selectedIndices.values().next().value;
                     const shape = shapes[idx];
                     resizeShape(shape, initialShapeState, pos);
                  }
                  updateConnections();
               } else if (isMovingSelection) {
                  const dx = pos.x - moveOffset.x;
                  const dy = pos.y - moveOffset.y;

                  // Temporarily break connections if moving - prevents flickering on simple clicks
                  if (dx !== 0 || dy !== 0) {
                     selectedIndices.forEach((idx) => temporarilyBreakConnections(shapes[idx]));
                  }

                  selectedIndices.forEach((idx) => moveShape(shapes[idx], dx, dy));
                  moveOffset = pos;
                  updateConnections();
               } else if (isBoxSelecting) {
                  selectionBox.end = pos;
               }
               render();
            } else if (currentTool === "eraser") {
               handleEraser(pos);
            } else if (currentShape) {
               if (currentTool === "arrow" && arrowCreationPhase === "drawing_line") {
                  currentShape.end = pos;
                  currentShape.control = {
                     x: (currentShape.start.x + pos.x) / 2,
                     y: (currentShape.start.y + pos.y) / 2,
                  };
               } else if (currentShape.type === "pencil" || currentShape.type === "pencil-arrow") {
                  const lastPt = currentShape.points[currentShape.points.length - 1];

                  if (lastPt) {
                     // Streamline interpolation (algorithm from Excalidraw/tldraw)
                     // Instead of recording raw cursor, interpolate toward it
                     // Lower streamline = smoother, higher = more raw
                     const streamline = 0.5; // 0-1 range
                     const t = 0.15 + (1 - streamline) * 0.85;

                     // Interpolate toward cursor position (linear interpolation)
                     const smoothedPoint = {
                        x: lastPt.x + (pos.x - lastPt.x) * t,
                        y: lastPt.y + (pos.y - lastPt.y) * t,
                     };

                     // Only add point if moved enough (prevents micro-duplicates)
                     const dist = Math.hypot(
                        smoothedPoint.x - lastPt.x,
                        smoothedPoint.y - lastPt.y,
                     );
                     if (dist > 1.5 / camera.scale) {
                        currentShape.points.push(smoothedPoint);
                     }
                  } else {
                     currentShape.points.push(pos);
                  }

                  // Add temporary preview point for responsiveness (shows cursor position)
                  currentShape.points.push(pos);
                  render();
                  currentShape.points.pop();
                  return; // Skip shared render call
               } else if (currentShape.type === "laser") {
                  const lastPt = currentShape.points[currentShape.points.length - 1];
                  if (lastPt) {
                     const dist = Math.hypot(pos.x - lastPt.x, pos.y - lastPt.y);
                     if (dist > 1 / camera.scale) {
                        currentShape.points.push(pos);
                        // Limit tail length for snake effect
                        if (currentShape.points.length > LASER_MAX_TAIL) {
                           currentShape.points.shift();
                        }
                     }
                  } else {
                     currentShape.points.push(pos);
                  }
               } else if (currentShape.type === "line") {
                  currentShape.end = pos;
               } else {
                  currentShape.w = pos.x - startPos.x;
                  currentShape.h = pos.y - startPos.y;
               }
               render();
            }
         }

         // --- Shape Detection & Conversion ---

         function detectShapeType(pencilShape) {
            if (!pencilShape.points || pencilShape.points.length < 4) {
               return null;
            }

            const points = pencilShape.points;
            const firstPt = points[0];
            const lastPt = points[points.length - 1];

            // Get bounding box first to calculate relative closure distance
            let minX = points[0].x,
               maxX = points[0].x;
            let minY = points[0].y,
               maxY = points[0].y;
            points.forEach((p) => {
               minX = Math.min(minX, p.x);
               maxX = Math.max(maxX, p.x);
               minY = Math.min(minY, p.y);
               maxY = Math.max(maxY, p.y);
            });

            const width = maxX - minX;
            const height = maxY - minY;
            const shapeSize = Math.max(width, height);

            // Check if shape is closed (first and last points are close)
            // Use relative distance based on shape size (more lenient for larger shapes)
            const closureDist = Math.hypot(lastPt.x - firstPt.x, lastPt.y - firstPt.y);
            const closureThreshold = Math.max(15, shapeSize * 0.15); // Reduced from 50px/10% to 15px/15% to better handle open shapes like "n"
            const isClosedShape = closureDist < closureThreshold;
            if (!isClosedShape) return null;

            const centerX = minX + width / 2;
            const centerY = minY + height / 2;

            // Calculate average distance from center to determine if it's a circle
            let sumDistFromCenter = 0;
            points.forEach((p) => {
               sumDistFromCenter += Math.hypot(p.x - centerX, p.y - centerY);
            });
            const avgDistFromCenter = sumDistFromCenter / points.length;

            // Circle detection: variance in distance from center should be low
            let radiusVariance = 0;
            points.forEach((p) => {
               const dist = Math.hypot(p.x - centerX, p.y - centerY);
               radiusVariance += Math.pow(dist - avgDistFromCenter, 2);
            });
            radiusVariance = Math.sqrt(radiusVariance / points.length);
            const radiusVarianceRatio = radiusVariance / avgDistFromCenter;

            // Detect major direction changes (corners) using curvature
            const corners = [];
            // Use smaller step for better corner detection
            const step = Math.max(1, Math.floor(points.length / 80)); // More samples for better detection

            for (let i = step * 2; i < points.length - step * 2; i += step) {
               const prev = points[i - step * 2];
               const curr = points[i];
               const next = points[i + step * 2];

               const v1 = { x: curr.x - prev.x, y: curr.y - prev.y };
               const v2 = { x: next.x - curr.x, y: next.y - curr.y };

               const len1 = Math.hypot(v1.x, v1.y);
               const len2 = Math.hypot(v2.x, v2.y);

               if (len1 > 1 && len2 > 1) {
                  const norm1 = { x: v1.x / len1, y: v1.y / len1 };
                  const norm2 = { x: v2.x / len2, y: v2.y / len2 };
                  const dot = norm1.x * norm2.x + norm1.y * norm2.y;

                  // More sensitive corner detection: angle change > ~80 degrees (dot product < -0.1)
                  // This will catch more corners including softer ones
                  if (dot < -0.1) {
                     corners.push({ x: curr.x, y: curr.y, angle: dot });
                  }
               }
            }

            // Remove duplicate/adjacent corners (cluster them)
            const filteredCorners = [];
            const minCornerDistance = Math.max(10, Math.min(width, height) * 0.12); // At least 10px or 12% of smallest dimension

            corners.forEach((corner) => {
               let isNearExisting = false;
               for (let existing of filteredCorners) {
                  if (
                     Math.hypot(corner.x - existing.x, corner.y - existing.y) < minCornerDistance
                  ) {
                     isNearExisting = true;
                     break;
                  }
               }
               if (!isNearExisting) {
                  filteredCorners.push(corner);
               }
            });

            const cornerCount = filteredCorners.length;

            // Determine shape type based on detection criteria
            // Circle detection takes priority (lowest variance)
            if (radiusVarianceRatio < 0.12) {
               return { type: "circle", confidence: 0.9 };
            }

            // Rectangle detection: improved algorithm
            // Check if points are mostly aligned to form a rectangle
            const edgeThreshold = Math.max(10, Math.min(width, height) * 0.2); // At least 10px or 20% of smallest dimension
            let pointsNearEdges = 0;

            points.forEach((p) => {
               const distToLeft = Math.abs(p.x - minX);
               const distToRight = Math.abs(p.x - maxX);
               const distToTop = Math.abs(p.y - minY);
               const distToBottom = Math.abs(p.y - maxY);

               // Check if point is near any edge of the bounding box
               if (
                  distToLeft < edgeThreshold ||
                  distToRight < edgeThreshold ||
                  distToTop < edgeThreshold ||
                  distToBottom < edgeThreshold
               ) {
                  pointsNearEdges++;
               }
            });

            const edgeAlignmentRatio = pointsNearEdges / points.length;
            const aspectRatio = Math.max(width, height) / Math.min(width, height);

            // Rectangle detection: More lenient criteria
            // - Should have 2-8 corners (very forgiving for messy drawings)
            // - At least 50% of points should be near the edges (lowered from 60%)
            // - Aspect ratio should be reasonable (not too extreme)
            // - Shape should have reasonable size (not too small)
            const minSize = 20; // Minimum size for a valid rectangle
            if (
               shapeSize >= minSize &&
               cornerCount >= 2 &&
               cornerCount <= 8 &&
               edgeAlignmentRatio >= 0.5 &&
               aspectRatio < 10.0
            ) {
               // Stricter check for thin shapes (high aspect ratio)
               // Thin shapes like "i" or lines often have high edge alignment by accident
               if (aspectRatio > 3.0 && cornerCount < 3) {
                  return null;
               }

               // Higher confidence for 4 corners
               if (cornerCount === 4) {
                  return { type: "rectangle", confidence: 0.95 };
               } else if (cornerCount === 3 || cornerCount === 5) {
                  return { type: "rectangle", confidence: 0.85 };
               } else if (cornerCount === 2 || cornerCount === 6) {
                  return { type: "rectangle", confidence: 0.75 };
               } else {
                  // Even with 7-8 corners, if edges align well, it's likely a rectangle
                  return { type: "rectangle", confidence: 0.65 };
               }
            }

            // Alternative rectangle detection: if edge alignment is very high,
            // it's likely a rectangle even with fewer corners
            // BUT: Do not use this fallback for very thin shapes, as they trivially satisfy edge alignment
            if (
               shapeSize >= minSize &&
               edgeAlignmentRatio >= 0.7 &&
               aspectRatio < 10.0 &&
               cornerCount >= 0 &&
               Math.min(width, height) > 25 // Ensure shape has some thickness
            ) {
               return { type: "rectangle", confidence: 0.8 };
            }

            return null;
         }

         function convertPencilToShape(pencilShape, detectedShape) {
            const points = pencilShape.points;
            let minX = points[0].x,
               maxX = points[0].x;
            let minY = points[0].y,
               maxY = points[0].y;
            points.forEach((p) => {
               minX = Math.min(minX, p.x);
               maxX = Math.max(maxX, p.x);
               minY = Math.min(minY, p.y);
               maxY = Math.max(maxY, p.y);
            });

            const width = maxX - minX;
            const height = maxY - minY;

            // Map detected shape type to actual shape type used in rendering
            const shapeTypeMap = {
               rectangle: "rect",
               circle: "circle",
               triangle: "triangle",
            };
            const mappedType = shapeTypeMap[detectedShape.type] || detectedShape.type;

            const newShape = {
               id: generateId(),
               type: mappedType,
               x: minX,
               y: minY,
               w: width,
               h: height,
               color: pencilShape.color,
               fillColor: "transparent",
               width: pencilShape.width,
               startConnected: pencilShape.startConnected,
               endConnected: pencilShape.endConnected,
            };

            return newShape;
         }

         function showShapeConversionPrompt(pencilShape, detectedShape) {
            // Create a modal for shape conversion
            const overlay = document.createElement("div");
            overlay.id = "conversion-overlay";
            overlay.style.cssText = `
               position: fixed;
               top: 0;
               left: 0;
               width: 100%;
               height: 100%;
               background: rgba(0, 0, 0, 0.5);
               display: flex;
               align-items: center;
               justify-content: center;
               z-index: 999;
            `;

            const modal = document.createElement("div");
            modal.style.cssText = `
               background: white;
               padding: 24px;
               border-radius: 12px;
               box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
               max-width: 400px;
               text-align: center;
               font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            `;

            const shapeNameMap = {
               circle: "Circle",
               rectangle: "Rectangle",
               triangle: "Triangle",
            };

            const title = document.createElement("h2");
            title.textContent = "Convert to Shape?";
            title.style.cssText = "margin: 0 0 12px 0; font-size: 20px; color: #1f2937;";
            modal.appendChild(title);

            const message = document.createElement("p");
            message.textContent = `Looks like you drew a ${
               shapeNameMap[detectedShape.type]
            }! Would you like to convert it to a shape?`;
            message.style.cssText =
               "margin: 0 0 20px 0; font-size: 14px; color: #6b7280; line-height: 1.5;";
            modal.appendChild(message);

            const confidence = document.createElement("p");
            confidence.textContent = `Confidence: ${Math.round(detectedShape.confidence * 100)}%`;
            confidence.style.cssText = "margin: 0 0 20px 0; font-size: 12px; color: #9ca3af;";
            modal.appendChild(confidence);

            const buttonContainer = document.createElement("div");
            buttonContainer.style.cssText = "display: flex; gap: 12px; justify-content: center;";

            const cancelBtn = document.createElement("button");
            cancelBtn.textContent = "Keep as Drawing";
            cancelBtn.style.cssText = `
               padding: 8px 16px;
               border: 1px solid #d1d5db;
               background: white;
               border-radius: 6px;
               cursor: pointer;
               font-size: 14px;
               color: #6b7280;
               transition: all 0.2s;
            `;
            cancelBtn.onmouseover = () => (cancelBtn.style.background = "#f9fafb");
            cancelBtn.onmouseout = () => (cancelBtn.style.background = "white");
            cancelBtn.onclick = () => {
               overlay.remove();
            };
            buttonContainer.appendChild(cancelBtn);

            const convertBtn = document.createElement("button");
            convertBtn.textContent = "Convert";
            convertBtn.style.cssText = `
               padding: 8px 16px;
               border: none;
               background: #3b82f6;
               color: white;
               border-radius: 6px;
               cursor: pointer;
               font-size: 14px;
               font-weight: 600;
               transition: all 0.2s;
            `;
            convertBtn.onmouseover = () => (convertBtn.style.background = "#2563eb");
            convertBtn.onmouseout = () => (convertBtn.style.background = "#3b82f6");
            convertBtn.onclick = () => {
               // Remove the pencil shape from shapes array
               const pencilIndex = shapes.indexOf(pencilShape);
               if (pencilIndex > -1) {
                  shapes.splice(pencilIndex, 1);
               }

               // Add the converted shape
               const newShape = convertPencilToShape(pencilShape, detectedShape);
               shapes.push(newShape);

               // Update selection
               clearSelection();
               addToSelection(shapes.length - 1);

               // Save history and render
               saveHistory();
               render();
               showToast(`Converted to ${shapeNameMap[detectedShape.type]}`);
               overlay.remove();
            };
            buttonContainer.appendChild(convertBtn);

            modal.appendChild(buttonContainer);
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
         }

         function onMouseUp(e) {
            // Clear connection hover state
            connectionHoverShape = null;

            // End pinch-to-zoom gesture
            if (isPinching) {
               isPinching = false;
               pinchStartDistance = 0;
               return;
            }

            if (camera.isPanning) {
               camera.isPanning = false;
               updateCursor();
               return;
            }

            if (!isDragging) return;
            isDragging = false;

            const screenPos = getPointerPos(e);
            const pos = toWorld(screenPos.x, screenPos.y);

            if (isBoxSelecting) {
               finishBoxSelection();
               isBoxSelecting = false;
               render();
            } else if (isMovingSelection || isManipulatingHandle || isRotating) {
               // Bake rotation into lines/arrows so connection logic works with world coordinates
               if (isRotating) {
                  selectedIndices.forEach((idx) => {
                     const shape = shapes[idx];
                     if ((shape.type === "line" || shape.type === "arrow") && shape.angle) {
                        const b = getBoundingBox(shape);
                        const cx = b.x + b.w / 2;
                        const cy = b.y + b.h / 2;
                        const center = { x: cx, y: cy };

                        shape.start = rotatePoint(shape.start, center, shape.angle);
                        shape.end = rotatePoint(shape.end, center, shape.angle);
                        if (shape.control) {
                           shape.control = rotatePoint(shape.control, center, shape.angle);
                        }
                        shape.angle = 0;
                     }
                  });
               }

               // Re-evaluate connections for moved shapes
               if (isMovingSelection || isRotating) {
                  selectedIndices.forEach((idx) => {
                     const shape = shapes[idx];
                     reEvaluateConnections(shape);
                  });

                  // Show toast if we just duplicated
                  if (isDuplicating) {
                     const count = selectedIndices.size;
                     showToast(`Duplicated ${count} object${count !== 1 ? "s" : ""}`);
                     isDuplicating = false;
                  }
               } else if (isManipulatingHandle) {
                  // Re-evaluate connections when resizing/manipulating handles (e.g. arrow endpoints)
                  selectedIndices.forEach((idx) => {
                     const shape = shapes[idx];
                     reEvaluateConnections(shape);
                  });
               }

               // Ensure connections are visually updated (snapped) immediately
               updateConnections();

               saveHistory();
               isMovingSelection = false;
               isManipulatingHandle = false;
               isRotating = false;
               activeHandle = null;
               render();
            }

            if (currentShape) {
               if (currentTool === "arrow" && arrowCreationPhase === "drawing_line") {
                  const pos = toWorld(getPointerPos(e).x, getPointerPos(e).y);
                  for (let i = shapes.length - 1; i >= 0; i--) {
                     if (isPointInShape(pos, shapes[i])) {
                        currentShape.endConnected = attachToShape(pos, shapes[i], i);
                        break;
                     }
                  }
                  // Simply finish the arrow as a straight line (it is an 'arrow' type but control point is on the line)
                  arrowCreationPhase = "idle";
                  shapes.push(currentShape);
                  saveHistory();

                  // Auto-select the newly created arrow
                  if (!isToolLocked) {
                     setTool("select");
                     clearSelection();
                     addToSelection(shapes.length - 1);
                  } else {
                     clearSelection();
                  }

                  currentShape = null;
                  render();
                  return;
               }

               if (
                  currentTool === "line" ||
                  currentTool === "pencil" ||
                  currentTool === "pencil-arrow"
               ) {
                  // Use outer world pos (L3739) instead of re-fetching screen pos
                  for (let i = shapes.length - 1; i >= 0; i--) {
                     if (isPointInShape(pos, shapes[i])) {
                        currentShape.endConnected = attachToShape(pos, shapes[i], i);
                        break;
                     }
                  }

                  // Add the final point for pencil tools to prevent trimming
                  if (currentTool === "pencil" || currentTool === "pencil-arrow") {
                     currentShape.points.push(pos);
                  }
               }

               const isTiny =
                  currentShape.type === "pencil" || currentShape.type === "pencil-arrow"
                     ? currentShape.points.length < 2
                     : currentShape.type === "laser"
                       ? currentShape.points.length < 2
                       : currentShape.type === "line"
                         ? Math.hypot(
                              currentShape.end.x - currentShape.start.x,
                              currentShape.end.y - currentShape.start.y,
                           ) < 5
                         : Math.abs(currentShape.w) < 5 && Math.abs(currentShape.h) < 5;
               if (!isTiny) {
                  // Laser shapes are temporary and auto-delete
                  if (currentShape.type === "laser") {
                     const laserShape = currentShape; // Capture reference for closure
                     laserShape.deletedCount = 0; // Track how many points have been deleted
                     laserShapes.push(laserShape);

                     // Fade out from tail to head
                     const startTime = Date.now();
                     const fadeInterval = setInterval(() => {
                        const elapsed = Date.now() - startTime;

                        if (elapsed >= LASER_LIFETIME) {
                           // Complete deletion
                           const index = laserShapes.indexOf(laserShape);
                           if (index > -1) {
                              laserShapes.splice(index, 1);
                           }
                           clearInterval(fadeInterval);
                           render();
                        } else if (elapsed > LASER_DELETE_DELAY) {
                           // Start deletion after delay
                           const deleteElapsed = elapsed - LASER_DELETE_DELAY;
                           const deleteProgress = Math.min(
                              1,
                              deleteElapsed / LASER_DELETE_DURATION,
                           );

                           // Gradually delete from start (tail) toward end (head)
                           const pointsToDelete = Math.floor(
                              laserShape.points.length * deleteProgress,
                           );
                           laserShape.deletedCount = pointsToDelete;

                           // Also gradually reduce opacity after deletion starts
                           laserShape.tailOpacity = 1 - deleteProgress;
                           render();
                        } else {
                           // Before delay - just render fully opaque
                           laserShape.deletedCount = 0;
                           laserShape.tailOpacity = 1;
                           render();
                        }
                     }, 16); // ~60fps
                     // Don't save to history or shapes array
                  } else {
                     // Check if pencil shape looks like a closed shape
                     if (currentShape.type === "pencil" || currentShape.type === "pencil-arrow") {
                        // Auto-convert to Arrow if connected to two different shapes
                        if (
                           currentShape.startConnected &&
                           currentShape.endConnected &&
                           currentShape.startConnected.id !== currentShape.endConnected.id
                        ) {
                           const arrowId = generateId(); // Use new ID to be safe
                           const startPt = currentShape.points[0];
                           const endPt = currentShape.points[currentShape.points.length - 1];
                           // const midPt = {
                           //    x: (startPt.x + endPt.x) / 2,
                           //    y: (startPt.y + endPt.y) / 2,
                           // };

                           // Create the Arrow Shape (Straight Line Arrow)
                           // Converted from freehand pencil/arrow when connecting two shapes
                           const newArrow = {
                              id: arrowId,
                              type: "line",
                              start: { x: startPt.x, y: startPt.y },
                              end: { x: endPt.x, y: endPt.y },
                              // control: midPt,
                              color: currentShape.color,
                              fillColor: currentShape.fillColor,
                              width: currentShape.width,
                              startConnected: currentShape.startConnected,
                              endConnected: currentShape.endConnected,
                              hasEndArrow: true,
                              hasStartArrow: false,
                           };

                           shapes.push(newArrow);

                           // Ensure connections are applied/snapped
                           updateConnections();

                           const convertedIndex = shapes.length - 1;
                           clearSelection();
                           addToSelection(convertedIndex);
                           saveHistory();
                           render();

                           showToast("Auto-connected shapes");

                           currentShape = null;
                           render();
                           return;
                        }

                        const detectedShape = detectShapeType(currentShape);
                        if (detectedShape) {
                           // Convert and show undo panel
                           const newShape = convertPencilToShape(currentShape, detectedShape);
                           shapes.push(newShape);
                           const convertedIndex = shapes.length - 1;
                           clearSelection();
                           addToSelection(convertedIndex);
                           saveHistory();
                           render();

                           // Show the undo panel with the original shape
                           showShapeRecognitionPanel(currentShape, convertedIndex);
                        } else {
                           // No shape detected, keep as pencil drawing
                           shapes.push(currentShape);
                           saveHistory();

                           // If it was a freehand arrow, switch to select tool automatically
                           if (currentShape.type === "pencil-arrow") {
                              clearSelection();
                              addToSelection(shapes.length - 1);
                              setTool("select", true);
                           }
                        }
                     } else {
                        shapes.push(currentShape);
                        // Keep pencil and pencil-arrow tools active for continuous drawing
                        // Don't switch tool, don't select - just continue drawing
                        if (!isToolLocked) {
                           clearSelection();
                           selectedIndices.add(shapes.length - 1);
                           setTool("select", true); // Switch tool while keeping the new selection
                        } else {
                           clearSelection();
                           // Don't select the new shape in locked mode so we can immediately draw another
                        }
                        saveHistory();
                     }
                  }
               }
               currentShape = null;
               render();
            }
         }

         // --- Connection Logic ---

         function temporarilyBreakConnections(shape) {
            if (
               !shape ||
               (shape.type !== "arrow" &&
                  shape.type !== "line" &&
                  shape.type !== "pencil" &&
                  shape.type !== "pencil-arrow")
            ) {
               return;
            }
            if (!temporarilyDisconnectedShapes.has(shape.id)) {
               // Store the connections before breaking them
               temporarilyDisconnectedShapes.set(shape.id, {
                  startConnected: shape.startConnected,
                  endConnected: shape.endConnected,
               });
               // Actually break the connections so the shape can move freely
               shape.startConnected = null;
               shape.endConnected = null;
            }
         }

         function restoreConnectionsForShape(shape) {
            if (!shape) return;
            const stored = temporarilyDisconnectedShapes.get(shape.id);
            if (stored) {
               shape.startConnected = stored.startConnected;
               shape.endConnected = stored.endConnected;
               temporarilyDisconnectedShapes.delete(shape.id);
            }
         }

         function reEvaluateConnections(shape) {
            if (
               !shape ||
               (shape.type !== "arrow" &&
                  shape.type !== "line" &&
                  shape.type !== "pencil" &&
                  shape.type !== "pencil-arrow")
            ) {
               return;
            }

            // Check if start point is near a shape
            let startPos, endPos;
            if (shape.type === "pencil" || shape.type === "pencil-arrow") {
               if (shape.points.length === 0) return;
               startPos = shape.points[0];
               endPos = shape.points[shape.points.length - 1];
            } else {
               startPos = shape.start;
               endPos = shape.end;
            }

            // Check for start connection
            let foundStart = false;
            for (let i = shapes.length - 1; i >= 0; i--) {
               if (shapes[i].id === shape.id) continue;
               if (isPointInShape(startPos, shapes[i], 20)) {
                  shape.startConnected = attachToShape(startPos, shapes[i], i);
                  foundStart = true;
                  break;
               }
            }
            if (!foundStart) {
               shape.startConnected = null;
            }

            // Check for end connection
            let foundEnd = false;
            for (let i = shapes.length - 1; i >= 0; i--) {
               if (shapes[i].id === shape.id) continue;
               if (isPointInShape(endPos, shapes[i], 20)) {
                  shape.endConnected = attachToShape(endPos, shapes[i], i);
                  foundEnd = true;
                  break;
               }
            }
            if (!foundEnd) {
               shape.endConnected = null;
            }

            // Remove from temporarily disconnected list
            temporarilyDisconnectedShapes.delete(shape.id);
         }

         function attachToShape(pos, shape, index) {
            const b = getBoundingBox(shape);
            const u = (pos.x - b.x) / Math.max(1, b.w);
            const v = (pos.y - b.y) / Math.max(1, b.h);
            return { id: shape.id, u, v };
         }

         // Helper function to get optimal edge connection point on a shape
         // given a direction point (typically the center of the other connected shape)
         function getEdgeConnectionPoint(shape, directionX, directionY) {
            const b = getBoundingBox(shape);
            const centerX = b.x + b.w / 2;
            const centerY = b.y + b.h / 2;
            const center = { x: centerX, y: centerY };

            // Rotate direction point into local space if shape is rotated
            let localDir = { x: directionX, y: directionY };
            if (shape.angle) {
               localDir = rotatePoint({ x: directionX, y: directionY }, center, -shape.angle);
            }

            // Calculate direction from shape center to the target point (in local space)
            const dx = localDir.x - centerX;
            const dy = localDir.y - centerY;

            let edgePoint = { x: centerX, y: centerY };

            if (shape.type === "circle") {
               // For circles, find the point on the ellipse edge
               const rx = b.w / 2;
               const ry = b.h / 2;

               if (dx === 0 && dy === 0) {
                  // Default to right edge if centers overlap
                  edgePoint = { x: centerX + rx, y: centerY };
               } else {
                  // Normalize and scale to ellipse edge
                  const angle = Math.atan2(dy, dx);
                  edgePoint = {
                     x: centerX + rx * Math.cos(angle),
                     y: centerY + ry * Math.sin(angle),
                  };
               }
            } else {
               // For rectangles and other shapes, find the edge intersection
               if (dx === 0 && dy === 0) {
                  // Default to right edge if centers overlap
                  edgePoint = { x: b.x + b.w, y: centerY };
               } else {
                  // Calculate intersection with rectangle edges
                  let t = Infinity;

                  // Check each edge
                  // Right edge (x = b.x + b.w)
                  if (dx > 0) {
                     const tRight = (b.x + b.w - centerX) / dx;
                     const yIntersect = centerY + tRight * dy;
                     if (yIntersect >= b.y && yIntersect <= b.y + b.h && tRight < t) {
                        t = tRight;
                        edgePoint = { x: b.x + b.w, y: yIntersect };
                     }
                  }
                  // Left edge (x = b.x)
                  if (dx < 0) {
                     const tLeft = (b.x - centerX) / dx;
                     const yIntersect = centerY + tLeft * dy;
                     if (yIntersect >= b.y && yIntersect <= b.y + b.h && tLeft < t) {
                        t = tLeft;
                        edgePoint = { x: b.x, y: yIntersect };
                     }
                  }
                  // Bottom edge (y = b.y + b.h)
                  if (dy > 0) {
                     const tBottom = (b.y + b.h - centerY) / dy;
                     const xIntersect = centerX + tBottom * dx;
                     if (xIntersect >= b.x && xIntersect <= b.x + b.w && tBottom < t) {
                        t = tBottom;
                        edgePoint = { x: xIntersect, y: b.y + b.h };
                     }
                  }
                  // Top edge (y = b.y)
                  if (dy < 0) {
                     const tTop = (b.y - centerY) / dy;
                     const xIntersect = centerX + tTop * dx;
                     if (xIntersect >= b.x && xIntersect <= b.x + b.w && tTop < t) {
                        t = tTop;
                        edgePoint = { x: xIntersect, y: b.y };
                     }
                  }
               }
            }

            // Rotate result back to world space
            if (shape.angle) {
               return rotatePoint(edgePoint, center, shape.angle);
            }

            return edgePoint;
         }

         function updateConnections() {
            const shapeMap = new Map();
            shapes.forEach((s) => shapeMap.set(s.id, s));

            shapes.forEach((shape) => {
               // Skip updating connections for shapes that are temporarily disconnected (being moved)
               if (temporarilyDisconnectedShapes.has(shape.id)) {
                  return;
               }

               if (
                  shape.type === "line" ||
                  shape.type === "arrow" ||
                  shape.type === "pencil" ||
                  shape.type === "pencil-arrow"
               ) {
                  // Get both connected shapes first
                  const startTarget = shape.startConnected
                     ? shapeMap.get(shape.startConnected.id)
                     : null;
                  const endTarget = shape.endConnected ? shapeMap.get(shape.endConnected.id) : null;

                  // Calculate optimal connection points
                  let startPoint = null;
                  let endPoint = null;

                  if (startTarget && endTarget) {
                     // Both ends connected to shapes - always use center-to-center for edge calculation
                     const startBox = getBoundingBox(startTarget);
                     const endBox = getBoundingBox(endTarget);
                     const startCenterX = startBox.x + startBox.w / 2;
                     const startCenterY = startBox.y + startBox.h / 2;
                     const endCenterX = endBox.x + endBox.w / 2;
                     const endCenterY = endBox.y + endBox.h / 2;

                     // Always use center-to-center direction for edge connection points
                     // This ensures edges update correctly when shapes swap positions
                     startPoint = getEdgeConnectionPoint(startTarget, endCenterX, endCenterY);
                     endPoint = getEdgeConnectionPoint(endTarget, startCenterX, startCenterY);
                  } else if (startTarget) {
                     // Only start connected - use control point or end point as direction
                     let directionPos;
                     if (shape.type === "pencil" || shape.type === "pencil-arrow") {
                        directionPos = shape.points[shape.points.length - 1];
                     } else if (shape.type === "arrow" && shape.control) {
                        // For curved arrows, start should point towards control
                        directionPos = shape.control;
                     } else {
                        directionPos = shape.end;
                     }
                     startPoint = getEdgeConnectionPoint(
                        startTarget,
                        directionPos.x,
                        directionPos.y,
                     );
                  } else if (endTarget) {
                     // Only end connected - use control point or start point as direction
                     let directionPos;
                     if (shape.type === "pencil" || shape.type === "pencil-arrow") {
                        directionPos = shape.points[0];
                     } else if (shape.type === "arrow" && shape.control) {
                        // For curved arrows, end should point towards control
                        directionPos = shape.control;
                     } else {
                        directionPos = shape.start;
                     }
                     endPoint = getEdgeConnectionPoint(endTarget, directionPos.x, directionPos.y);
                  }

                  // Apply the calculated connection points
                  if (startPoint && startTarget) {
                     if (shape.type === "pencil" || shape.type === "pencil-arrow") {
                        const dx = startPoint.x - shape.points[0].x;
                        const dy = startPoint.y - shape.points[0].y;
                        const range = Math.min(shape.points.length, 12);
                        for (let i = 0; i < range; i++) {
                           const influence = 1 - i / range;
                           shape.points[i].x += dx * influence;
                           shape.points[i].y += dy * influence;
                        }
                     } else {
                        shape.start.x = startPoint.x;
                        shape.start.y = startPoint.y;
                     }

                     // Update stored u,v values
                     const b = getBoundingBox(startTarget);
                     shape.startConnected.u = (startPoint.x - b.x) / Math.max(1, b.w);
                     shape.startConnected.v = (startPoint.y - b.y) / Math.max(1, b.h);
                  } else if (shape.startConnected && !startTarget) {
                     shape.startConnected = null;
                  }

                  if (endPoint && endTarget) {
                     if (shape.type === "pencil" || shape.type === "pencil-arrow") {
                        const last = shape.points.length - 1;
                        const dx = endPoint.x - shape.points[last].x;
                        const dy = endPoint.y - shape.points[last].y;
                        const range = Math.min(shape.points.length, 12);
                        for (let i = 0; i < range; i++) {
                           const idx = last - i;
                           const influence = 1 - i / range;
                           shape.points[idx].x += dx * influence;
                           shape.points[idx].y += dy * influence;
                        }
                     } else {
                        shape.end.x = endPoint.x;
                        shape.end.y = endPoint.y;
                     }

                     // Update stored u,v values
                     const b = getBoundingBox(endTarget);
                     shape.endConnected.u = (endPoint.x - b.x) / Math.max(1, b.w);
                     shape.endConnected.v = (endPoint.y - b.y) / Math.max(1, b.h);
                  } else if (shape.endConnected && !endTarget) {
                     shape.endConnected = null;
                  }

                  // Update control point for arrows when both ends are connected
                  // This keeps the curve properly centered between the shapes
                  if (
                     shape.type === "arrow" &&
                     shape.control &&
                     startPoint &&
                     endPoint &&
                     startTarget &&
                     endTarget
                  ) {
                     shape.control.x = (startPoint.x + endPoint.x) / 2;
                     shape.control.y = (startPoint.y + endPoint.y) / 2;
                  }
               }
            });
         }

         // --- Alignment Logic ---

         function hasConnections(shape) {
            // Check if the shape itself is a connector with connections
            if (
               shape.type === "line" ||
               shape.type === "arrow" ||
               shape.type === "pencil" ||
               shape.type === "pencil-arrow"
            ) {
               if (shape.startConnected || shape.endConnected) {
                  return true;
               }
            }

            // Check if any other shape is connected to this shape
            for (let i = 0; i < shapes.length; i++) {
               const s = shapes[i];
               if (s.id === shape.id) continue;

               if (
                  s.type === "line" ||
                  s.type === "arrow" ||
                  s.type === "pencil" ||
                  s.type === "pencil-arrow"
               ) {
                  if (
                     (s.startConnected && s.startConnected.id === shape.id) ||
                     (s.endConnected && s.endConnected.id === shape.id)
                  ) {
                     return true;
                  }
               }
            }

            return false;
         }

         function alignSelected(mode) {
            if (selectedIndices.size < 2) return;

            // Get the LAST selected object as the anchor (reference point)
            // Use explicit selectionQueue to guarantee chronological order
            // Fallback to Array.from(selectedIndices) if queue is empty (e.g. legacy selection)
            let anchorIdx;
            if (selectionQueue.length > 0) {
               anchorIdx = selectionQueue[selectionQueue.length - 1];
            } else {
               const indices = Array.from(selectedIndices);
               anchorIdx = indices[indices.length - 1];
            }
            const anchorShape = shapes[anchorIdx];
            const anchorBox = getBoundingBox(anchorShape);
            const anchorX = Math.min(anchorBox.x, anchorBox.x + anchorBox.w);
            const anchorY = Math.min(anchorBox.y, anchorBox.y + anchorBox.h);
            const anchorW = Math.abs(anchorBox.w);
            const anchorH = Math.abs(anchorBox.h);

            // Calculate reference positions from the anchor object
            let refLeft = anchorX;
            let refRight = anchorX + anchorW;
            let refTop = anchorY;
            let refBottom = anchorY + anchorH;
            let refCenterH = anchorX + anchorW / 2;
            let refMiddleV = anchorY + anchorH / 2;

            // Align all other objects to the anchor
            selectedIndices.forEach((idx) => {
               // Skip the anchor object itself
               if (idx === anchorIdx) return;

               const shape = shapes[idx];

               // Skip shapes with connections (flow chart objects)
               if (hasConnections(shape)) return;

               const b = getBoundingBox(shape);
               const bx = Math.min(b.x, b.x + b.w);
               const by = Math.min(b.y, b.y + b.h);
               const bw = Math.abs(b.w);
               const bh = Math.abs(b.h);

               let dx = 0;
               let dy = 0;

               if (mode === "left") dx = refLeft - bx;
               else if (mode === "center-h") dx = refCenterH - (bx + bw / 2);
               else if (mode === "right") dx = refRight - (bx + bw);
               else if (mode === "top") dy = refTop - by;
               else if (mode === "middle-v") dy = refMiddleV - (by + bh / 2);
               else if (mode === "bottom") dy = refBottom - (by + bh);

               moveShape(shape, dx, dy);
            });

            updateConnections();
            render();
            saveHistory();
         }

         // --- Helper: Movement & Resizing ---

         function moveShape(shape, dx, dy) {
            if (shape.type === "pencil" || shape.type === "pencil-arrow") {
               shape.points.forEach((p) => {
                  p.x += dx;
                  p.y += dy;
               });
            } else if (shape.type === "line" || shape.type === "arrow") {
               shape.start.x += dx;
               shape.start.y += dy;
               shape.end.x += dx;
               shape.end.y += dy;
               if (shape.control) {
                  shape.control.x += dx;
                  shape.control.y += dy;
               }
            } else {
               shape.x += dx;
               shape.y += dy;
            }
         }

         function resizeShape(shape, init, pos) {
            if (activeHandle === "bend") {
               // Convert line to arrow
               // Preserve existing arrow state, defaulting to false if undefined (since lines default to no arrow)
               if (shape.hasEndArrow === undefined) {
                  shape.hasEndArrow = false;
               }
               shape.type = "arrow";
               shape.control = pos;
               // Switch handle to control so subsequent moves update the control point
               activeHandle = "control";
               return;
            }

            if (shape.type === "arrow" || shape.type === "line") {
               if (activeHandle === "start") shape.start = pos;
               else if (activeHandle === "end") shape.end = pos;
               else if (activeHandle === "control") shape.control = pos;
               return;
            }

            let initX = init.x;
            let initY = init.y;
            let initW = init.w;
            let initH = init.h;

            if (
               shape.type === "text" ||
               shape.type === "pencil" ||
               shape.type === "pencil-arrow" ||
               shape.type === "image"
            ) {
               const b = getBoundingBox(init);
               initX = b.x;
               initY = b.y;
               initW = b.w;
               initH = b.h;
            }

            const dxWorld = pos.x - startPos.x;
            const dyWorld = pos.y - startPos.y;

            let dx, dy;
            if (shape.angle) {
               const cos = Math.cos(-shape.angle);
               const sin = Math.sin(-shape.angle);
               dx = dxWorld * cos - dyWorld * sin;
               dy = dxWorld * sin + dyWorld * cos;
            } else {
               dx = dxWorld;
               dy = dyWorld;
            }

            let newX = initX,
               newY = initY,
               newW = initW,
               newH = initH;

            if (activeHandle === "br") {
               newW = initW + dx;
               newH = initH + dy;
            } else if (activeHandle === "bl") {
               newX = initX + dx;
               newW = initW - dx;
               newH = initH + dy;
            } else if (activeHandle === "tr") {
               newY = initY + dy;
               newW = initW + dx;
               newH = initH - dy;
            } else if (activeHandle === "tl") {
               newX = initX + dx;
               newY = initY + dy;
               newW = initW - dx;
               newH = initH - dy;
            } else if (activeHandle === "top") {
               // Top side: resize height from top
               newY = initY + dy;
               newH = initH - dy;
            } else if (activeHandle === "bottom") {
               // Bottom side: resize height from bottom
               newH = initH + dy;
            } else if (activeHandle === "left") {
               // Left side: resize width from left
               newX = initX + dx;
               newW = initW - dx;
            } else if (activeHandle === "right") {
               // Right side: resize width from right
               newW = initW + dx;
            }

            if (shape.type === "text") {
               if (newH < 5) {
                  newH = 5;
                  if (activeHandle.includes("t")) newY = initY + initH - 5;
               }
               const lineCount = shape.text.split('\n').length || 1;
               shape.size = Math.abs(newH) / lineCount;
               shape.x = newX;
               shape.y = newY;
            } else if (shape.type === "pencil" || shape.type === "pencil-arrow") {
               const scaleX = initW === 0 ? 1 : newW / initW;
               const scaleY = initH === 0 ? 1 : newH / initH;

               shape.points = init.points.map((p) => ({
                  x: newX + (p.x - initX) * scaleX,
                  y: newY + (p.y - initY) * scaleY,
               }));
            } else if (shape.type === "image") {
               // Maintain aspect ratio when resizing
               if (shape.aspectRatio) {
                  if (activeHandle === "br") {
                     // Bottom-right: expand both dimensions
                     newH = newW / shape.aspectRatio;
                  } else if (activeHandle === "bl") {
                     // Bottom-left: maintain ratio with height change
                     newH = (initW - dx) / shape.aspectRatio;
                     newW = initW - dx;
                     newX = initX + dx;
                  } else if (activeHandle === "tr") {
                     // Top-right: maintain ratio with width change
                     newH = newW / shape.aspectRatio;
                     newY = initY + initH - newH;
                  } else if (activeHandle === "tl") {
                     // Top-left: maintain ratio with width change
                     newW = initW - dx;
                     newH = newW / shape.aspectRatio;
                     newX = initX + dx;
                     newY = initY + initH - newH;
                  } else if (activeHandle === "top" || activeHandle === "bottom") {
                     // Top/Bottom side: maintain aspect ratio with height change
                     newW = Math.abs(newH * shape.aspectRatio);
                     const centerX = initX + initW / 2;
                     newX = centerX - newW / 2;
                  } else if (activeHandle === "left" || activeHandle === "right") {
                     // Left/Right side: maintain aspect ratio with width change
                     newH = Math.abs(newW / shape.aspectRatio);
                     const centerY = initY + initH / 2;
                     newY = centerY - newH / 2;
                  }
               }
               shape.x = newX;
               shape.y = newY;
               shape.w = newW;
               shape.h = newH;
            } else {
               shape.x = newX;
               shape.y = newY;
               shape.w = newW;
               shape.h = newH;
            }
         }

         function finishBoxSelection() {
            if (!selectionBox) return;
            const x1 = Math.min(selectionBox.start.x, selectionBox.end.x);
            const x2 = Math.max(selectionBox.start.x, selectionBox.end.x);
            const y1 = Math.min(selectionBox.start.y, selectionBox.end.y);
            const y2 = Math.max(selectionBox.start.y, selectionBox.end.y);

            shapes.forEach((shape, index) => {
               const b = getBoundingBox(shape);
               const bx = Math.min(b.x, b.x + b.w);
               const by = Math.min(b.y, b.y + b.h);
               const bw = Math.abs(b.w);
               const bh = Math.abs(b.h);

               if (bx < x2 && bx + bw > x1 && by < y2 && by + bh > y1) {
                  // Refined check for skeletal shapes (Pencil, Line, Arrow) to avoid selecting by loose bounding box
                  if (
                     shape.type === "pencil" ||
                     shape.type === "pencil-arrow" ||
                     shape.type === "line" ||
                     shape.type === "arrow"
                  ) {
                     let intersects = false;
                     let pointsToCheck = [];

                     if (shape.type === "line" || shape.type === "arrow") {
                        pointsToCheck.push(shape.start);
                        pointsToCheck.push(shape.end);
                     } else if (shape.points) {
                        pointsToCheck = shape.points;
                     }

                     // 1. Check if any point is inside the selection box
                     for (const p of pointsToCheck) {
                        if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2) {
                           intersects = true;
                           break;
                        }
                     }

                     // 2. If not, check if any segment crosses the box edges
                     if (!intersects && pointsToCheck.length > 1) {
                        const rectLines = [
                           { p1: { x: x1, y: y1 }, p2: { x: x2, y: y1 } },
                           { p1: { x: x2, y: y1 }, p2: { x: x2, y: y2 } },
                           { p1: { x: x2, y: y2 }, p2: { x: x1, y: y2 } },
                           { p1: { x: x1, y: y2 }, p2: { x: x1, y: y1 } },
                        ];

                        for (let i = 0; i < pointsToCheck.length - 1; i++) {
                           const pA = pointsToCheck[i];
                           const pB = pointsToCheck[i + 1];

                           for (const edge of rectLines) {
                              if (linesIntersect(pA, pB, edge.p1, edge.p2)) {
                                 intersects = true;
                                 break;
                              }
                           }
                           if (intersects) break;
                        }
                     }

                     if (intersects) {
                        addToSelection(index);
                     }
                  } else {
                     addToSelection(index);
                  }
               }
            });
            selectionBox = null;
         }

         function linesIntersect(p1, p2, p3, p4) {
            const det = (p2.x - p1.x) * (p4.y - p3.y) - (p4.x - p3.x) * (p2.y - p1.y);
            if (det === 0) return false;
            const lambda = ((p4.y - p3.y) * (p4.x - p1.x) + (p3.x - p4.x) * (p4.y - p1.y)) / det;
            const gamma = ((p1.y - p2.y) * (p4.x - p1.x) + (p2.x - p1.x) * (p4.y - p1.y)) / det;
            return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;
         }

         // --- Text Tool ---

         function createTextInput(x, y, text = "", size = null, color = null, isBoldVal = null) {
            if (activeInput) cleanupInput();

            isTyping = true;
            const input = document.createElement("textarea");
            input.id = "text-input";

            // Transform world coordinates to screen coordinates for the HTML element
            const screenPos = toScreen(x, y);
            input.style.left = screenPos.x + "px";
            input.style.top = screenPos.y + "px";

            const useColor = color || currentColor;
            const useSize = size || currentWidth * 5 + 10;
            const displaySize = useSize * camera.scale;
            const useBold = isBoldVal !== null ? isBoldVal : isBold;

            input.style.color = useColor;
            input.style.fontSize = displaySize + "px";
            input.style.fontWeight = useBold ? "bold" : "normal";
            
            // Apply stroke to both bold and normal to match canvas rendering
            const strokeDivisor = useBold ? 40 : 100;
            input.style.webkitTextStroke = (displaySize / strokeDivisor) + "px " + useColor;
            
            input.style.lineHeight = "1";
            input.style.overflow = "hidden";
            input.style.resize = "none";
            input.style.minHeight = displaySize + "px";
            input.style.whiteSpace = "pre";
            input.value = text;

            document.body.appendChild(input);

            // Function to update input width and height based on text content
            const updateInputSize = () => {
               input.style.height = "auto";
               input.style.height = input.scrollHeight + "px";
               
               // Create a temporary span to measure text width
               const measureSpan = document.createElement("span");
               measureSpan.style.font = `${useBold ? "bold" : "normal"} ${displaySize}px 'Caveat', cursive`;
               measureSpan.style.visibility = "hidden";
               measureSpan.style.position = "absolute";
               measureSpan.style.whiteSpace = "pre";
               measureSpan.textContent = input.value || " ";
               document.body.appendChild(measureSpan);

               const lines = input.value.split("\n");
               let maxWidth = 50;
               lines.forEach(line => {
                   measureSpan.textContent = line || " ";
                   maxWidth = Math.max(maxWidth, measureSpan.offsetWidth);
               });
               
               document.body.removeChild(measureSpan);

               // Set input width with some padding (add 10px for cursor and breathing room)
               input.style.width = (maxWidth + 20) + "px";
            };

            // Update size initially
            updateInputSize();

            // Update size as user types
            input.addEventListener("input", updateInputSize);

            setTimeout(() => {
               input.focus();
               if (text) {
                  const len = input.value.length;
                  input.setSelectionRange(len, len);
               }
            }, 10);
            activeInput = input;

            const finish = () => {
               if (!activeInput) return;

               const trimmedText = input.value.trim();
               if (trimmedText !== "") {
                  shapes.push({
                     id: generateId(),
                     type: "text",
                     x: x,
                     y: y,
                     text: trimmedText,
                     size: useSize,
                     color: useColor,
                     fillColor: currentFillColor,
                     width: 1,
                     isBold: useBold,
                  });
                  clearSelection();
                  if (!isToolLocked) {
                     addToSelection(shapes.length - 1);
                     setTool("select", true);
                  } else {
                     // In locked mode, keep the current text tool and prepare for new input
                     // Don't select the new text object
                  }
                  saveHistory();
                  render();
               }
               cleanupInput();
            };

            input.addEventListener("keydown", (e) => {
               if (e.key === "Enter" && !e.shiftKey) {
                  // Allow default Enter behavior (new line)
                  // e.stopPropagation(); 
               }
               // If you want Shift+Enter to finish, or maybe nothing (click outside)
            });
            input.addEventListener("blur", finish);
         }

         function cleanupInput() {
            if (activeInput) {
               activeInput.remove();
               activeInput = null;
            }
            isTyping = false;
            isFinishingText = true;
            setTimeout(() => {
               isFinishingText = false;
            }, 200);
         }

         function createTextInputForShape(
            x,
            y,
            text = "",
            size = null,
            color = null,
            shapeIndex = -1,
         ) {
            if (activeInput) cleanupInput();

            // Mark the shape as being edited
            if (shapeIndex >= 0 && shapeIndex < shapes.length) {
               shapes[shapeIndex].isEditingText = true;
               render(); // Redraw without the old text
            }

            isTyping = true;
            const input = document.createElement("textarea");
            input.id = "text-input";

            // Transform world coordinates to screen coordinates for the HTML element
            const screenPos = toScreen(x, y);

            const useColor = color || currentColor;
            const useSize = size || currentWidth * 5 + 10;
            const displaySize = useSize * camera.scale;

            // Determine font weight
            let useBold = isBold;
            if (shapeIndex >= 0 && shapeIndex < shapes.length) {
               useBold = shapes[shapeIndex].isBold !== false;
            }

            input.style.color = useColor;
            input.style.fontSize = displaySize + "px";
            input.style.fontWeight = useBold ? "bold" : "normal";

            // Apply stroke to both bold and normal to match canvas rendering
            const strokeDivisor = useBold ? 40 : 100;
            input.style.webkitTextStroke = (displaySize / strokeDivisor) + "px " + useColor;

            input.style.lineHeight = "1";
            input.style.textAlign = "center";
            input.style.overflow = "hidden";
            input.style.resize = "none";
            input.style.minHeight = displaySize + "px";
            input.style.whiteSpace = "pre";
            // Add halo effect removed as it makes white text unreadable on dark shapes
            input.style.textShadow = "none";
            input.value = text;

            // Position the input centered
            input.style.left = screenPos.x + "px";
            input.style.top = screenPos.y + "px";
            // Reset transform as we'll handle centering with margin calculation in updateInputSize
            input.style.transform = "translate(-50%, -50%)";

            document.body.appendChild(input);

            // Function to update input width and height based on text content
            const updateInputSize = () => {
               input.style.height = "auto";
               input.style.height = input.scrollHeight + "px";

               // Create a temporary span to measure text width
               const measureSpan = document.createElement("span");
               measureSpan.style.font = `${useBold ? "bold" : "normal"} ${displaySize}px 'Caveat', cursive`;
               measureSpan.style.visibility = "hidden";
               measureSpan.style.position = "absolute";
               measureSpan.style.whiteSpace = "pre";
               measureSpan.textContent = input.value || " ";
               document.body.appendChild(measureSpan);

               const lines = input.value.split("\n");
               let maxWidth = 50;
               lines.forEach(line => {
                   measureSpan.textContent = line || " ";
                   maxWidth = Math.max(maxWidth, measureSpan.offsetWidth);
               });
               
               document.body.removeChild(measureSpan);

               // Set input width with some padding (add 10px for cursor and breathing room)
               input.style.width = Math.max(50, maxWidth + 20) + "px";
            };

            // Update size initially
            updateInputSize();

            // Update size as user types
            input.addEventListener("input", updateInputSize);

            setTimeout(() => {
               input.focus();
               if (text) {
                  const len = input.value.length;
                  input.setSelectionRange(len, len);
               }
            }, 10);
            activeInput = input;

            const finish = () => {
               if (!activeInput) return;

               const trimmedText = input.value.trim();
               if (shapeIndex >= 0 && shapeIndex < shapes.length) {
                  const shape = shapes[shapeIndex];
                  // Update the shape's inner text properties
                  shape.innerText = trimmedText;
                  shape.innerTextSize = useSize;
                  shape.innerTextColor = useColor;
                  // Mark as no longer editing
                  shape.isEditingText = false;

                  // Select the shape after editing
                  clearSelection();
                  selectedIndices.add(shapeIndex);
                  setTool("select", true);
                  saveHistory();
                  render();
               }
               cleanupInput();
            };

            input.addEventListener("keydown", (e) => {
               // Allow default enter behavior
            });
            input.addEventListener("blur", finish);
         }

         // --- Helpers: Eraser & Hit Testing ---

         // Track shapes currently fading out (to prevent double-erasing)
         let fadingShapeIds = new Set();

         function handleEraser(pos) {
            let anyHit = false;
            for (let i = shapes.length - 1; i >= 0; i--) {
               const shape = shapes[i];
               // Skip if this shape is already fading out
               if (fadingShapeIds.has(shape.id)) continue;

               // Use larger hit area for eraser (20px) to ensure smooth erasing
               if (isPointInShape(pos, shape, 20)) {
                  // Mark shape as fading
                  fadingShapeIds.add(shape.id);
                  anyHit = true;

                  // Start fade-out animation
                  const fadeStartTime = Date.now();
                  const fadeDuration = 80; // 80ms fade-out (faster)
                  shape.eraserOpacity = 1;

                  const fadeInterval = setInterval(() => {
                     const elapsed = Date.now() - fadeStartTime;
                     const progress = Math.min(1, elapsed / fadeDuration);

                     // Easing function for smooth fade
                     shape.eraserOpacity = 1 - progress;

                     if (progress >= 1) {
                        // Fade complete - remove the shape
                        clearInterval(fadeInterval);
                        const idx = shapes.indexOf(shape);
                        if (idx > -1) {
                           shapes.splice(idx, 1);
                        }
                        fadingShapeIds.delete(shape.id);
                        clearSelection();
                        updateConnections();
                        saveHistory();
                        render();
                     } else {
                        render();
                     }
                  }, 16); // ~60fps
               }
            }
            if (anyHit) render();
         }

         function getHitHandle(pos, shape) {
            let localPos = pos;
            if (shape.angle) {
               const b = getBoundingBox(shape);
               const cx = b.x + b.w / 2;
               const cy = b.y + b.h / 2;
               localPos = rotatePoint(pos, { x: cx, y: cy }, -shape.angle);
            }

            let r = 12 / camera.scale;

            // Adjust radius for small objects to prioritize moving
            let minDimension = Infinity;

            if (shape.type === "arrow" || shape.type === "line") {
               const len = Math.hypot(shape.end.x - shape.start.x, shape.end.y - shape.start.y);
               minDimension = len;
            } else {
               let w, h;
               if (
                  shape.type === "text" ||
                  shape.type === "pencil" ||
                  shape.type === "pencil-arrow" ||
                  shape.type === "image"
               ) {
                  const b = getBoundingBox(shape);
                  w = b.w;
                  h = b.h;
               } else {
                  w = shape.w;
                  h = shape.h;
               }
               minDimension = Math.min(Math.abs(w), Math.abs(h));
            }

            // Cap the handle radius to 1/3 of the smallest dimension
            // This ensures there is always a "safe zone" in the middle for moving
            const maxR = minDimension / 3;
            if (r > maxR) {
               r = Math.max(2 / camera.scale, maxR); // Ensure it doesn't get impossibly small (min 2px visual)
            }

            if (shape.type === "arrow" || shape.type === "line") {
               if (dist(localPos, shape.start) < r) return "start";
               if (dist(localPos, shape.end) < r) return "end";
               if (shape.type === "arrow" && shape.control && dist(localPos, shape.control) < r) {
                  if (!(shape.startConnected && shape.endConnected)) {
                     return "control";
                  }
               }
               if (shape.type === "line") {
                  if (!(shape.startConnected && shape.endConnected)) {
                     const midX = (shape.start.x + shape.end.x) / 2;
                     const midY = (shape.start.y + shape.end.y) / 2;
                     if (dist(localPos, { x: midX, y: midY }) < r) return "bend";
                  }
               }
            } else {
               let x, y, w, h;
               if (
                  shape.type === "text" ||
                  shape.type === "pencil" ||
                  shape.type === "pencil-arrow" ||
                  shape.type === "image"
               ) {
                  const b = getBoundingBox(shape);
                  x = b.x;
                  y = b.y;
                  w = b.w;
                  h = b.h;
               } else {
                  x = shape.x;
                  y = shape.y;
                  w = shape.w;
                  h = shape.h;
               }

               // Check visual size for Single Handle Mode (Match drawSelectionHandles logic)
               const minVisualDim = Math.min(Math.abs(w), Math.abs(h)) * camera.scale;
               const isSmall = minVisualDim < 30;

               if (isSmall) {
                  // Only check BR handle
                  if (dist(localPos, { x: x + w, y: y + h }) < r) return "br";
                  return null; // Ignore all other handles
               }

               // Corners (larger hit area)
               if (dist(localPos, { x: x, y: y }) < r) return "tl";
               if (dist(localPos, { x: x + w, y: y }) < r) return "tr";
               if (dist(localPos, { x: x, y: y + h }) < r) return "bl";
               if (dist(localPos, { x: x + w, y: y + h }) < r) return "br";

               // Sides (smaller hit area - check for proximity to edge)
               const sideR = Math.min(8 / camera.scale, r * 0.8); // Scale side hit area too
               // Top side
               if (Math.abs(localPos.y - y) < sideR && localPos.x > x + r && localPos.x < x + w - r) return "top";
               // Bottom side
               if (Math.abs(localPos.y - (y + h)) < sideR && localPos.x > x + r && localPos.x < x + w - r)
                  return "bottom";
               // Left side
               if (Math.abs(localPos.x - x) < sideR && localPos.y > y + r && localPos.y < y + h - r) return "left";
               // Right side
               if (Math.abs(localPos.x - (x + w)) < sideR && localPos.y > y + r && localPos.y < y + h - r)
                  return "right";

               // Rotation Handles (Hit only outside corners in distinct quadrants)
               // This prevents overlap with side resize zones and ensures rotation only works at "corners"
               const rotR = r + 20 / camera.scale;
               const signW = w >= 0 ? 1 : -1;
               const signH = h >= 0 ? 1 : -1;
               const strictBuffer = 2 / camera.scale; // Small buffer to avoid overlap on the exact edge line

               // TL Handle (x, y)
               if (dist(localPos, { x: x, y: y }) < rotR) {
                  // Must be outside-left and outside-top relative to corner orientation
                  if ((localPos.x - x) * signW < -strictBuffer && (localPos.y - y) * signH < -strictBuffer) return "rot-tl";
               }

               // TR Handle (x+w, y)
               if (dist(localPos, { x: x + w, y: y }) < rotR) {
                  // Must be outside-right and outside-top
                  if ((localPos.x - (x + w)) * signW > strictBuffer && (localPos.y - y) * signH < -strictBuffer) return "rot-tr";
               }

               // BL Handle (x, y+h)
               if (dist(localPos, { x: x, y: y + h }) < rotR) {
                  // Must be outside-left and outside-bottom
                  if ((localPos.x - x) * signW < -strictBuffer && (localPos.y - (y + h)) * signH > strictBuffer) return "rot-bl";
               }

               // BR Handle (x+w, y+h)
               if (dist(localPos, { x: x + w, y: y + h }) < rotR) {
                  // Must be outside-right and outside-bottom
                  if ((localPos.x - (x + w)) * signW > strictBuffer && (localPos.y - (y + h)) * signH > strictBuffer) return "rot-br";
               }
            }
            return null;
         }

         function bringToFront() {
            if (selectedIndices.size === 0) return;
            const selectedShapes = [];
            const remainingShapes = [];
            shapes.forEach((s, i) => {
               if (selectedIndices.has(i)) selectedShapes.push(s);
               else remainingShapes.push(s);
            });
            shapes = [...remainingShapes, ...selectedShapes];
            clearSelection();
            for (let i = shapes.length - selectedShapes.length; i < shapes.length; i++) {
               addToSelection(i);
            }
            saveHistory();
            render();
            showToast("Brought to Front");
         }

         function sendToBack() {
            if (selectedIndices.size === 0) return;
            const selectedShapes = [];
            const remainingShapes = [];
            shapes.forEach((s, i) => {
               if (selectedIndices.has(i)) selectedShapes.push(s);
               else remainingShapes.push(s);
            });
            shapes = [...selectedShapes, ...remainingShapes];
            clearSelection();
            for (let i = 0; i < selectedShapes.length; i++) {
               addToSelection(i);
            }
            saveHistory();
            render();
            showToast("Sent to Back");
         }

         function isPointInShape(pos, shape, hitPaddingOverride = null) {
            // Apply inverse rotation to point for hit testing
            if (shape.angle) {
               const b = getBoundingBox(shape);
               const cx = b.x + b.w / 2;
               const cy = b.y + b.h / 2;
               pos = rotatePoint(pos, { x: cx, y: cy }, -shape.angle);
            }

            // Tighter selection threshold: half width + small padding (3px)
            const basePadding = hitPaddingOverride !== null ? hitPaddingOverride : 3;
            // Ensure camera.scale is not 0 to avoid Infinity
            const scale = camera.scale || 1;
            const hitPadding = basePadding / scale;
            const halfWidth = (shape.width || 2) / 2;
            const t = halfWidth + hitPadding;

            const isFilled = shape.fillColor && shape.fillColor !== "transparent";

            if (shape.type === "rect") {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);

               // For filled rectangles, check if point is inside
               if (isFilled) {
                  return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
               }

               // For UNFILLED rectangles, ONLY check the border (stroke)
               // This prevents the "imaginary rectangular area" issue
               // Check outer bounds and inner bounds
               const outerWait =
                  pos.x >= x - t && pos.x <= x + w + t && pos.y >= y - t && pos.y <= y + h + t;
               const innerWait =
                  pos.x > x + t && pos.x < x + w - t && pos.y > y + t && pos.y < y + h - t;
               return outerWait && !innerWait;
            } else if (shape.type === "circle") {
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               const rx = Math.abs(shape.w / 2);
               const ry = Math.abs(shape.h / 2);
               const normalizedX = (pos.x - cx) / rx;
               const normalizedY = (pos.y - cy) / ry;
               const distSq = normalizedX * normalizedX + normalizedY * normalizedY;

               if (isFilled && distSq <= 1.05) return true;

               // For stroked circles, check the stroke area only
               // Distance from center should be close to 1
               if (!isFilled) {
                  return Math.abs(Math.sqrt(distSq) - 1) * Math.max(rx, ry) < t;
               }
               return distSq <= 1.0;
            } else if (shape.type === "triangle") {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);

               const p1 = { x: x + w / 2, y: y }; // Top
               const p2 = { x: x + w, y: y + h }; // Bottom Right
               const p3 = { x: x, y: y + h }; // Bottom Left

               if (isFilled) {
                  // Barycentric coordinate system
                  const area =
                     0.5 *
                     (-p2.y * p3.x + p1.y * (-p2.x + p3.x) + p1.x * (p2.y - p3.y) + p2.x * p3.y);
                  const s =
                     (1 / (2 * area)) *
                     (p1.y * p3.x - p1.x * p3.y + (p3.y - p1.y) * pos.x + (p1.x - p3.x) * pos.y);
                  const t_val =
                     (1 / (2 * area)) *
                     (p1.x * p2.y - p1.y * p2.x + (p1.y - p2.y) * pos.x + (p2.x - p1.x) * pos.y);
                  return s > 0 && t_val > 0 && 1 - s - t_val > 0;
               }

               return (
                  distToSegment(pos, p1, p2) < t ||
                  distToSegment(pos, p2, p3) < t ||
                  distToSegment(pos, p3, p1) < t
               );
            } else if (shape.type === "oval") {
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);
               const radius = Math.min(w, h) / 2;
               let x = shape.x;
               let y = shape.y;
               if (shape.w < 0) x += shape.w;
               if (shape.h < 0) y += shape.h;

               let dist = 0;
               if (w > h) {
                  const segmentStart = { x: x + radius, y: y + h / 2 };
                  const segmentEnd = { x: x + w - radius, y: y + h / 2 };
                  dist = distToSegment(pos, segmentStart, segmentEnd);
               } else {
                  const segmentStart = { x: x + w / 2, y: y + radius };
                  const segmentEnd = { x: x + w / 2, y: y + h - radius };
                  dist = distToSegment(pos, segmentStart, segmentEnd);
               }
               return dist <= radius + (isFilled ? 0 : t);
            } else if (shape.type === "rhombus") {
               // Approximate as polygon for hit test
               const skew = Math.abs(shape.w) * 0.1;
               const x = shape.x;
               const y = shape.y;
               const w = shape.w;
               const h = shape.h;

               const p1 = { x: x + skew, y: y };
               const p2 = { x: x + w, y: y };
               const p3 = { x: x + w - skew, y: y + h };
               const p4 = { x: x, y: y + h };

               const poly = [p1, p2, p3, p4];

               // For rhombus, we can check distance to segments if not filled
               if (!isFilled) {
                  return (
                     distToSegment(pos, p1, p2) < t ||
                     distToSegment(pos, p2, p3) < t ||
                     distToSegment(pos, p3, p4) < t ||
                     distToSegment(pos, p4, p1) < t
                  );
               }

               let inside = false;
               for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                  const xi = poly[i].x,
                     yi = poly[i].y;
                  const xj = poly[j].x,
                     yj = poly[j].y;
                  const intersect =
                     yi > pos.y !== yj > pos.y &&
                     pos.x < ((xj - xi) * (pos.y - yi)) / (yj - yi) + xi;
                  if (intersect) inside = !inside;
               }
               return inside;
            } else if (shape.type === "diamond") {
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);
               const val = Math.abs(pos.x - cx) / (w / 2) + Math.abs(pos.y - cy) / (h / 2);
               if (isFilled) return val <= 1;
               // Approximate stroke check for diamond
               return val <= 1 && val >= 1 - t / Math.min(w, h); // Not perfect stroke check but closer
            } else if (shape.type === "text") {
               const fontWeight = shape.isBold !== false ? "bold" : "normal";
               ctx.font = `${fontWeight} ${shape.size}px 'Caveat', cursive`;
               const lines = shape.text.split("\n");
               let maxWidth = 0;
               lines.forEach(line => {
                   const m = ctx.measureText(line);
                   maxWidth = Math.max(maxWidth, m.width);
               });
               const totalHeight = lines.length * shape.size;
               return (
                  pos.x >= shape.x &&
                  pos.x <= shape.x + maxWidth &&
                  pos.y >= shape.y &&
                  pos.y <= shape.y + totalHeight
               );
            } else if (shape.type === "pencil" || shape.type === "pencil-arrow") {
               if (!shape.points || shape.points.length < 2) return false;
               // Check each segment
               for (let i = 0; i < shape.points.length - 1; i++) {
                  if (distToSegment(pos, shape.points[i], shape.points[i + 1]) < t) return true;
               }
               return false;
            } else if (shape.type === "line") {
               return distToSegment(pos, shape.start, shape.end) < t;
            } else if (shape.type === "arrow") {
               const cp = shape.control || {
                  x: (shape.start.x + shape.end.x) / 2,
                  y: (shape.start.y + shape.end.y) / 2,
               };

               const steps = 20;
               let prevSearchP = shape.start;
               for (let i = 1; i <= steps; i++) {
                  const tVal = i / steps;
                  const mt = 1 - tVal;
                  const curSearchP = {
                     x: mt * mt * shape.start.x + 2 * mt * tVal * cp.x + tVal * tVal * shape.end.x,
                     y: mt * mt * shape.start.y + 2 * mt * tVal * cp.y + tVal * tVal * shape.end.y,
                  };

                  if (distToSegment(pos, prevSearchP, curSearchP) < t) {
                     return true;
                  }
                  prevSearchP = curSearchP;
               }
               return false;
            } else if (shape.type === "image") {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);
               return pos.x > x && pos.x < x + w && pos.y > y && pos.y < y + h;
            }
            return false;
         }

         function dist(p1, p2) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y);
         }

         function rotatePoint(point, center, angle) {
            if (!angle) return point;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const dx = point.x - center.x;
            const dy = point.y - center.y;
            return {
               x: center.x + dx * cos - dy * sin,
               y: center.y + dx * sin + dy * cos,
            };
         }

         function getRotatedBoundingBox(shape) {
            const b = getBoundingBox(shape);
            if (!shape.angle) return b;

            const cx = b.x + b.w / 2;
            const cy = b.y + b.h / 2;
            
            const p1 = rotatePoint({ x: b.x, y: b.y }, { x: cx, y: cy }, shape.angle);
            const p2 = rotatePoint({ x: b.x + b.w, y: b.y }, { x: cx, y: cy }, shape.angle);
            const p3 = rotatePoint({ x: b.x + b.w, y: b.y + b.h }, { x: cx, y: cy }, shape.angle);
            const p4 = rotatePoint({ x: b.x, y: b.y + b.h }, { x: cx, y: cy }, shape.angle);

            const xs = [p1.x, p2.x, p3.x, p4.x];
            const ys = [p1.y, p2.y, p3.y, p4.y];

            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);

            return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
         }

         function distToSegment(p, v, w) {
            const l2 = (w.x - v.x) ** 2 + (w.y - v.y) ** 2;
            if (l2 === 0) return dist(p, v);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
         }

         function getBoundingBox(shape) {
            if (shape.points) {
               let mx = Infinity,
                  my = Infinity,
                  Mx = -Infinity,
                  My = -Infinity;
               shape.points.forEach((p) => {
                  mx = Math.min(mx, p.x);
                  my = Math.min(my, p.y);
                  Mx = Math.max(Mx, p.x);
                  My = Math.max(My, p.y);
               });
               return { x: mx, y: my, w: Mx - mx, h: My - my };
            }
            if (shape.type === "line" || shape.type === "arrow") {
               const mx = Math.min(shape.start.x, shape.end.x);
               const my = Math.min(shape.start.y, shape.end.y);
               const Mx = Math.max(shape.start.x, shape.end.x);
               const My = Math.max(shape.start.y, shape.end.y);
               return { x: mx, y: my, w: Mx - mx, h: My - my };
            }
            if (shape.type === "text") {
               ctx.save();
               ctx.setTransform(1, 0, 0, 1, 0, 0); // Measure in unscaled pixels for accuracy
               const fontWeight = shape.isBold !== false ? "bold" : "normal";
               ctx.font = `${fontWeight} ${shape.size}px 'Caveat', cursive`;
               // const m = ctx.measureText(shape.text);
               const lines = shape.text.split('\n');
               let maxWidth = 0;
               lines.forEach(line => {
                   const m = ctx.measureText(line);
                   maxWidth = Math.max(maxWidth, m.width);
               });
               const totalHeight = lines.length * shape.size;
               ctx.restore();
               return { x: shape.x, y: shape.y, w: maxWidth, h: totalHeight };
            }
            // Normalize rect-like shapes to have positive w/h for alignment logic
            const x = Math.min(shape.x, shape.x + shape.w);
            const y = Math.min(shape.y, shape.y + shape.h);
            const w = Math.abs(shape.w);
            const h = Math.abs(shape.h);
            return { x, y, w, h };
         }

         // --- Tool & UI Functions ---

         function updateCursor() {
            if (currentTool === "select") {
               canvas.style.cursor = "default";
            } else if (currentTool === "eraser") {
               canvas.style.cursor = "cell";
            } else if (currentTool === "pencil") {
               // Custom pencil cursor
               const pencilSvg = `
                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                     <g transform="rotate(90 12 12) translate(2 2) scale(0.8) translate(-2 -2)">
                        <!-- White outline for better visibility -->
                        <path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z" stroke="white" stroke-width="5" />
                        <path d="m15 5 4 4" stroke="white" stroke-width="5" />
                        <!-- Actual icon -->
                        <path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"/>
                        <path d="m15 5 4 4"/>
                     </g>
                  </svg>
               `;
               const cursorUrl = "data:image/svg+xml;base64," + btoa(pencilSvg);
               canvas.style.cursor = `url('${cursorUrl}') 2 2, crosshair`;
            } else {
               canvas.style.cursor = "crosshair";
            }
         }

         function setTool(tool, keepSelection = false) {
            // Hide shape recognition panel when switching tools
            hideShapeRecognitionPanel();

            currentTool = tool;

            // Handle tool lock visibility and state
            const lockBtn = document.getElementById("tool-lock-btn");
            if (lockBtn) {
               const lockableTools = [
                  "rect",
                  "circle",
                  "triangle",
                  "oval",
                  "rhombus",
                  "diamond",
                  "line",
                  "arrow",
                  "text",
               ];

               if (lockableTools.includes(tool)) {
                  lockBtn.style.display = "flex";
                  // Reset lock state when switching TO a tool (default: unlocked)
                  // Unless we are just refreshing the current tool (which shouldn't happen much via setTool directly for new selection)
                  isToolLocked = false;
                  lockBtn.classList.remove("locked");
                  lockBtn.innerHTML = '<i data-lucide="lock-open"></i>';
                  lucide.createIcons();
               } else {
                  lockBtn.style.display = "none";
                  isToolLocked = false;
               }
            }
            document.querySelectorAll(".tool-btn").forEach((btn) => btn.classList.remove("active"));
            document
               .querySelectorAll(".shape-dropdown-item")
               .forEach((btn) => btn.classList.remove("active"));

            const toolMap = {
               select: "btn-select",
               pencil: "btn-pencil",
               "pencil-arrow": "btn-pencil-arrow",
               laser: "btn-laser",
               eraser: "btn-eraser",
               line: "btn-line",
               arrow: "btn-arrow",
               text: "btn-text",
               rect: "btn-rect",
               circle: "btn-circle",
               triangle: "btn-triangle",
               oval: "btn-oval",
               rhombus: "btn-rhombus",
               diamond: "btn-diamond",
            };

            const btnId = toolMap[tool];
            if (btnId) {
               const btn = document.getElementById(btnId);
               if (btn) btn.classList.add("active");
            }

            // Also highlight the more-shapes button if a dropdown shape is selected
            if (tool === "oval" || tool === "rhombus" || tool === "diamond") {
               const moreBtn = document.getElementById("btn-more-shapes");
               if (moreBtn) moreBtn.classList.add("active");
            }

            updateCursor();

            if (!keepSelection) clearSelection();
            currentShape = null;
            render();
         }

         function toggleToolLock() {
            isToolLocked = !isToolLocked;
            const btn = document.getElementById("tool-lock-btn");
            if (btn) {
               if (isToolLocked) {
                  btn.classList.add("locked");
                  btn.innerHTML = '<i data-lucide="lock"></i>';
                  showToast("Tool Locked");
               } else {
                  btn.classList.remove("locked");
                  btn.innerHTML = '<i data-lucide="lock-open"></i>';
                  showToast("Tool Unlocked");
               }
               lucide.createIcons();
            }
         }

         function toggleBold() {
            isBold = !isBold;
            const btn = document.getElementById("ft-btn-bold");
            if (btn) {
               if (isBold) btn.classList.add("active");
               else btn.classList.remove("active");
            }

            if (selectedIndices.size > 0) {
               selectedIndices.forEach((idx) => {
                  if (shapes[idx]) {
                     shapes[idx].isBold = isBold;
                  }
               });
               saveHistory();
               render();
            }
            showToast(isBold ? "Bold Enabled" : "Bold Disabled");
         }

         function toggleShapeDropdown() {
            const menu = document.getElementById("shape-dropdown-menu");
            if (menu) {
               menu.classList.toggle("visible");
            }
         }

         function hideShapeDropdown() {
            const menu = document.getElementById("shape-dropdown-menu");
            if (menu) {
               menu.classList.remove("visible");
            }
         }

         // Close dropdown when clicking elsewhere
         document.addEventListener("click", (e) => {
            const dropdown = document.querySelector(".shape-dropdown");
            if (dropdown && !dropdown.contains(e.target)) {
               hideShapeDropdown();
            }
         });

         function checkAndSetPencilIfEmpty() {
            // If canvas is completely empty, switch to Pencil tool
            if (shapes.length === 0) {
               setTool("pencil");
            }
         }

         function setCurrentStrokeColor(color) {
            setColor(color, "stroke");

            // Auto-apply corresponding fill color from palette
            const fillMap = {
               "#000000": "#e5e7eb", // Black -> Light Gray
               "#ef4444": "#fee2e2", // Red -> Light Red
               "#3b82f6": "#dbeafe", // Blue -> Light Blue
               "#22c55e": "#dcfce7", // Green -> Light Green
            };

            if (fillMap[color]) {
               setColor(fillMap[color], "fill", true, true);
            }
         }

         function setCurrentFillColor(color) {
            if (selectedIndices.size > 0) {
               selectedIndices.forEach((idx) => {
                  const shape = shapes[idx];
                  // If transparent, reset memory (allow auto-change later). 
                  // If color, set memory (block auto-change).
                  shape.hasManualFillColor = (color !== "transparent");
               });
            }
            setColor(color, "fill");
         }

         function setColor(color, type, silent = false, preserveManualFill = false) {
            if (selectedIndices.size > 0) {
               // Apply to selected shapes ONLY, do not change defaults
               selectedIndices.forEach((idx) => {
                  const shape = shapes[idx];
                  if (type === "fill") {
                     if (preserveManualFill && shape.hasManualFillColor) {
                        return;
                     }
                     // Constraint: prevent invisible shapes
                     if (color === "transparent" && shape.color === "transparent") {
                        return; // Skip this shape
                     }
                     shape.fillColor = color;

                     // Auto-toggle text color for shapes with inner text
                     if (
                        shape.type === "rect" ||
                        shape.type === "circle" ||
                        shape.type === "triangle" ||
                        shape.type === "oval" ||
                        shape.type === "rhombus" ||
                        shape.type === "diamond"
                     ) {
                        if (color === "transparent") {
                           // Set text color to black when fill is transparent
                           shape.innerTextColor = "#000000";
                        } else {
                           // Determine if color is light or dark
                           const isLight = isColorLight(color);
                           shape.innerTextColor = isLight ? "#000000" : "#ffffff";
                        }
                     }
                  } else {
                     let colorToApply = color;
                     // Tweak: Treat transparent as white for Text objects
                     if (shape.type === "text" && color === "transparent") {
                        colorToApply = "#ffffff";
                     }

                     if (colorToApply === "transparent" && shape.fillColor === "transparent") {
                        return; // Skip
                     }
                     shape.color = colorToApply;
                  }
               });
               if (!silent) {
                  showToast(
                     "Applied " + (type === "fill" ? "Fill" : "Outline") + " color to selection",
                  );
               }
               saveHistory();
               render();
            } else {
               // No selection: update default colors for new shapes

               if (type === "fill") {
                  if (color === "transparent" && currentColor === "transparent") {
                     showToast("At least one color must be visible");
                     return;
                  }
                  currentFillColor = color;
                  showToast("Default Fill color set to " + color);
               } else {
                  if (color === "transparent" && currentFillColor === "transparent") {
                     showToast("At least one color must be visible");
                     return;
                  }
                  currentColor = color;
                  showToast("Default Stroke color set to " + color);
               }
               // updateColorUI(); // UI update is less relevant with direct buttons, but maybe highlights?
               // We can add highlighting logic later if needed.
            }
         }

         function isColorLight(color) {
            if (color === "transparent") return false;

            let r, g, b;
            if (color.startsWith("#")) {
               r = parseInt(color.slice(1, 3), 16);
               g = parseInt(color.slice(3, 5), 16);
               b = parseInt(color.slice(5, 7), 16);
            } else if (color.startsWith("rgb")) {
               const matches = color.match(/\d+/g);
               r = parseInt(matches[0]);
               g = parseInt(matches[1]);
               b = parseInt(matches[2]);
            } else {
               return false;
            }

            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.5;
         }

         function updateColorUI() {
            // Deprecated or can be used to highlight active color in palette
         }

         function showContextMenu(x, y) {
            const menu = document.getElementById("context-menu");

            // Show off-screen/invisible first to measure dimensions
            menu.style.visibility = "hidden";
            menu.classList.remove("hidden");

            const width = menu.offsetWidth;
            const height = menu.offsetHeight;
            const winWidth = window.innerWidth;
            const winHeight = window.innerHeight;

            // Adjust position if it goes out of bounds
            if (x + width > winWidth) {
               x = winWidth - width - 10;
            }
            if (y + height > winHeight) {
               y = winHeight - height - 10;
            }

            // Ensure positive coordinates (don't go off top/left)
            x = Math.max(10, x);
            y = Math.max(10, y);

            menu.style.left = x + "px";
            menu.style.top = y + "px";
            menu.style.visibility = "visible";
         }

         function hideContextMenu() {
            document.getElementById("context-menu").classList.add("hidden");
         }

         window.addEventListener("contextmenu", (e) => {
            // Don't show context menu if right-clicked on toolbar or other UI elements
            if (e.target !== canvas && !canvas.contains(e.target)) {
               return;
            }

            const screenPos = getPointerPos(e);
            const pos = toWorld(screenPos.x, screenPos.y);

            // Check if we right-clicked on a shape
            let hitIndex = -1;
            for (let i = shapes.length - 1; i >= 0; i--) {
               // Use larger padding (10px) for right-click context menu to make it easier to click lines
               if (isPointInShape(pos, shapes[i], 10)) {
                  hitIndex = i;
                  break;
               }
            }

            // Fix for non-filled shapes:
            // If we didn't hit a shape directly (maybe because it's transparent),
            // but we are right-clicking inside a shape that is CURRENTLY SELECTED,
            // then we should consider it a hit on that shape.
            if (hitIndex === -1 && selectedIndices.size === 1) {
               const selectedIdx = Array.from(selectedIndices)[0];
               if (
                  selectedIdx < shapes.length &&
                  isPointInsideShapeBounds(pos, shapes[selectedIdx])
               ) {
                  hitIndex = selectedIdx;
               }
            }

            e.preventDefault();

            // Show/hide paste option based on whether we right-clicked on a shape
            const pasteItem = document.getElementById("paste-menu-item");
            const pasteSeparator = document.getElementById("paste-separator");
            const toDottedItem = document.getElementById("to-dotted-line-item");
            const toggleStartArrowItem = document.getElementById("toggle-start-arrow-item");
            const toggleEndArrowItem = document.getElementById("toggle-end-arrow-item");
            const arrowTogglesContainer = document.getElementById("arrow-toggles-container");
            const editingLayeringSeparator = document.getElementById("editing-layering-separator");
            const layeringActionsContainer = document.getElementById("layering-actions-container");
            const bringToFront = document.getElementById("bring-to-front-item");
            const sendToBack = document.getElementById("send-to-back-item");
            const layeringDeleteSeparator = document.getElementById("layering-delete-separator");
            const duplicateItem = document.getElementById("duplicate-item");
            const deleteItem = document.getElementById("delete-item");
            const shapeConversionSeparator = document.getElementById("shape-conversion-separator");
            const changeToRectangleItem = document.getElementById("change-to-rectangle-item");
            const changeToCircleItem = document.getElementById("change-to-circle-item");
            const changeToTriangleItem = document.getElementById("change-to-triangle-item");
            const changeToOvalItem = document.getElementById("change-to-oval-item");
            const changeToRhombusItem = document.getElementById("change-to-rhombus-item");
            const changeToDiamondItem = document.getElementById("change-to-diamond-item");

            if (hitIndex !== -1) {
               // Right-clicked on a shape - hide paste, show shape options
               pasteItem.style.display = "none";
               pasteSeparator.style.display = "none";
               const hitShape = shapes[hitIndex];
               // Only show 'Toggle Dotted Line' for non-text, non-image shapes
               if (toDottedItem) {
                  if (hitShape && hitShape.type !== "text" && hitShape.type !== "image") {
                     toDottedItem.style.display = "flex";
                  } else {
                     toDottedItem.style.display = "none";
                  }
               }
               // Show arrow toggle options for line, arrow, pencil, and pencil-arrow types
               if (arrowTogglesContainer) {
                  if (
                     hitShape &&
                     (hitShape.type === "line" ||
                        hitShape.type === "arrow" ||
                        hitShape.type === "pencil" ||
                        hitShape.type === "pencil-arrow")
                  ) {
                     arrowTogglesContainer.style.display = "block";
                     const startArrowIndicator = document.getElementById("start-arrow-indicator");
                     const endArrowIndicator = document.getElementById("end-arrow-indicator");
                     if (startArrowIndicator) {
                        startArrowIndicator.style.display = hitShape.hasStartArrow ? "block" : "none";
                     }
                     if (endArrowIndicator) {
                        const showEndArrow =
                           hitShape.hasEndArrow !== undefined
                              ? hitShape.hasEndArrow
                              : hitShape.type === "arrow" || hitShape.type === "pencil-arrow";
                        endArrowIndicator.style.display = showEndArrow ? "block" : "none";
                     }
                  } else {
                     arrowTogglesContainer.style.display = "none";
                  }
               }
               if (editingLayeringSeparator) editingLayeringSeparator.style.display = "block";
               if (layeringActionsContainer) layeringActionsContainer.style.display = "block";
               if (layeringDeleteSeparator) layeringDeleteSeparator.style.display = "block";
               if (duplicateItem) duplicateItem.style.display = "flex";
               if (deleteItem) deleteItem.style.display = "flex";

               // Only show shape conversion for allowed types
               const convertibleTypes = [
                  "rect",
                  "circle",
                  "triangle",
                  "oval",
                  "rhombus",
                  "diamond",
               ];
               if (hitShape && convertibleTypes.includes(hitShape.type)) {
                  if (shapeConversionSeparator) shapeConversionSeparator.style.display = "block";
                  if (changeToRectangleItem) changeToRectangleItem.style.display = "flex";
                  if (changeToCircleItem) changeToCircleItem.style.display = "flex";
                  if (changeToTriangleItem) changeToTriangleItem.style.display = "flex";
                  if (changeToOvalItem) changeToOvalItem.style.display = "flex";
                  if (changeToRhombusItem) changeToRhombusItem.style.display = "flex";
                  if (changeToDiamondItem) changeToDiamondItem.style.display = "flex";
               } else {
                  if (shapeConversionSeparator) shapeConversionSeparator.style.display = "none";
                  if (changeToRectangleItem) changeToRectangleItem.style.display = "none";
                  if (changeToCircleItem) changeToCircleItem.style.display = "none";
                  if (changeToTriangleItem) changeToTriangleItem.style.display = "none";
                  if (changeToOvalItem) changeToOvalItem.style.display = "none";
                  if (changeToRhombusItem) changeToRhombusItem.style.display = "none";
                  if (changeToDiamondItem) changeToDiamondItem.style.display = "none";
               }

               if (!selectedIndices.has(hitIndex)) {
                  clearSelection();
                  selectedIndices.add(hitIndex);
                  render();
               }
               // Switch to select tool when right-clicking on a shape
               setTool("select", true);
            } else {
               // Right-clicked on empty canvas - show paste, hide shape options
               pasteItem.style.display = "flex";
               pasteSeparator.style.display = "block";
               if (toDottedItem) toDottedItem.style.display = "none";
               if (arrowTogglesContainer) arrowTogglesContainer.style.display = "none";
               if (editingLayeringSeparator) editingLayeringSeparator.style.display = "none";
               if (layeringActionsContainer) layeringActionsContainer.style.display = "none";
               if (layeringDeleteSeparator) layeringDeleteSeparator.style.display = "none";
               if (deleteItem) deleteItem.style.display = "none";
               if (shapeConversionSeparator) shapeConversionSeparator.style.display = "none";
               if (changeToRectangleItem) changeToRectangleItem.style.display = "none";
               if (changeToCircleItem) changeToCircleItem.style.display = "none";
               if (changeToTriangleItem) changeToTriangleItem.style.display = "none";
               if (changeToOvalItem) changeToOvalItem.style.display = "none";
               if (changeToRhombusItem) changeToRhombusItem.style.display = "none";
               if (changeToDiamondItem) changeToDiamondItem.style.display = "none";
            }

            showContextMenu(e.clientX, e.clientY);
         });

         window.addEventListener("click", () => {
            hideContextMenu();
         });

         function setCustomColor(color) {
            setColor(color);
            const swatch = document.createElement("button");
            swatch.className = "color-swatch w-5 h-5 rounded-full";
            swatch.style.backgroundColor = color;
            swatch.dataset.color = color;
            swatch.onclick = function () {
               setColor(color, this);
            };
            // Optionally add the custom color to the palette
         }

         function setLineWidth(width) {
            currentWidth = parseInt(width);
            const widthValDesk = document.getElementById("width-val-desk");
            const widthValMob = document.getElementById("width-val-mob");
            const widthSliderDesk = document.getElementById("width-slider-desk");
            const widthSliderMob = document.getElementById("width-slider-mob");

            if (widthValDesk) widthValDesk.textContent = currentWidth;
            if (widthValMob) widthValMob.textContent = currentWidth;
            if (widthSliderDesk) widthSliderDesk.value = currentWidth;
            if (widthSliderMob) widthSliderMob.value = currentWidth;
         }

         function duplicateSelected() {
            if (selectedIndices.size === 0) return;

            const duplicatedShapes = [];
            const offset = 20 / camera.scale;

            selectedIndices.forEach((idx) => {
               const original = shapes[idx];
               const duplicate = JSON.parse(
                  JSON.stringify(original, (key, value) => {
                     if (key === "image") return undefined;
                     return value;
                  }),
               );

               duplicate.id = generateId();

               // Apply offset
               if (duplicate.points) {
                  duplicate.points = duplicate.points.map((p) => ({
                     x: p.x + offset,
                     y: p.y + offset,
                  }));
               } else if (duplicate.start && duplicate.end) {
                  duplicate.start.x += offset;
                  duplicate.start.y += offset;
                  duplicate.end.x += offset;
                  duplicate.end.y += offset;
                  if (duplicate.control) {
                     duplicate.control.x += offset;
                     duplicate.control.y += offset;
                  }
               } else {
                  duplicate.x += offset;
                  duplicate.y += offset;
               }

               if (original.type === "image" && original.src) {
                  const img = new Image();
                  img.src = original.src;
                  duplicate.image = img;
               }

               duplicatedShapes.push(duplicate);
            });

            shapes.push(...duplicatedShapes);

            clearSelection();
            for (let i = shapes.length - duplicatedShapes.length; i < shapes.length; i++) {
               addToSelection(i);
            }

            saveHistory();
            render();
            showToast("Duplicated");
         }

         function deleteSelected() {
            if (selectedIndices.size === 0) return;

            const sortedIndices = Array.from(selectedIndices).sort((a, b) => b - a);
            sortedIndices.forEach((idx) => {
               shapes.splice(idx, 1);
            });

            clearSelection();
            updateConnections();
            saveHistory();
            render();
            showToast("Deleted");
            // Switch to Select tool instead of Pencil when deleting
            setTool("select");
         }

         function toggleDottedLine() {
            if (selectedIndices.size === 0) return;

            selectedIndices.forEach((idx) => {
               if (shapes[idx]) {
                  shapes[idx].isDotted = !shapes[idx].isDotted;
               }
            });

            saveHistory();
            render();
            showToast(shapes[Array.from(selectedIndices)[0]].isDotted ? "To Dotted" : "To Solid");
         }

         function toggleStartArrow() {
            if (selectedIndices.size === 0) return;

            selectedIndices.forEach((idx) => {
               const shape = shapes[idx];
               if (
                  shape &&
                  (shape.type === "line" ||
                     shape.type === "arrow" ||
                     shape.type === "pencil" ||
                     shape.type === "pencil-arrow")
               ) {
                  if (shape.hasStartArrow === undefined) {
                     shape.hasStartArrow = false;
                  }
                  shape.hasStartArrow = !shape.hasStartArrow;
               }
            });

            saveHistory();
            render();
            showToast(
               shapes[Array.from(selectedIndices)[0]].hasStartArrow
                  ? "Start Arrow Added"
                  : "Start Arrow Removed",
            );
         }

         function toggleEndArrow() {
            if (selectedIndices.size === 0) return;

            selectedIndices.forEach((idx) => {
               const shape = shapes[idx];
               if (
                  shape &&
                  (shape.type === "line" ||
                     shape.type === "arrow" ||
                     shape.type === "pencil" ||
                     shape.type === "pencil-arrow")
               ) {
                  if (shape.hasEndArrow === undefined) {
                     if (shape.type === "pencil-arrow" || shape.type === "arrow") {
                        shape.hasEndArrow = true;
                     } else {
                        shape.hasEndArrow = false;
                     }
                  }
                  shape.hasEndArrow = !shape.hasEndArrow;
               }
            });

            saveHistory();
            render();
            showToast(
               shapes[Array.from(selectedIndices)[0]].hasEndArrow
                  ? "End Arrow Added"
                  : "End Arrow Removed",
            );
         }

         function clearBoard() {
            shapes = [];
            clearSelection();
            currentShape = null;
            camera.x = 0;
            camera.y = 0;
            camera.scale = 1;
            saveHistory();
            render();
            showToast("Board Cleared");
            checkAndSetPencilIfEmpty();
         }

         function resetView() {
            camera.x = 0;
            camera.y = 0;
            camera.scale = 1;
            render();
            showToast("View Reset");
         }

         function downloadImage() {
            const link = document.createElement("a");
            link.download = "scribble-" + Date.now() + ".png";
            link.href = canvas.toDataURL();
            link.click();
            showToast("Image Downloaded");
         }

         function showToast(message) {
            if (toastEl) {
               toastEl.textContent = message;
               toastEl.classList.remove("opacity-0");
               setTimeout(() => {
                  toastEl.classList.add("opacity-0");
               }, 2000);
            }
         }

         // --- Shape Recognition Undo Panel Functions ---

         function showShapeRecognitionPanel(originalShape, convertedIndex) {
            const panel = document.getElementById("shape-recognition-panel");
            if (!panel) return;

            // Store the original shape and converted index
            originalPencilShape = JSON.parse(JSON.stringify(originalShape)); // Deep copy
            convertedShapeIndex = convertedIndex;

            // Clear any existing timer
            if (shapeRecognitionPanelTimer) {
               clearTimeout(shapeRecognitionPanelTimer);
               shapeRecognitionPanelTimer = null;
            }

            // Show the panel with animation
            panel.classList.remove("hidden");
            setTimeout(() => {
               panel.style.opacity = "1";
               panel.style.transform = "translate(-50%, 0)";
            }, 10);

            // Auto-hide after 4 seconds
            shapeRecognitionPanelTimer = setTimeout(() => {
               hideShapeRecognitionPanel();
            }, 4000);
         }

         function hideShapeRecognitionPanel() {
            const panel = document.getElementById("shape-recognition-panel");
            if (!panel) return;

            // Clear timer
            if (shapeRecognitionPanelTimer) {
               clearTimeout(shapeRecognitionPanelTimer);
               shapeRecognitionPanelTimer = null;
            }

            // Hide with animation
            panel.style.opacity = "0";
            panel.style.transform = "translate(-50%, -10px)";
            setTimeout(() => {
               panel.classList.add("hidden");
               originalPencilShape = null;
               convertedShapeIndex = -1;
            }, 300);
         }

         function undoShapeRecognition() {
            if (originalPencilShape === null || convertedShapeIndex === -1) {
               hideShapeRecognitionPanel();
               return;
            }

            // Remove the converted shape
            if (shapes[convertedShapeIndex]) {
               shapes.splice(convertedShapeIndex, 1);
            }

            // Restore the original pencil shape
            shapes.push(originalPencilShape);
            clearSelection();
            addToSelection(shapes.length - 1);
            saveHistory();
            render();

            hideShapeRecognitionPanel();
            showToast("Reverted to original drawing");
         }

         function convertToShape(shapeType) {
            if (originalPencilShape === null || convertedShapeIndex === -1) {
               hideShapeRecognitionPanel();
               return;
            }

            // Remove the current converted shape
            if (shapes[convertedShapeIndex]) {
               shapes.splice(convertedShapeIndex, 1);
            }

            // Convert to the requested shape type
            const detectedShape = { type: shapeType };
            const newShape = convertPencilToShape(originalPencilShape, detectedShape);
            shapes.push(newShape);

            // Update the converted shape index
            convertedShapeIndex = shapes.length - 1;

            clearSelection();
            addToSelection(convertedShapeIndex);
            saveHistory();
            render();

            const shapeNameMap = {
               rectangle: "Rectangle",
               circle: "Circle",
               triangle: "Triangle",
            };
            const shapeName = shapeNameMap[shapeType] || shapeType;
            showToast(`Converted to ${shapeName}`);

            // Keep panel open for further conversions
            // Reset the timer
            if (shapeRecognitionPanelTimer) {
               clearTimeout(shapeRecognitionPanelTimer);
            }
            shapeRecognitionPanelTimer = setTimeout(() => {
               hideShapeRecognitionPanel();
            }, 4000);
         }

         // Change currently selected shapes to a specific basic shape type
         function changeSelectedShapesType(targetType) {
            if (!selectedIndices || selectedIndices.size === 0) return;

            selectedIndices.forEach((idx) => {
               const shape = shapes[idx];
               if (!shape) return;

               // Only convert compatible shapes (basic shapes and pencil strokes)
               if (
                  shape.type === "rect" ||
                  shape.type === "circle" ||
                  shape.type === "triangle" ||
                  shape.type === "oval" ||
                  shape.type === "rhombus" ||
                  shape.type === "diamond"
               ) {
                  shape.type = targetType;
               } else if (
                  shape.type === "pencil" &&
                  Array.isArray(shape.points) &&
                  shape.points.length > 1
               ) {
                  // Reuse pencil-to-shape conversion to create a new shape from the stroke
                  const detectedShape = {
                     type: targetType === "rect" ? "rectangle" : targetType,
                  };
                  const newShape = convertPencilToShape(shape, detectedShape);
                  // Preserve some visual properties
                  newShape.fillColor = shape.fillColor || "transparent";
                  newShape.innerText = shape.innerText || "";
                  newShape.innerTextColor = shape.innerTextColor || "#000000";
                  newShape.innerTextSize = shape.innerTextSize || 20;
                  shapes[idx] = newShape;
               }
            });

            saveHistory();
            render();
         }

         // --- Image Upload Logic ---

         function handleImageFile(file) {
            if (!file || !file.type.startsWith("image/")) return;

            const reader = new FileReader();
            reader.onload = (e) => {
               const img = new Image();
               img.onload = () => {
                  // Calculate dimensions to fit in view
                  let w = img.width;
                  let h = img.height;
                  const maxDim = 400;
                  if (w > maxDim || h > maxDim) {
                     const ratio = Math.min(maxDim / w, maxDim / h);
                     w *= ratio;
                     h *= ratio;
                  }

                  const worldCenter = toWorld(canvas.width / 2, canvas.height / 2);
                  const newShape = {
                     id: generateId(),
                     type: "image",
                     x: worldCenter.x - w / 2,
                     y: worldCenter.y - h / 2,
                     w: w,
                     h: h,
                     image: img,
                     src: e.target.result, // Store source for history/serialization
                     aspectRatio: w / h, // Store aspect ratio for resizing
                  };
                  shapes.push(newShape);
                  clearSelection();
                  addToSelection(shapes.length - 1);
                  setTool("select", true);
                  saveHistory();
                  render();
                  showToast("Image Added");
               };
               img.src = e.target.result;
            };
            reader.readAsDataURL(file);
         }

         // Paste from clipboard (context menu)
         function pasteFromClipboard() {
            // Access clipboard API
            navigator.clipboard
               .read()
               .then((items) => {
                  for (const item of items) {
                     if (item.types.some((type) => type.startsWith("image/"))) {
                        item
                           .getType(item.types.find((t) => t.startsWith("image/")))
                           .then((blob) => {
                              handleImageFile(blob);
                           });
                        return;
                     }
                  }
                  showToast("No image found in clipboard");
               })
               .catch((err) => {
                  showToast("Clipboard access denied or no image in clipboard");
                  console.error("Clipboard error:", err);
               });
         }

         // Drag and Drop
         window.addEventListener("dragover", (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
         });

         window.addEventListener("drop", (e) => {
            e.preventDefault();
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
               handleImageFile(e.dataTransfer.files[0]);
            }
         });

         // Paste
         window.addEventListener("paste", (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (const item of items) {
               if (item.type.indexOf("image") !== -1) {
                  const file = item.getAsFile();
                  handleImageFile(file);
               }
            }
         });

         // --- Persistence ---

         const STORAGE_KEY = "scribble_canvas_v1";

         function saveToLocalStorage() {
            const data = {
               shapes: shapes,
               camera: camera,
            };
            try {
               const json = JSON.stringify(data, (key, value) => {
                  if (key === "image") return undefined; // Don't stringify Image objects
                  return value;
               });
               localStorage.setItem(STORAGE_KEY, json);
            } catch (e) {
               console.error("Failed to save to local storage", e);
            }
         }

         function loadFromLocalStorage() {
            try {
               const json = localStorage.getItem(STORAGE_KEY);
               if (!json) return false;

               const data = JSON.parse(json);
               if (data.shapes) {
                  // Re-hydrate images
                  shapes = data.shapes.map((s) => {
                     if (s.type === "image" && s.src) {
                        const img = new Image();
                        img.src = s.src;
                        return { ...s, image: img };
                     }
                     return s;
                  });
               }
               if (data.camera) {
                  // Validate camera data
                  if (
                     typeof data.camera.x === "number" &&
                     typeof data.camera.y === "number" &&
                     typeof data.camera.scale === "number"
                  ) {
                     camera = data.camera;
                  }
               }
               return true;
            } catch (e) {
               console.error("Failed to load from local storage", e);
               return false;
            }
         }

         // --- History & Keys ---

         function saveHistory() {
            // For images, we need to handle the Image objects specially if we were to use localStorage
            // but for in-memory history, we can just store the shapes array (with references).
            // However, to make undo/redo work correctly with object references, we should clone.
            // Special handling for image property to keep it as an Image object.
            const s = JSON.stringify(shapes, (key, value) => {
               if (key === "image") return undefined; // Don't stringify the Image object
               return value;
            });

            if (historyStack.length > 0 && historyStack[historyStep] === s) return;

            if (historyStep < historyStack.length - 1) {
               historyStack = historyStack.slice(0, historyStep + 1);
            }

            historyStack.push(s);
            if (historyStack.length > MAX_HISTORY) historyStack.shift();
            else historyStep++;

            saveToLocalStorage();
         }

         function undo() {
            if (historyStep > 0) {
               historyStep--;
               const savedShapes = JSON.parse(historyStack[historyStep]);

               // Re-hydrate images
               shapes = savedShapes.map((s) => {
                  if (s.type === "image" && s.src) {
                     const img = new Image();
                     img.src = s.src;
                     return { ...s, image: img };
                  }
                  return s;
               });

               const validSelection = new Set();
               selectedIndices.forEach((idx) => {
                  if (idx < shapes.length) {
                     validSelection.add(idx);
                  }
               });
               selectedIndices = validSelection;
               selectionQueue = Array.from(validSelection);

               updateConnections();
               render();
               showToast("Undo");
               checkAndSetPencilIfEmpty();
            } else if (historyStep === 0) {
               historyStep = -1;
               shapes = [];
               clearSelection();
               render();
               showToast("Undo");
               checkAndSetPencilIfEmpty();
            }
         }

         // Helper function to check if a point is inside a shape's bounds (for double-click)
         // This ignores fill status and always checks the interior
         function isPointInsideShapeBounds(pos, shape) {
            if (shape.type === "rect") {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);
               return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
            } else if (shape.type === "circle") {
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               const rx = Math.abs(shape.w / 2);
               const ry = Math.abs(shape.h / 2);
               const normalizedX = (pos.x - cx) / rx;
               const normalizedY = (pos.y - cy) / ry;
               const distSq = normalizedX * normalizedX + normalizedY * normalizedY;
               return distSq <= 1.05; // Slightly larger for easier clicking
            } else if (shape.type === "triangle") {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);
               return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
            } else if (shape.type === "oval") {
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               const rx = Math.abs(shape.w / 2);
               const ry = Math.abs(shape.h / 2);
               const normalizedX = (pos.x - cx) / rx;
               const normalizedY = (pos.y - cy) / ry;
               const distSq = normalizedX * normalizedX + normalizedY * normalizedY;
               return distSq <= 1.05;
            } else if (shape.type === "rhombus" || shape.type === "diamond") {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);
               return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
            } else if (shape.type === "text") {
               const fontWeight = shape.isBold !== false ? "bold" : "normal";
               ctx.font = `${fontWeight} ${shape.size}px 'Caveat', cursive`;
               const lines = shape.text.split("\n");
               let maxWidth = 0;
               lines.forEach(line => {
                   const m = ctx.measureText(line);
                   maxWidth = Math.max(maxWidth, m.width);
               });
               const totalHeight = lines.length * shape.size;
               return (
                  pos.x >= shape.x &&
                  pos.x <= shape.x + maxWidth &&
                  pos.y >= shape.y &&
                  pos.y <= shape.y + totalHeight
               );
            }
            return false;
         }

         function onDoubleClick(e) {
            const screenPos = getPointerPos(e);
            const pos = toWorld(screenPos.x, screenPos.y);

            for (let i = shapes.length - 1; i >= 0; i--) {
               const shape = shapes[i];

               // For shapes that can have text inside, use bounds checking
               if (
                  shape.type === "rect" ||
                  shape.type === "circle" ||
                  shape.type === "triangle" ||
                  shape.type === "oval" ||
                  shape.type === "rhombus" ||
                  shape.type === "diamond"
               ) {
                  if (isPointInsideShapeBounds(pos, shape)) {
                     // Handle shape objects - add text inside them
                     // Calculate center position of the shape
                     const centerX = shape.x + shape.w / 2;
                     const centerY = shape.y + shape.h / 2;

                     // Check if shape already has text
                     const existingText = shape.innerText || "";
                     const textSize = shape.innerTextSize || currentWidth * 5 + 10;
                     const textColor = shape.innerTextColor || currentColor;

                     // Store reference to the shape being edited
                     const shapeIndex = i;

                     // Create text input at center of shape
                     createTextInputForShape(
                        centerX,
                        centerY,
                        existingText,
                        textSize,
                        textColor,
                        shapeIndex,
                     );
                     return;
                  }
               } else if (shape.type === "line" || shape.type === "arrow") {
                  if (isPointInShape(pos, shape, 10)) {
                     let centerX, centerY;
                     if (shape.type === "line") {
                        const t = 0.35;
                        centerX = shape.start.x + (shape.end.x - shape.start.x) * t;
                        centerY = shape.start.y + (shape.end.y - shape.start.y) * t;
                     } else {
                        // arrow
                        const t = 0.35;
                        const mt = 1 - t;
                        const cp = shape.control || {
                           x: (shape.start.x + shape.end.x) / 2,
                           y: (shape.start.y + shape.end.y) / 2,
                        };
                        centerX = mt * mt * shape.start.x + 2 * mt * t * cp.x + t * t * shape.end.x;
                        centerY = mt * mt * shape.start.y + 2 * mt * t * cp.y + t * t * shape.end.y;
                     }

                     const existingText = shape.innerText || "";
                     const textSize = shape.innerTextSize || currentWidth * 5 + 10;
                     const textColor = shape.innerTextColor || currentColor;

                     createTextInputForShape(
                        centerX,
                        centerY,
                        existingText,
                        textSize,
                        textColor,
                        i,
                     );
                     return;
                  }
               } else if (isPointInShape(pos, shape)) {
                  // For other shapes (text, lines, etc.), use normal hit detection
                  if (shape.type === "text") {
                     shapes.splice(i, 1);
                     clearSelection();
                     render();

                     createTextInput(shape.x, shape.y, shape.text, shape.size, shape.color, shape.isBold);
                     return;
                  }
               }
            }
         }

         document.addEventListener("keydown", (e) => {
            if (isTyping) return;

            const isCtrl = e.ctrlKey || e.metaKey;
            const isAlt = e.altKey;
            const k = e.key.toLowerCase();

            if (isCtrl && k === "z") {
               e.preventDefault();
               undo();
            } else if (isAlt && k === "n") {
               e.preventDefault();
               clearBoard();
            } else if (isCtrl && k === "a") {
               e.preventDefault();
               clearSelection();
               shapes.forEach((_, i) => addToSelection(i));
               setTool("select", true);
               render();
               showToast(`Selected ${shapes.length} object${shapes.length !== 1 ? "s" : ""}`);
            } else if (e.key === "Escape") {
               setTool("select");
               if (selectedIndices.size > 0) {
                  clearSelection();
                  render();
                  showToast("Selection Removed");
               } else {
                  resetView();
               }
               e.preventDefault();
            } else if (isCtrl && ["arrowup", "arrowright", "arrowdown", "arrowleft"].includes(k)) {
               e.preventDefault();
               const sideMap = {
                  arrowup: "top",
                  arrowright: "right",
                  arrowdown: "bottom",
                  arrowleft: "left",
               };
               createLinkedShapeOnSide(sideMap[k]);
            } else if (!isCtrl && ["arrowup", "arrowright", "arrowdown", "arrowleft"].includes(k)) {
               if (selectedIndices.size > 0 && !isTyping) {
                  e.preventDefault();
                  const step = e.shiftKey ? 10 : 1;
                  let dx = 0;
                  let dy = 0;
                  if (k === "arrowup") dy = -step;
                  else if (k === "arrowdown") dy = step;
                  else if (k === "arrowleft") dx = -step;
                  else if (k === "arrowright") dx = step;

                  selectedIndices.forEach((idx) => moveShape(shapes[idx], dx, dy));
                  updateConnections();
                  render();
               }
            } else if (
               !isCtrl &&
               !isAlt &&
               selectedIndices.size > 1 &&
               ["l", "r", "t", "b", "c", "v", "h", "e"].includes(k)
            ) {
               e.preventDefault();
               if (k === "l") alignSelected("left");
               else if (k === "r") alignSelected("right");
               else if (k === "t") alignSelected("top");
               else if (k === "b") alignSelected("bottom");
               else if (k === "h" || k === "e")
                  alignSelected("center-h"); // H or E for horizontal center
               else if (k === "c" || k === "v") alignSelected("middle-v"); // C or V for vertical center
               showToast("Aligned " + k.toUpperCase());
            } else if (isCtrl && k === "k") {
               e.preventDefault();
               setCurrentStrokeColor("#000000");
            } else if (isCtrl && k === "r") {
               e.preventDefault();
               setCurrentStrokeColor("#ef4444");
            } else if (isCtrl && k === "g") {
               e.preventDefault();
               setCurrentStrokeColor("#22c55e");
            } else if (isCtrl && k === "b") {
               e.preventDefault();
               setCurrentStrokeColor("#3b82f6");
            } else if (isCtrl && k === "d") {
               e.preventDefault();
               duplicateSelected();
            } else if (e.key === "Delete" || e.key === "Backspace") {
               deleteSelected();
            } else if (e.key === "[") setLineWidth(Math.max(1, currentWidth - 1));
            else if (e.key === "]") setLineWidth(Math.min(50, currentWidth + 1));
            // Single-letter tool shortcuts (only when Ctrl/Alt are not pressed)
            else if (!isCtrl && !isAlt && k === "s") setTool("select");
            else if (!isCtrl && !isAlt && k === "e") setTool("eraser");
            else if (!isCtrl && !isAlt && k === "p") setTool("pencil");
            else if (!isCtrl && !isAlt && k === "f") setTool("pencil-arrow");
            else if (!isCtrl && !isAlt && k === "z") setTool("laser");
            else if (!isCtrl && !isAlt && k === "l") setTool("line");
            else if (!isCtrl && !isAlt && k === "a") setTool("arrow");
            else if (!isCtrl && !isAlt && k === "r") setTool("rect");
            else if (!isCtrl && !isAlt && k === "t") setTool("text");
            else if (!isCtrl && !isAlt && k === "n") setTool("triangle");
            else if (!isCtrl && !isAlt && k === "c") setTool("circle");
         });

         canvas.addEventListener("mousedown", onMouseDown);
         canvas.addEventListener("mousemove", onMouseMove);
         window.addEventListener("mouseup", onMouseUp);
         canvas.addEventListener("touchstart", onMouseDown, { passive: false });
         canvas.addEventListener("touchmove", onMouseMove, { passive: false });
         window.addEventListener("touchend", onMouseUp);
         canvas.addEventListener("dblclick", onDoubleClick);

         // Double-tap detection for mobile/tablet
         let lastTapTime = 0;
         let lastTapPos = null;

         canvas.addEventListener("touchend", (e) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTapTime;
            const screenPos = getPointerPos(e);

            // Check for double tap (within 300ms and 20px radius)
            if (tapLength < 300 && tapLength > 0) {
               if (
                  lastTapPos &&
                  Math.hypot(screenPos.x - lastTapPos.x, screenPos.y - lastTapPos.y) < 20
               ) {
                  e.preventDefault();  // Prevent default zoom/selection behaviors
                  onDoubleClick(e);    // Trigger existing double-click logic
                  lastTapTime = 0;     // Reset to prevent triple-tap triggering immediately
                  return;
               }
            }

            lastTapTime = currentTime;
            lastTapPos = screenPos;
         });

         resizeCanvas();
         if (loadFromLocalStorage()) {
            // Explicitly load the font required for canvas text to ensure it's available
            // before the initial render. This prevents the "wrong font" issue.
            document.fonts.load("1em Caveat").then(() => {
               render();
            });
            // Save loaded state as initial history
            // We need to push the loaded state to history so undo works back to this point
            // But saveHistory() calls saveToLocalStorage() again, which is redundant but harmless here.
            saveHistory();
            //showToast("Restored previous session");
         } else {
            saveHistory();
         }

         // --- Menu Functions ---
         function toggleAppMenu() {
            const menu = document.getElementById("app-menu-dropdown");
            menu.classList.toggle("hidden");
            if (!menu.classList.contains("hidden")) {
               // Ensure icons are rendered
               if (typeof lucide !== "undefined") {
                  lucide.createIcons({ root: menu });
               }
            }
         }

         function closeAppMenu(e) {
            const menu = document.getElementById("app-menu-dropdown");
            const btn = document.getElementById("app-menu-btn");
            if (menu && btn && !menu.classList.contains("hidden")) {
               if (!menu.contains(e.target) && !btn.contains(e.target)) {
                  menu.classList.add("hidden");
               }
            }
         }
         window.addEventListener("mousedown", closeAppMenu);
         // Also close on touch start
         window.addEventListener("touchstart", closeAppMenu, { passive: true });

         function exportCanvas() {
            try {
               const backup = {
                  version: "1.0",
                  timestamp: Date.now(),
                  shapes: shapes,
                  camera: camera,
               };
               const data = JSON.stringify(backup);
               const blob = new Blob([data], { type: "application/json" });
               const url = URL.createObjectURL(blob);
               const a = document.createElement("a");
               a.href = url;
               a.download = `tuneboard-${new Date().toISOString().slice(0, 10)}.tboard`;
               document.body.appendChild(a);
               a.click();
               document.body.removeChild(a);
               URL.revokeObjectURL(url);
               showToast("Board exported successfully");
               toggleAppMenu();
            } catch (err) {
               console.error(err);
               showToast("Failed to export board");
            }
         }

         function importCanvas() {
            document.getElementById("import-file-input").click();
            toggleAppMenu();
         }

         function handleImportFile(file) {
            if (!file) return;
            
            // Basic extension check (optional, but requested format is .tboard)
            if (!file.name.endsWith(".tboard") && !file.name.endsWith(".json")) {
               // Allow .json as fallback just in case
               showToast("Please select a .tboard file");
               return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
               try {
                  const content = e.target.result;
                  const data = JSON.parse(content);
                  let newShapes = [];
                  let newCamera = null;

                  if (Array.isArray(data)) {
                     // Legacy/Simple format
                     newShapes = data;
                  } else if (data.shapes && Array.isArray(data.shapes)) {
                     // Structured format
                     newShapes = data.shapes;
                     if (data.camera) newCamera = data.camera;
                  } else {
                     throw new Error("Invalid file format");
                  }

                  // Restore images async
                  const imagePromises = newShapes.map((shape) => {
                     if (shape.type === "image" && shape.src) {
                        return new Promise((resolve) => {
                           const img = new Image();
                           img.onload = () => {
                              shape.image = img;
                              resolve();
                           };
                           img.onerror = () => {
                              console.warn("Failed to load image resource");
                              resolve();
                           };
                           img.src = shape.src;
                        });
                     }
                     return Promise.resolve();
                  });

                  Promise.all(imagePromises).then(() => {
                     shapes = newShapes;
                     if (newCamera) {
                        camera = newCamera;
                        // Validate camera values
                        if (isNaN(camera.x)) camera.x = 0;
                        if (isNaN(camera.y)) camera.y = 0;
                        if (isNaN(camera.scale)) camera.scale = 1;
                     }
                     clearSelection();
                     saveHistory();
                     render();
                     showToast("Board imported successfully");
                  });
               } catch (err) {
                  console.error(err);
                  showToast("Error importing file");
               }
               // Reset input
               document.getElementById("import-file-input").value = "";
            };
            reader.readAsText(file);
         }

         // Fix ReferenceError by exposing functions to window
         window.setTool = setTool;
         window.setLineWidth = setLineWidth;
         window.undo = undo;
         window.duplicateSelected = duplicateSelected;
         window.deleteSelected = deleteSelected;
         window.clearBoard = clearBoard;
         window.downloadImage = downloadImage;
         window.alignSelected = alignSelected;
         window.resetView = resetView;
         window.handleImageFile = handleImageFile;
         window.setCurrentStrokeColor = setCurrentStrokeColor;
         window.setCurrentFillColor = setCurrentFillColor;
         window.bringToFront = bringToFront;
         window.sendToBack = sendToBack;
         window.undoShapeRecognition = undoShapeRecognition;
         window.convertToShape = convertToShape;
         window.pasteFromClipboard = pasteFromClipboard;
         window.toggleDottedLine = toggleDottedLine;
         window.setColor = setColor;
         window.hideContextMenu = hideContextMenu;
         window.toggleShapeDropdown = toggleShapeDropdown;
         window.hideShapeDropdown = hideShapeDropdown;
         window.changeSelectedShapesType = changeSelectedShapesType;
         
         // Menu functions
         window.toggleAppMenu = toggleAppMenu;
         window.importCanvas = importCanvas;
         window.exportCanvas = exportCanvas;
         window.handleImportFile = handleImportFile;
         window.toggleBold = toggleBold;

         updateColorUI();
         if (isBold) {
            const btn = document.getElementById("ft-btn-bold");
            if (btn) btn.classList.add("active");
         }
      </script>
      <!-- Secondary Actions Toolbar (Undo, Duplicate, Delete, Reset) - Moved to body to avoid clipping -->
      <div class="toolbar-secondary" id="secondary-toolbar" style="position: fixed; z-index: 100">
         <button
            class="tool-btn rounded-md text-gray-600 hover:bg-gray-200"
            onclick="undo()"
            title="Undo (Ctrl+Z)"
         >
            <i data-lucide="undo-2"></i>
         </button>
         <button
            class="tool-btn rounded-md text-gray-600 hover:bg-gray-200"
            onclick="duplicateSelected()"
            title="Duplicate (Ctrl+D)"
         >
            <i data-lucide="copy"></i>
         </button>
         <button
            class="tool-btn rounded-md text-red-500 hover:bg-red-100"
            onclick="deleteSelected()"
            title="Delete (Del)"
         >
            <i data-lucide="trash-2"></i>
         </button>
         <div class="w-px h-5 bg-gray-300 mx-1"></div>
         <button
            class="tool-btn rounded-md text-red-500 hover:bg-red-100"
            onclick="clearBoard()"
            title="Clear All (Alt+N)"
         >
            <i data-lucide="refresh-ccw"></i>
         </button>
      </div>

      <script>
         function updateSecondaryToolbarPos() {
            const main = document.querySelector(".toolbar-main");
            const sec = document.getElementById("secondary-toolbar");
            if (!main || !sec) return;

            const rect = main.getBoundingClientRect();
            const gap = 8;
            const indentation = 8; // Align with some indentation like before

            // Calculate position
            // We use fixed positioning based on the main toolbar's client rect
            const leftVal = rect.left + indentation;
            const topVal = rect.top - sec.offsetHeight - gap;

            sec.style.left = leftVal + "px";
            sec.style.top = topVal + "px";

            // Reset incompatible styles from CSS class if any
            sec.style.bottom = "auto";
            sec.style.right = "auto";

            // Ensure icons are rendered if Lucide missed them on dynamic insert (unlikely on page load)
            if (window.lucide && window.lucide.createIcons) {
               window.lucide.createIcons({
                  root: sec,
               });
            }
         }

         // Update position on resize and periodically
         window.addEventListener("resize", updateSecondaryToolbarPos);
         // Also update on scroll since main toolbar might move if window scrolls (though body is overflow hidden)
         window.addEventListener("scroll", updateSecondaryToolbarPos);

         // Poll every 500ms to catch layout changes or visibility changes
         setInterval(updateSecondaryToolbarPos, 500);

         // Immediate call
         // We wrap in setTimeout to ensure initial layout is done and Lucide potentially ran
         setTimeout(updateSecondaryToolbarPos, 100);
         setTimeout(updateSecondaryToolbarPos, 500);
      </script>
   </body>
</html>
