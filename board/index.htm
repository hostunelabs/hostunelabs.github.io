<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
      />
      <title>TuneBoard</title>
      <!-- Google Fonts - Caveat for handwriting-style text -->
      <link rel="preconnect" href="https://fonts.googleapis.com" />
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
      <link
         href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&display=swap"
         rel="stylesheet"
      />
      <script src="https://cdn.tailwindcss.com"></script>
      <!-- Updated Lucide Script to ensure UMD build is loaded -->
      <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
      <style>
         body {
            overscroll-behavior: none;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
         }
         canvas {
            touch-action: none;
            display: block;
         }
         .tool-btn {
            transition: all 0.2s ease;
            min-height: 36px;
            min-width: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            padding: 0.4rem !important;
         }
         @media (max-width: 640px) {
            .tool-btn {
               min-height: 44px;
               min-width: 44px;
               padding: 0.5rem !important;
            }
         }
         .tool-btn.active {
            background-color: #e5e7eb;
            color: #2563eb;
            transform: scale(1.05);
         }
         .color-swatch {
            transition: transform 0.2s ease;
            min-height: 20px;
            min-width: 20px;
            flex-shrink: 0;
         }
         @media (max-width: 640px) {
            .color-swatch {
               min-height: 24px;
               min-width: 24px;
            }
         }
         .color-swatch:hover,
         .color-swatch.active {
            transform: scale(1.2);
            box-shadow: 0 0 0 2px white, 0 0 0 4px #e5e7eb;
         }
         input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            height: 5px;
            flex-shrink: 0;
         }
         input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #2563eb;
            margin-top: -7px;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
         }
         input[type="range"]::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            border: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
         }
         input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 5px;
            background: #e5e7eb;
            border-radius: 2px;
         }
         input[type="range"]::-moz-range-track {
            background: #e5e7eb;
            border-radius: 2px;
            height: 5px;
         }
         .no-scrollbar::-webkit-scrollbar {
            display: none;
         }
         .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
         }

         #text-input {
            position: absolute;
            background: transparent;
            border: none;
            outline: none;
            padding: 0;
            margin: 0;
            font-family: "Caveat", cursive;
            font-weight: bold;
            color: black;
            z-index: 100;
            min-width: 50px;
            line-height: 1; /* Match canvas text rendering */
         }

         /* Context Menu Styles */
         #context-menu {
            position: absolute;
            z-index: 1000;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 4px;
            min-width: 160px;
            max-width: calc(100vw - 16px);
         }
         .context-menu-item {
            padding: 10px 12px;
            font-size: 14px;
            color: #374151;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            border-radius: 4px;
            white-space: nowrap;
            touch-action: manipulation;
            flex-shrink: 0;
         }
         @media (max-width: 640px) {
            .context-menu-item {
               padding: 12px 14px;
               font-size: 15px;
               min-height: 44px;
            }
         }
         .context-menu-item:hover,
         .context-menu-item:active {
            background-color: #f3f4f6;
            color: #111827;
         }

         .color-swatch.transparent-swatch {
            background: repeating-conic-gradient(#ddd 0% 25%, #fff 0% 50%) 50% / 8px 8px;
            position: relative;
            overflow: hidden;
         }
         .color-swatch.transparent-swatch::after {
            content: "";
            position: absolute;
            top: 50%;
            left: -20%;
            width: 140%;
            height: 1px;
            background: red;
            transform: rotate(45deg);
         }

         /* Responsive toolbar */
         .toolbar-main {
            display: flex;
            flex-wrap: nowrap;
            align-items: center;
            gap: 1px;
            gap: 1px;
            overflow: visible;
            max-height: 56px;
         }

         .toolbar-group {
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 0 4px;
            flex-shrink: 0;
            border-right: 1px solid #e5e7eb;
         }

         .toolbar-group:last-child {
            border-right: none;
         }

         @media (max-width: 640px) {
            .toolbar-main {
               bottom: 12px !important;
               width: calc(100% - 12px) !important;
               left: 6px !important;
               transform: none !important;
               gap: 4px !important;
               padding: 6px 8px !important;
               border-radius: 16px !important;
               max-height: 70vh;
            }
            .toolbar-group {
               gap: 4px !important;
               padding: 0 6px !important;
            }
            .toolbar-group.border-r {
               border-right: 1px solid #e5e7eb;
            }
         }

         /* Ensure touch targets are 44x44 minimum */
         @media (max-width: 1024px) {
            button {
               min-height: 44px;
               min-width: 44px;
            }
         }

         /* Mobile viewport optimization */
         @media (orientation: landscape) and (max-height: 600px) {
            .toolbar-main {
               bottom: 8px !important;
               max-height: 90px !important;
            }
            .toolbar-group {
               gap: 2px !important;
            }
         }

         /* Plus icon tooltip styling */
         #plus-icon-tooltip {
            position: absolute;
            z-index: 1000;
            background: rgba(100, 116, 139, 0.75);
            color: rgba(255, 255, 255, 0.9);
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 400;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
            white-space: nowrap;
         }
         #plus-icon-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
         }
         #plus-icon-tooltip kbd {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 5px;
            border-radius: 3px;
            font-family: ui-monospace, monospace;
            font-size: 11px;
            margin-left: 6px;
         }

         /* Shape dropdown menu styles */
         .shape-dropdown {
            position: relative;
         }
         .shape-dropdown-menu {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 4px;
            margin-bottom: 8px;
            min-width: 120px;
            z-index: 2000;
            display: none;
         }
         .shape-dropdown-menu.visible {
            display: block;
         }
         .shape-dropdown-item {
            padding: 8px 12px;
            font-size: 13px;
            color: #374151;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            border-radius: 4px;
            white-space: nowrap;
         }
         .shape-dropdown-item:hover {
            background-color: #f3f4f6;
            color: #111827;
         }
         .shape-dropdown-item.active {
            background-color: #e5e7eb;
            color: #2563eb;
         }
      </style>
   </head>
   <body
      class="bg-gray-50 h-screen w-screen overflow-hidden flex flex-col font-sans"
      oncontextmenu="return false;"
   >
      <!-- Logo -->
      <img
         src="logo.png"
         alt="TuneBoard Logo"
         class="absolute top-3 left-4 md:top-4 md:left-6 z-20 h-4 md:h-5 w-auto select-none pointer-events-none"
      />

      <!-- Top Toolbar -->
      <div
         class="toolbar-main absolute bottom-4 left-1/2 transform -translate-x-1/2 z-20 p-2 bg-white/95 backdrop-blur-md rounded-2xl shadow-xl border border-gray-200 w-[95%] max-w-6xl"
      >
         <!-- Tools Group 1: Basics -->
         <div class="toolbar-group">
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-select"
               onclick="setTool('select')"
               title="Select (S)"
            >
               <i data-lucide="mouse-pointer-2" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn active p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-pencil"
               onclick="setTool('pencil')"
               title="Pencil (P)"
            >
               <i data-lucide="pencil" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-pencil-arrow"
               onclick="setTool('pencil-arrow')"
               title="Freehand Arrow (F)"
            >
               <i data-lucide="corner-up-right" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-laser"
               onclick="setTool('laser')"
               title="Laser Tool (Z)"
            >
               <i data-lucide="zap" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-eraser"
               onclick="setTool('eraser')"
               title="Eraser (E)"
            >
               <i data-lucide="eraser" class="w-4 h-4"></i>
            </button>
         </div>

         <!-- Tools Group 2: Lines & Text -->
         <div class="toolbar-group">
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-line"
               onclick="setTool('line')"
               title="Line (L)"
            >
               <i data-lucide="minus" class="w-4 h-4 transform -rotate-45"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-arrow"
               onclick="setTool('arrow')"
               title="Curved Arrow (A)"
            >
               <i data-lucide="move-up-right" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-text"
               onclick="setTool('text')"
               title="Text (T)"
            >
               <i data-lucide="type" class="w-4 h-4"></i>
            </button>
         </div>

         <!-- Tools Group 3: Shapes -->
         <div class="toolbar-group">
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-rect"
               onclick="setTool('rect')"
               title="Rectangle (R)"
            >
               <i data-lucide="square" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-circle"
               onclick="setTool('circle')"
               title="Circle (C)"
            >
               <i data-lucide="circle" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               id="btn-triangle"
               onclick="setTool('triangle')"
               title="Triangle (N)"
            >
               <i data-lucide="triangle" class="w-4 h-4"></i>
            </button>
            <!-- More Shapes Dropdown -->
            <div class="shape-dropdown">
               <button
                  class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
                  id="btn-more-shapes"
                  onclick="toggleShapeDropdown()"
                  title="More Shapes"
               >
                  <i data-lucide="more-horizontal" class="w-4 h-4"></i>
               </button>
               <div id="shape-dropdown-menu" class="shape-dropdown-menu">
                  <div
                     class="shape-dropdown-item"
                     id="btn-oval"
                     onclick="setTool('oval'); hideShapeDropdown()"
                  >
                     <i data-lucide="circle" class="w-4 h-4"></i>
                     <span>Oval</span>
                  </div>
                  <div
                     class="shape-dropdown-item"
                     id="btn-rhombus"
                     onclick="setTool('rhombus'); hideShapeDropdown()"
                  >
                     <i data-lucide="diamond" class="w-4 h-4"></i>
                     <span>Rhombus</span>
                  </div>
                  <div
                     class="shape-dropdown-item"
                     id="btn-diamond"
                     onclick="setTool('diamond'); hideShapeDropdown()"
                  >
                     <i data-lucide="diamond" class="w-4 h-4"></i>
                     <span>Diamond</span>
                  </div>
               </div>
            </div>
         </div>

         <!-- Colors -->
         <div class="toolbar-group" style="gap: 6px">
            <div
               id="color-indicator"
               class="flex flex-col gap-0.5 mr-1"
               title="Top: Stroke, Bottom: Fill"
            >
               <div id="stroke-preview" class="w-4 h-2 bg-black"></div>
               <div id="fill-preview" class="w-4 h-2 bg-transparent transparent-swatch"></div>
            </div>
            <button
               class="color-swatch w-5 h-5 rounded-full transparent-swatch"
               data-color="transparent"
               onclick="handleColorClick('transparent', event)"
               oncontextmenu="handleColorClick('transparent', event); return false;"
               title="Transparent (Right click to fill)"
            ></button>
            <button
               class="color-swatch w-5 h-5 rounded-full bg-black"
               data-color="#000000"
               onclick="handleColorClick('#000000', event)"
               oncontextmenu="handleColorClick('#000000', event); return false;"
               title="Black (Right click to fill)"
            ></button>
            <button
               class="color-swatch w-5 h-5 rounded-full bg-red-500"
               data-color="#ef4444"
               onclick="handleColorClick('#ef4444', event)"
               oncontextmenu="handleColorClick('#ef4444', event); return false;"
               title="Red (Right click to fill)"
            ></button>
            <button
               class="color-swatch w-5 h-5 rounded-full bg-blue-500"
               data-color="#3b82f6"
               onclick="handleColorClick('#3b82f6', event)"
               oncontextmenu="handleColorClick('#3b82f6', event); return false;"
               title="Blue (Right click to fill)"
            ></button>
            <button
               class="color-swatch w-5 h-5 rounded-full bg-green-500"
               data-color="#22c55e"
               onclick="handleColorClick('#22c55e', event)"
               oncontextmenu="handleColorClick('#22c55e', event); return false;"
               title="Green (Right click to fill)"
            ></button>
            <div class="relative group w-5 h-5">
               <input
                  type="color"
                  id="customColorPicker"
                  class="opacity-0 absolute inset-0 w-full h-full cursor-pointer"
                  oninput="handleCustomColorInput(this.value, event)"
                  onchange="handleCustomColorChange(event)"
                  onmousedown="handleCustomColorMouseDown(event)"
                  title="Custom Color (Right click to fill)"
               />
               <div
                  class="w-full h-full rounded-full bg-gradient-to-br from-purple-400 to-pink-500 border border-gray-200 flex items-center justify-center cursor-pointer"
                  title="Custom Color"
                  onmousedown="handleCustomColorPickerMouseDown(event)"
               >
                  <i data-lucide="plus" class="w-3 h-3 text-white"></i>
               </div>
            </div>
         </div>

         <!-- Brush Size (Desktop) -->
         <div class="toolbar-group hidden md:flex" style="gap: 6px">
            <i data-lucide="circle-dot" class="w-4 h-4 text-gray-400 flex-shrink-0"></i>
            <input
               type="range"
               min="1"
               max="50"
               value="3"
               id="width-slider-desk"
               class="w-20"
               oninput="setLineWidth(this.value)"
               title="Thickness ([ / ])"
            />
            <span id="width-val-desk" class="text-xs text-gray-500 w-4 flex-shrink-0">3</span>
         </div>

         <!-- Actions Group 1: Files -->
         <div class="toolbar-group">
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               onclick="downloadImage()"
               title="Download (Ctrl+S)"
            >
               <i data-lucide="download" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               onclick="document.getElementById('imageInput').click()"
               title="Add Image"
            >
               <i data-lucide="image" class="w-4 h-4"></i>
            </button>
            <input
               type="file"
               id="imageInput"
               accept="image/*"
               class="hidden"
               onchange="handleImageFile(this.files[0])"
            />
         </div>

         <!-- Actions Group 2: Board -->
         <div class="toolbar-group">
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               onclick="undo()"
               title="Undo (Ctrl+Z)"
            >
               <i data-lucide="undo-2" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100 text-red-500 hover:bg-red-50"
               onclick="clearBoard()"
               title="Clear All (Alt+N)"
            >
               <i data-lucide="refresh-ccw" class="w-4 h-4"></i>
            </button>
         </div>

         <!-- Selection Actions -->
         <div id="selection-actions" class="toolbar-group hidden">
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               onclick="bringToFront()"
               title="Bring to Front"
            >
               <i data-lucide="layers-2" class="w-4 h-4"></i>
            </button>
            <button
               class="tool-btn p-2 rounded-lg text-gray-600 hover:bg-gray-100"
               onclick="sendToBack()"
               title="Send to Back"
            >
               <i data-lucide="layers" class="w-4 h-4"></i>
            </button>
            <button
               id="btn-delete-selected"
               class="tool-btn p-2 rounded-lg text-red-500 hover:bg-red-50"
               onclick="deleteSelected()"
               title="Delete (Del)"
            >
               <i data-lucide="trash-2" class="w-4 h-4"></i>
            </button>
         </div>
      </div>

      <!-- Context Toolbar (Alignment) - Floats below main toolbar -->
      <div
         id="alignment-bar"
         class="absolute bottom-24 left-1/2 transform -translate-x-1/2 z-10 flex items-center gap-1 p-2 bg-white/90 backdrop-blur-sm rounded-xl shadow-lg border border-gray-200 hidden transition-all duration-200"
      >
         <button
            class="tool-btn p-2 rounded-xl text-gray-600 hover:bg-gray-100"
            onclick="alignSelected('left')"
            title="Align Left (L)"
         >
            <i data-lucide="arrow-left-to-line" class="w-4 h-4"></i>
         </button>
         <button
            class="tool-btn p-2 rounded-xl text-gray-600 hover:bg-gray-100"
            onclick="alignSelected('center-h')"
            title="Align Center Horizontal (H / E)"
         >
            <i data-lucide="align-center-horizontal" class="w-4 h-4"></i>
         </button>
         <button
            class="tool-btn p-2 rounded-xl text-gray-600 hover:bg-gray-100"
            onclick="alignSelected('right')"
            title="Align Right (R)"
         >
            <i data-lucide="arrow-right-to-line" class="w-4 h-4"></i>
         </button>
         <div class="w-px h-6 bg-gray-200 mx-1"></div>
         <button
            class="tool-btn p-2 rounded-xl text-gray-600 hover:bg-gray-100"
            onclick="alignSelected('top')"
            title="Align Top (T)"
         >
            <i data-lucide="arrow-up-to-line" class="w-4 h-4"></i>
         </button>
         <button
            class="tool-btn p-2 rounded-xl text-gray-600 hover:bg-gray-100"
            onclick="alignSelected('middle-v')"
            title="Align Middle Vertical (C / V)"
         >
            <i data-lucide="align-center-vertical" class="w-4 h-4"></i>
         </button>
         <button
            class="tool-btn p-2 rounded-xl text-gray-600 hover:bg-gray-100"
            onclick="alignSelected('bottom')"
            title="Align Bottom (B)"
         >
            <i data-lucide="arrow-down-to-line" class="w-4 h-4"></i>
         </button>
      </div>

      <!-- Mobile Size Slider -->
      <div
         class="absolute bottom-6 right-4 md:right-6 z-20 md:hidden bg-white/90 backdrop-blur-sm p-3 rounded-2xl shadow-lg border border-gray-200 flex items-center gap-3 flex-shrink-0"
         style="max-width: 85%; min-width: min(250px, 85%)"
      >
         <i data-lucide="circle-dot-dashed" class="w-4 h-4 text-gray-400 flex-shrink-0"></i>
         <input
            type="range"
            min="1"
            max="50"
            value="3"
            id="width-slider-mob"
            class="flex-grow min-w-0"
            oninput="setLineWidth(this.value)"
         />
         <span id="width-val-mob" class="text-xs text-gray-500 font-bold w-5 flex-shrink-0">3</span>
      </div>

      <!-- Reset Zoom Button -->
      <div class="absolute top-3 md:top-4 right-4 md:right-6 z-20 flex items-center gap-2">
         <button
            class="tool-btn p-2 md:p-3 bg-white/95 backdrop-blur-md rounded-2xl shadow-xl border border-gray-200 text-gray-600 hover:bg-gray-100 flex items-center gap-2"
            onclick="resetView()"
            title="Reset View (Esc)"
         >
            <i data-lucide="refresh-cw" class="w-4 md:w-5 h-4 md:h-5"></i>
            <span class="text-xs font-bold hidden sm:inline" id="zoom-percentage">100%</span>
         </button>
      </div>

      <canvas id="canvas"></canvas>

      <div
         id="toast"
         class="absolute top-20 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-full shadow-lg opacity-0 transition-opacity duration-300 pointer-events-none z-50 text-xs sm:text-sm"
      >
         Action Completed
      </div>

      <!-- Shape Recognition Undo Panel -->
      <div
         id="shape-recognition-panel"
         class="absolute top-4 left-1/2 transform -translate-x-1/2 bg-white rounded-lg shadow-xl border border-gray-200 px-4 py-3 z-50 hidden transition-all duration-300"
         style="opacity: 0; transform: translate(-50%, -10px)"
      >
         <div class="flex items-center gap-2">
            <button
               id="undo-shape-btn"
               class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-md text-sm font-medium text-gray-700 transition-colors"
               onclick="undoShapeRecognition()"
            >
               Undo
            </button>
            <div class="w-px h-6 bg-gray-300"></div>
            <button
               id="convert-rectangle-btn"
               class="px-4 py-2 bg-blue-50 hover:bg-blue-100 rounded-md text-sm font-medium text-blue-700 transition-colors"
               onclick="convertToShape('rectangle')"
            >
               Rectangle
            </button>
            <button
               id="convert-circle-btn"
               class="px-4 py-2 bg-blue-50 hover:bg-blue-100 rounded-md text-sm font-medium text-blue-700 transition-colors"
               onclick="convertToShape('circle')"
            >
               Circle
            </button>
            <button
               id="convert-triangle-btn"
               class="px-4 py-2 bg-blue-50 hover:bg-blue-100 rounded-md text-sm font-medium text-blue-700 transition-colors"
               onclick="convertToShape('triangle')"
            >
               Triangle
            </button>
         </div>
      </div>

      <!-- Context Menu -->
      <div
         id="context-menu"
         class="absolute bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50 hidden overflow-y-auto"
         style="max-height: 90vh"
      >
         <div
            class="context-menu-item"
            id="paste-menu-item"
            style="display: none"
            onclick="pasteFromClipboard(); hideContextMenu()"
         >
            <i data-lucide="clipboard-paste" class="w-4 h-4 flex-shrink-0"></i>
            <span>Paste</span>
         </div>
         <div
            class="context-menu-separator"
            id="paste-separator"
            style="display: none; height: 1px; background-color: #e5e7eb; margin: 4px 0"
         ></div>
         <div
            class="context-menu-item"
            id="to-dotted-line-item"
            style="display: none"
            onclick="toggleDottedLine(); hideContextMenu()"
         >
            <i data-lucide="circle-dot-dashed" class="w-4 h-4 flex-shrink-0"></i>
            <span>Toggle Dotted Line</span>
         </div>
         <div
            class="context-menu-separator"
            id="editing-layering-separator"
            style="display: none; height: 1px; background-color: #e5e7eb; margin: 4px 0"
         ></div>
         <div
            class="context-menu-item"
            id="bring-to-front-item"
            style="display: none"
            onclick="bringToFront(); hideContextMenu()"
         >
            <i data-lucide="layers-2" class="w-4 h-4 flex-shrink-0"></i>
            <span>Bring to Front</span>
         </div>
         <div
            class="context-menu-item"
            id="send-to-back-item"
            style="display: none"
            onclick="sendToBack(); hideContextMenu()"
         >
            <i data-lucide="layers" class="w-4 h-4 flex-shrink-0"></i>
            <span>Send to Back</span>
         </div>
         <div
            class="context-menu-separator"
            id="layering-delete-separator"
            style="display: none; height: 1px; background-color: #e5e7eb; margin: 4px 0"
         ></div>
         <div
            class="context-menu-item text-red-500"
            id="delete-item"
            style="display: none"
            onclick="deleteSelected(); hideContextMenu()"
         >
            <i data-lucide="trash-2" class="w-4 h-4 flex-shrink-0"></i>
            <span>Delete</span>
         </div>
         <!-- Shape conversion items (appended after existing context menu items) -->
         <div
            class="context-menu-separator"
            id="shape-conversion-separator"
            style="display: none; height: 1px; background-color: #e5e7eb; margin: 4px 0"
         ></div>
         <div
            class="context-menu-item"
            id="change-to-rectangle-item"
            style="display: none"
            onclick="changeSelectedShapesType('rect'); hideContextMenu()"
         >
            <i data-lucide="square" class="w-4 h-4 flex-shrink-0"></i>
            <span>Change to Rectangle</span>
         </div>
         <div
            class="context-menu-item"
            id="change-to-circle-item"
            style="display: none"
            onclick="changeSelectedShapesType('circle'); hideContextMenu()"
         >
            <i data-lucide="circle" class="w-4 h-4 flex-shrink-0"></i>
            <span>Change to Circle</span>
         </div>
         <div
            class="context-menu-item"
            id="change-to-triangle-item"
            style="display: none"
            onclick="changeSelectedShapesType('triangle'); hideContextMenu()"
         >
            <i data-lucide="triangle" class="w-4 h-4 flex-shrink-0"></i>
            <span>Change to Triangle</span>
         </div>
         <div
            class="context-menu-item"
            id="change-to-oval-item"
            style="display: none"
            onclick="changeSelectedShapesType('oval'); hideContextMenu()"
         >
            <i data-lucide="circle" class="w-4 h-4 flex-shrink-0"></i>
            <span>Change to Oval</span>
         </div>
         <div
            class="context-menu-item"
            id="change-to-rhombus-item"
            style="display: none"
            onclick="changeSelectedShapesType('rhombus'); hideContextMenu()"
         >
            <i data-lucide="diamond" class="w-4 h-4 flex-shrink-0"></i>
            <span>Change to Rhombus</span>
         </div>
         <div
            class="context-menu-item"
            id="change-to-diamond-item"
            style="display: none"
            onclick="changeSelectedShapesType('diamond'); hideContextMenu()"
         >
            <i data-lucide="diamond" class="w-4 h-4 flex-shrink-0"></i>
            <span>Change to Diamond</span>
         </div>
      </div>

      <!-- Plus Icon Tooltip -->
      <div id="plus-icon-tooltip">Add connected shape <kbd>+</kbd></div>

      <script>
         // Wait for Lucide to load
         window.addEventListener("load", function () {
            if (typeof lucide !== "undefined") {
               lucide.createIcons();
            }
         });

         const canvas = document.getElementById("canvas");
         const ctx = canvas.getContext("2d");
         const toastEl = document.getElementById("toast");
         const btnDeleteSelected = document.getElementById("btn-delete-selected");
         const alignmentBar = document.getElementById("alignment-bar");
         const plusIconTooltip = document.getElementById("plus-icon-tooltip");

         // --- Application State ---
         let shapes = [];
         let historyStack = [];
         let historyStep = -1;
         const MAX_HISTORY = 40;

         let currentTool = "pencil";
         let currentColor = "#000000";
         let currentFillColor = "transparent";
         let currentWidth = 4;

         let isDragging = false;
         let startPos = { x: 0, y: 0 };

         // Interaction State
         let currentShape = null;
         let selectedIndices = new Set();
         let selectionQueue = []; // Explicit chronological order
         let selectionBox = null;

         function clearSelection() {
            selectedIndices.clear();
            selectionQueue = [];
            // Reset hover state when selection is cleared
            hoveredSide = null;
            hoveredRectIndex = null;
         }

         function addToSelection(idx) {
            if (!selectedIndices.has(idx)) {
               selectedIndices.add(idx);
               // Ensure unique in queue
               if (!selectionQueue.includes(idx)) {
                  selectionQueue.push(idx);
               }
            }
         }

         function removeFromSelection(idx) {
            selectedIndices.delete(idx);
            selectionQueue = selectionQueue.filter((i) => i !== idx);
         }

         let arrowCreationPhase = "idle";

         // Laser Tool State
         let laserShapes = []; // Array to store laser shapes with timestamps
         const LASER_LIFETIME = 2000; // Laser lines last 2 seconds
         const LASER_DELETE_DELAY = 500; // Start deleting after 0.5 seconds
         const LASER_DELETE_DURATION = 1000; // Delete over 1 second
         const LASER_MAX_TAIL = 100; // Maximum points in laser tail

         // Shape Recognition Undo Panel State
         let originalPencilShape = null; // Store original pencil shape for undo
         let convertedShapeIndex = -1; // Index of the converted shape in shapes array
         let shapeRecognitionPanelTimer = null; // Timer for auto-hiding panel

         // Manipulation State
         let isManipulatingHandle = false;
         let isMovingSelection = false;
         let isBoxSelecting = false;
         let isDuplicating = false;
         let activeHandle = null;
         let moveOffset = { x: 0, y: 0 };
         let initialShapeState = null;
         let temporarilyDisconnectedShapes = new Map(); // Store broken connections during movement

         // Rectangle Plus Icon State (for creating connected rectangles)
         let hoveredSide = null; // 'top', 'right', 'bottom', 'left', or null
         let hoveredRectIndex = null; // Index of rectangle being hovered

         // Context Menu State
         let contextMenuTarget = null;

         // Text Editing
         let isTyping = false;
         let isFinishingText = false;
         let activeInput = null;

         // --- Camera / Transformation State ---
         let camera = {
            x: 0,
            y: 0,
            scale: 1,
            isPanning: false,
         };

         function toWorld(screenX, screenY) {
            return {
               x: (screenX - camera.x) / camera.scale,
               y: (screenY - camera.y) / camera.scale,
            };
         }

         function toScreen(worldX, worldY) {
            return {
               x: worldX * camera.scale + camera.x,
               y: worldY * camera.scale + camera.y,
            };
         }

         function generateId() {
            return "shape_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
         }

         // --- Core Engine ---

         function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render();
         }
         window.addEventListener("resize", resizeCanvas);

         // --- Interaction Logic ---

         canvas.addEventListener(
            "wheel",
            (e) => {
               if (e.ctrlKey) {
                  e.preventDefault();
                  const zoomSpeed = 0.001;
                  const delta = -e.deltaY;
                  const factor = Math.pow(1.1, delta / 100);

                  const rect = canvas.getBoundingClientRect();
                  const mouseX = e.clientX - rect.left;
                  const mouseY = e.clientY - rect.top;

                  // Position before zoom
                  const worldPos = toWorld(mouseX, mouseY);

                  camera.scale *= factor;
                  // Limit scale
                  camera.scale = Math.min(Math.max(0.1, camera.scale), 20);

                  // Re-position after zoom to keep mouse fixed in world
                  const newScreenPos = toScreen(worldPos.x, worldPos.y);
                  camera.x -= newScreenPos.x - mouseX;
                  camera.y -= newScreenPos.y - mouseY;

                  render();
               }
            },
            { passive: false }
         );

         function render() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawGrid();

            // Apply Camera Transform
            ctx.setTransform(camera.scale, 0, 0, camera.scale, camera.x, camera.y);

            // Draw Shapes
            shapes.forEach((shape, index) => {
               drawShape(shape, selectedIndices.has(index));
            });

            // Draw Laser Shapes (temporary, auto-deleting)
            laserShapes.forEach((laserShape) => {
               drawShape(laserShape, false);
            });

            // Draw Ghost Shape
            if (currentShape) {
               drawShape(currentShape, false);
            }

            // Draw Selection Box
            if (selectionBox) {
               ctx.save();
               ctx.strokeStyle = "#3b82f6";
               ctx.fillStyle = "rgba(59, 130, 246, 0.1)";
               ctx.lineWidth = 1 / camera.scale; // Adjust width for zoom
               ctx.setLineDash([4 / camera.scale, 4 / camera.scale]);
               const x = Math.min(selectionBox.start.x, selectionBox.end.x);
               const y = Math.min(selectionBox.start.y, selectionBox.end.y);
               const w = Math.abs(selectionBox.end.x - selectionBox.start.x);
               const h = Math.abs(selectionBox.end.y - selectionBox.start.y);
               ctx.fillRect(x, y, w, h);
               ctx.strokeRect(x, y, w, h);
               ctx.restore();
            }

            // Draw plus icons for selected rectangles and circles
            if (currentTool === "select" && selectedIndices.size === 1) {
               const idx = selectedIndices.values().next().value;
               const shape = shapes[idx];
               if (
                  shape &&
                  (shape.type === "rect" ||
                     shape.type === "circle" ||
                     shape.type === "oval" ||
                     shape.type === "rhombus" ||
                     shape.type === "diamond") &&
                  hoveredSide
               ) {
                  const iconPos = getPlusIconPosition(shape, hoveredSide);
                  if (iconPos) {
                     drawPlusIcon(ctx, iconPos.x, iconPos.y, hoveredSide);

                     // Set tooltip text based on direction
                     const shortcuts = {
                        top: "Ctrl+↑",
                        bottom: "Ctrl+↓",
                        left: "Ctrl+←",
                        right: "Ctrl+→",
                     };
                     plusIconTooltip.textContent = shortcuts[hoveredSide] || "";

                     // Position tooltip further from the icon based on side
                     const screenPos = toScreen(iconPos.x, iconPos.y);
                     const tooltipOffset = 20;

                     if (hoveredSide === "top") {
                        plusIconTooltip.style.left = screenPos.x + "px";
                        plusIconTooltip.style.top = screenPos.y - tooltipOffset + "px";
                        plusIconTooltip.style.transform = "translate(-50%, -100%)";
                     } else if (hoveredSide === "bottom") {
                        plusIconTooltip.style.left = screenPos.x + "px";
                        plusIconTooltip.style.top = screenPos.y + tooltipOffset + "px";
                        plusIconTooltip.style.transform = "translateX(-50%)";
                     } else if (hoveredSide === "left") {
                        plusIconTooltip.style.left = screenPos.x - tooltipOffset + "px";
                        plusIconTooltip.style.top = screenPos.y + "px";
                        plusIconTooltip.style.transform = "translate(-100%, -50%)";
                     } else if (hoveredSide === "right") {
                        plusIconTooltip.style.left = screenPos.x + tooltipOffset + "px";
                        plusIconTooltip.style.top = screenPos.y + "px";
                        plusIconTooltip.style.transform = "translateY(-50%)";
                     }

                     plusIconTooltip.classList.add("visible");
                  } else {
                     plusIconTooltip.classList.remove("visible");
                  }
               } else {
                  plusIconTooltip.classList.remove("visible");
               }
            } else {
               plusIconTooltip.classList.remove("visible");
            }

            // Update Zoom Display
            const zoomEl = document.getElementById("zoom-percentage");
            if (zoomEl) {
               zoomEl.textContent = Math.round(camera.scale * 100) + "%";
            }

            // Update UI (buttons and bars) remains in screen coordinates
            // Reset transform for UI-like logic if needed, but here it's just toggling classes
            if (selectedIndices.size > 0) {
               document.getElementById("selection-actions").classList.remove("hidden");
            } else {
               document.getElementById("selection-actions").classList.add("hidden");
            }

            if (selectedIndices.size > 1) {
               alignmentBar.classList.remove("hidden");
               alignmentBar.classList.add("flex");
            } else {
               alignmentBar.classList.add("hidden");
               alignmentBar.classList.remove("flex");
            }
         }

         function drawGrid() {
            const gridSize = 50 * camera.scale;
            const offsetX = camera.x % gridSize;
            const offsetY = camera.y % gridSize;

            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.beginPath();
            ctx.strokeStyle = "#fafbfc"; // Very light grid color
            ctx.lineWidth = 0.5;
            ctx.globalAlpha = 0.4;

            // Vertical lines
            for (let x = offsetX; x <= canvas.width; x += gridSize) {
               ctx.moveTo(x, 0);
               ctx.lineTo(x, canvas.height);
            }

            // Horizontal lines
            for (let y = offsetY; y <= canvas.height; y += gridSize) {
               ctx.moveTo(0, y);
               ctx.lineTo(canvas.width, y); // Corrected from canvas.height to canvas.width for horizontal lines
            }
            ctx.stroke();
            ctx.restore();
         }

         // Catmull-Rom spline interpolation for ultra-smooth curves
         function catmullRom(p0, p1, p2, p3, t) {
            const t2 = t * t;
            const t3 = t2 * t;
            return (
               0.5 *
               (2 * p1 +
                  (-p0 + p2) * t +
                  (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
                  (-p0 + 3 * p1 - 3 * p2 + p3) * t3)
            );
         }

         function drawShape(shape, isSelected) {
            ctx.save();
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.strokeStyle = shape.color;
            ctx.lineWidth = shape.width;
            ctx.fillStyle = shape.fillColor || "transparent";

            // Apply dotted line style if shape is marked as dotted
            if (shape.isDotted) {
               ctx.setLineDash([4 / camera.scale, 12 / camera.scale]);
            }

            const isFilled = shape.fillColor && shape.fillColor !== "transparent";
            const isStroked = shape.color && shape.color !== "transparent";

            if (shape.type === "laser") {
               // Draw laser with ultra-smooth Catmull-Rom splines
               if (shape.points.length > 1) {
                  const deletedCount = shape.deletedCount || 0;
                  const visiblePoints = shape.points.slice(deletedCount);
                  const tailOpacity = shape.tailOpacity !== undefined ? shape.tailOpacity : 1;

                  if (visiblePoints.length > 1) {
                     // Use Catmull-Rom for ultra-smooth interpolation
                     const r = parseInt(shape.color.slice(1, 3), 16);
                     const g = parseInt(shape.color.slice(3, 5), 16);
                     const b = parseInt(shape.color.slice(5, 7), 16);

                     // Draw segments with interpolation
                     for (let i = 0; i < visiblePoints.length - 1; i++) {
                        const p0 = visiblePoints[Math.max(0, i - 1)];
                        const p1 = visiblePoints[i];
                        const p2 = visiblePoints[i + 1];
                        const p3 = visiblePoints[Math.min(visiblePoints.length - 1, i + 2)];

                        const progress = i / Math.max(1, visiblePoints.length - 1);
                        const alpha = Math.max(
                           0,
                           Math.min(0.8, 0.8 * Math.sin(progress * Math.PI)) * tailOpacity
                        );

                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        ctx.lineWidth = shape.width * (0.7 + 0.6 * progress);

                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);

                        // Interpolate with 10 sub-segments for smoothness
                        for (let t = 0.1; t <= 1; t += 0.1) {
                           const x = catmullRom(p0.x, p1.x, p2.x, p3.x, t);
                           const y = catmullRom(p0.y, p1.y, p2.y, p3.y, t);
                           ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                     }
                  }
               }
            } else if (shape.type === "pencil" || shape.type === "pencil-arrow") {
               if (shape.points.length > 0) {
                  ctx.beginPath();
                  ctx.moveTo(shape.points[0].x, shape.points[0].y);

                  if (shape.points.length > 1) {
                     // Smooth quadratic curves without joints
                     for (let i = 1; i < shape.points.length; i++) {
                        const curr = shape.points[i];

                        if (i === 1) {
                           // First point - draw line to it
                           ctx.lineTo(curr.x, curr.y);
                        } else {
                           // Use midpoint between current and next point as end point
                           const next = shape.points[Math.min(i + 1, shape.points.length - 1)];
                           const nextMidX = (curr.x + next.x) / 2;
                           const nextMidY = (curr.y + next.y) / 2;
                           // Control point is the current point itself
                           ctx.quadraticCurveTo(curr.x, curr.y, nextMidX, nextMidY);
                        }
                     }
                     // Ensure we reach the last point
                     ctx.lineTo(
                        shape.points[shape.points.length - 1].x,
                        shape.points[shape.points.length - 1].y
                     );
                  }
                  if (isStroked) ctx.stroke();

                  // Draw Arrow Head for Freehand Arrow
                  if (shape.type === "pencil-arrow" && shape.points.length > 1) {
                     const points = shape.points;
                     const last = points[points.length - 1];

                     // Calculate average direction from last 3-5 points for stable angle
                     let angleSum = 0;
                     let validAngles = 0;
                     const lookBackCount = Math.min(5, points.length - 1);

                     for (let j = 1; j <= lookBackCount; j++) {
                        const idx = Math.max(0, points.length - 1 - j);
                        const prev = points[idx];

                        if (prev.x !== last.x || prev.y !== last.y) {
                           const angle = Math.atan2(last.y - prev.y, last.x - prev.x);
                           angleSum += angle;
                           validAngles++;
                        }
                     }

                     if (validAngles > 0) {
                        const avgAngle = angleSum / validAngles;
                        // Ensure fillStyle is set for arrowhead
                        ctx.fillStyle =
                           shape.color && shape.color !== "transparent" ? shape.color : "#000000";
                        drawArrowHead(ctx, last.x, last.y, avgAngle, shape.width * 3);
                     }
                  }
               }
            } else if (shape.type === "line") {
               ctx.beginPath();
               ctx.moveTo(shape.start.x, shape.start.y);
               ctx.lineTo(shape.end.x, shape.end.y);
               if (isStroked) ctx.stroke();
            } else if (shape.type === "arrow") {
               ctx.beginPath();
               ctx.moveTo(shape.start.x, shape.start.y);
               const cp = shape.control || {
                  x: (shape.start.x + shape.end.x) / 2,
                  y: (shape.start.y + shape.end.y) / 2,
               };
               ctx.quadraticCurveTo(cp.x, cp.y, shape.end.x, shape.end.y);
               if (isStroked) ctx.stroke();

               const dx = shape.end.x - cp.x;
               const dy = shape.end.y - cp.y;
               let angle = Math.atan2(dy, dx);
               if (dx === 0 && dy === 0) {
                  angle = Math.atan2(shape.end.y - shape.start.y, shape.end.x - shape.start.x);
               }
               // Ensure fillStyle is set for arrowhead
               ctx.fillStyle =
                  shape.color && shape.color !== "transparent" ? shape.color : "#000000";
               drawArrowHead(ctx, shape.end.x, shape.end.y, angle, shape.width * 3);
            } else if (shape.type === "rect") {
               if (isFilled) ctx.fillRect(shape.x, shape.y, shape.w, shape.h);
               if (isStroked) ctx.strokeRect(shape.x, shape.y, shape.w, shape.h);
            } else if (shape.type === "circle") {
               ctx.beginPath();
               const rx = Math.abs(shape.w / 2);
               const ry = Math.abs(shape.h / 2);
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
               if (isFilled) ctx.fill();
               if (isStroked) ctx.stroke();
            } else if (shape.type === "triangle") {
               ctx.beginPath();
               ctx.moveTo(shape.x + shape.w / 2, shape.y);
               ctx.lineTo(shape.x + shape.w, shape.y + shape.h);
               ctx.lineTo(shape.x, shape.y + shape.h);
               ctx.closePath();
               if (isFilled) ctx.fill();
               if (isStroked) ctx.stroke();
            } else if (shape.type === "oval") {
               ctx.beginPath();
               // Stadium shape using roundRect
               const radius = Math.min(Math.abs(shape.w), Math.abs(shape.h)) / 2;
               ctx.roundRect(shape.x, shape.y, shape.w, shape.h, radius);
               if (isFilled) ctx.fill();
               if (isStroked) ctx.stroke();
            } else if (shape.type === "rhombus") {
               ctx.beginPath();
               // Parallelogram shape (skewed rectangle)
               const skew = shape.w * 0.1;
               // Ensure skew direction works well with negative width/height
               // Or just normalize coordinates. We use shape.x, shape.w directly.

               // Points: Top-Left(skewed), Top-Right, Bottom-Right(skewed), Bottom-Left
               const x = shape.x;
               const y = shape.y;
               const w = shape.w;
               const h = shape.h;

               // To make it look right regardless of drag direction, we should probably normalize.
               // But existing shapes handle negative w/h gracefully by ctx.rect logic mostly.
               // Let's manually calculate vertices.

               ctx.moveTo(x + skew, y);
               ctx.lineTo(x + w, y);
               ctx.lineTo(x + w - skew, y + h);
               ctx.lineTo(x, y + h);
               ctx.closePath();

               if (isFilled) ctx.fill();
               if (isStroked) ctx.stroke();
            } else if (shape.type === "diamond") {
               ctx.beginPath();
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               ctx.moveTo(cx, shape.y); // Top
               ctx.lineTo(shape.x + shape.w, cy); // Right
               ctx.lineTo(cx, shape.y + shape.h); // Bottom
               ctx.lineTo(shape.x, cy); // Left
               ctx.closePath();
               if (isFilled) ctx.fill();
               if (isStroked) ctx.stroke();
            } else if (shape.type === "text") {
               ctx.font = `bold ${shape.size}px 'Caveat', cursive`;
               ctx.textBaseline = "top";
               ctx.fillStyle = shape.color; // Text uses 'color' (stroke) for filling characters
               if (isStroked) ctx.fillText(shape.text, shape.x, shape.y);
            } else if (shape.type === "image") {
               if (shape.image && shape.image.complete) {
                  ctx.drawImage(shape.image, shape.x, shape.y, shape.w, shape.h);
               } else {
                  // Placeholder while loading
                  ctx.fillStyle = "#e5e7eb";
                  ctx.fillRect(shape.x, shape.y, shape.w, shape.h);
                  ctx.strokeStyle = "#9ca3af";
                  ctx.strokeRect(shape.x, shape.y, shape.w, shape.h);
               }
            }

            // Draw inner text for shapes (rect, circle, triangle, oval, rhombus, diamond)
            if (
               (shape.type === "rect" ||
                  shape.type === "circle" ||
                  shape.type === "triangle" ||
                  shape.type === "oval" ||
                  shape.type === "rhombus" ||
                  shape.type === "diamond") &&
               shape.innerText &&
               !shape.isEditingText
            ) {
               ctx.save();
               ctx.font = `bold ${shape.innerTextSize || 20}px 'Caveat', cursive`;
               ctx.textBaseline = "middle";
               ctx.textAlign = "center";
               ctx.fillStyle = shape.innerTextColor || "#000000";

               // Calculate center position
               const centerX = shape.x + shape.w / 2;
               const centerY = shape.y + shape.h / 2;

               ctx.fillText(shape.innerText, centerX, centerY);
               ctx.restore();
            }

            ctx.restore();

            if (isSelected) {
               if (selectedIndices.size === 1) {
                  drawSelectionHandles(shape);
               } else {
                  drawSimpleBoundingBox(shape);
               }
            }
         }

         function drawArrowHead(ctx, x, y, angle, size) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-size, -size / 2);
            ctx.lineTo(-size, size / 2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
         }

         function drawSimpleBoundingBox(shape) {
            ctx.save();
            ctx.strokeStyle = "#3b82f6";
            ctx.lineWidth = 2 / camera.scale; // Adjust for zoom
            ctx.setLineDash([4 / camera.scale, 4 / camera.scale]); // Adjust dash for zoom
            const b = getBoundingBox(shape);
            const padding = 5 / camera.scale; // Adjust padding for zoom
            if (
               shape.type === "pencil" ||
               shape.type === "pencil-arrow" ||
               shape.type === "line" ||
               shape.type === "arrow"
            ) {
               ctx.strokeRect(b.x - padding, b.y - padding, b.w + padding * 2, b.h + padding * 2);
            } else if (shape.type === "text") {
               ctx.font = `bold ${shape.size}px 'Caveat', cursive`;
               ctx.textBaseline = "top";
               const m = ctx.measureText(shape.text);
               ctx.strokeRect(
                  shape.x - padding,
                  shape.y - padding,
                  m.width + padding * 2,
                  shape.size + padding * 2
               );
            } else {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);
               ctx.strokeRect(x - padding, y - padding, w + padding * 2, h + padding * 2);
            }
            ctx.restore();
         }

         function drawSelectionHandles(shape) {
            ctx.save();
            ctx.fillStyle = "#ffffff";
            ctx.strokeStyle = "#3b82f6";
            ctx.lineWidth = 2 / camera.scale; // Adjust for zoom

            if (shape.type === "arrow" || shape.type === "line") {
               const cp = shape.control || {
                  x: (shape.start.x + shape.end.x) / 2,
                  y: (shape.start.y + shape.end.y) / 2,
               };
               drawHandle(shape.start.x, shape.start.y);
               drawHandle(shape.end.x, shape.end.y);
               if (shape.type === "arrow") {
                  ctx.fillStyle = "#fcd34d";
                  drawHandle(cp.x, cp.y);
                  ctx.setLineDash([4 / camera.scale, 4 / camera.scale]);
                  ctx.beginPath();
                  ctx.moveTo(shape.start.x, shape.start.y);
                  ctx.lineTo(cp.x, cp.y);
                  ctx.lineTo(shape.end.x, shape.end.y);
                  ctx.stroke();
               }
            } else {
               // Rect, Triangle, Circle, Text, Pencil, Pencil-Arrow, Image
               let x, y, w, h;

               if (
                  shape.type === "text" ||
                  shape.type === "pencil" ||
                  shape.type === "pencil-arrow" ||
                  shape.type === "image"
               ) {
                  const b = getBoundingBox(shape);
                  x = b.x;
                  y = b.y;
                  w = b.w;
                  h = b.h;
               } else {
                  x = shape.x;
                  y = shape.y;
                  w = shape.w;
                  h = shape.h;
               }

               const padding = 5 / camera.scale; // Adjust padding for zoom
               ctx.setLineDash([4 / camera.scale, 4 / camera.scale]);
               ctx.strokeRect(x - padding, y - padding, w + padding * 2, h + padding * 2);

               // Corner handles only
               drawHandle(x, y);
               drawHandle(x + w, y);
               drawHandle(x, y + h);
               drawHandle(x + w, y + h);
            }
            ctx.restore();
         }

         function drawHandle(x, y) {
            const handleSize = 6 / camera.scale; // Adjust handle size for zoom
            ctx.beginPath();
            ctx.arc(x, y, handleSize, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
         }

         function drawSquareHandle(x, y, size) {
            ctx.fillRect(x - size, y - size, size * 2, size * 2);
            ctx.strokeRect(x - size, y - size, size * 2, size * 2);
         }

         // --- Rectangle & Circle Plus Icon Functions ---

         function detectHoveredSide(pos, shape) {
            if (
               shape.type === "rect" ||
               shape.type === "rhombus" ||
               shape.type === "diamond" ||
               shape.type === "oval"
            ) {
               return detectHoveredSideForRect(pos, shape);
            } else if (shape.type === "circle") {
               return detectHoveredSideForCircle(pos, shape);
            }
            return null;
         }

         function detectHoveredSideForRect(pos, rectShape) {
            if (
               rectShape.type !== "rect" &&
               rectShape.type !== "rhombus" &&
               rectShape.type !== "diamond" &&
               rectShape.type !== "oval"
            )
               return null;

            const x = Math.min(rectShape.x, rectShape.x + rectShape.w);
            const y = Math.min(rectShape.y, rectShape.y + rectShape.h);
            const w = Math.abs(rectShape.w);
            const h = Math.abs(rectShape.h);

            const hoverThreshold = 30 / camera.scale; // Distance threshold for detecting hover
            const edgeThreshold = 10 / camera.scale; // Distance from edge to consider "near"

            // Check if point is near the rectangle
            const isNearRect =
               pos.x >= x - hoverThreshold &&
               pos.x <= x + w + hoverThreshold &&
               pos.y >= y - hoverThreshold &&
               pos.y <= y + h + hoverThreshold;

            if (!isNearRect) return null;

            // Calculate distances to each side
            const distToTop = Math.abs(pos.y - y);
            const distToBottom = Math.abs(pos.y - (y + h));
            const distToLeft = Math.abs(pos.x - x);
            const distToRight = Math.abs(pos.x - (x + w));

            // Check if point is within the rectangle bounds (exclude interior)
            const isInside =
               pos.x > x + edgeThreshold &&
               pos.x < x + w - edgeThreshold &&
               pos.y > y + edgeThreshold &&
               pos.y < y + h - edgeThreshold;

            if (isInside) return null;

            // Determine which side is closest
            const minDist = Math.min(distToTop, distToBottom, distToLeft, distToRight);

            if (minDist > hoverThreshold) return null;

            // Check if point is near the middle portion of a side (not corners)
            const sideMiddleThreshold = Math.min(w, h) * 0.3; // 30% from center

            if (distToTop === minDist) {
               const centerX = x + w / 2;
               if (Math.abs(pos.x - centerX) < sideMiddleThreshold) {
                  return "top";
               }
            } else if (distToBottom === minDist) {
               const centerX = x + w / 2;
               if (Math.abs(pos.x - centerX) < sideMiddleThreshold) {
                  return "bottom";
               }
            } else if (distToLeft === minDist) {
               const centerY = y + h / 2;
               if (Math.abs(pos.y - centerY) < sideMiddleThreshold) {
                  return "left";
               }
            } else if (distToRight === minDist) {
               const centerY = y + h / 2;
               if (Math.abs(pos.y - centerY) < sideMiddleThreshold) {
                  return "right";
               }
            }

            return null;
         }

         function drawPlusIcon(ctx, x, y, side) {
            const iconSize = 20 / camera.scale;
            const lineWidth = 2 / camera.scale;
            const radius = iconSize / 2;

            ctx.save();
            ctx.fillStyle = "#ffffff";
            ctx.strokeStyle = "#3b82f6";
            ctx.lineWidth = lineWidth;

            // Draw circle background
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            // Draw plus sign
            ctx.strokeStyle = "#3b82f6";
            ctx.lineWidth = lineWidth * 1.5;
            ctx.lineCap = "round";

            const plusSize = radius * 0.6;
            ctx.beginPath();
            ctx.moveTo(x - plusSize, y);
            ctx.lineTo(x + plusSize, y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x, y - plusSize);
            ctx.lineTo(x, y + plusSize);
            ctx.stroke();

            ctx.restore();
         }

         function detectHoveredSideForCircle(pos, circleShape) {
            if (circleShape.type !== "circle") return null;

            const cx = circleShape.x + circleShape.w / 2;
            const cy = circleShape.y + circleShape.h / 2;
            const rx = Math.abs(circleShape.w / 2);
            const ry = Math.abs(circleShape.h / 2);

            // Calculate distance from center
            const dx = pos.x - cx;
            const dy = pos.y - cy;
            const distFromCenter = Math.hypot(dx / rx, dy / ry);

            const hoverThreshold = 30 / camera.scale; // Distance threshold for detecting hover
            const edgeThreshold = 0.1; // Distance from edge (normalized) to consider "near"

            // Check if point is near the circle edge
            const isNearEdge = Math.abs(distFromCenter - 1) * Math.max(rx, ry) < hoverThreshold;
            const isInside = distFromCenter < 1 - edgeThreshold;

            if (!isNearEdge || isInside) return null;

            // Determine which side based on angle
            // Math.atan2(dy, dx) returns: top=-90°(270°), right=0°, bottom=90°, left=180°(-180°)
            const angle = Math.atan2(dy, dx);
            let angleDeg = (angle * 180) / Math.PI;
            if (angleDeg < 0) angleDeg += 360; // Normalize to 0-360

            // Check if point is near the middle portion of a side (not corners)
            const cornerThreshold = 30; // degrees from cardinal directions

            // Top: around 270° (or -90° normalized to 270°)
            if (angleDeg >= 270 - cornerThreshold && angleDeg <= 270 + cornerThreshold) {
               return "top";
            }
            // Right: around 0° (or 360°)
            else if (angleDeg >= 360 - cornerThreshold || angleDeg <= cornerThreshold) {
               return "right";
            }
            // Bottom: around 90°
            else if (angleDeg >= 90 - cornerThreshold && angleDeg <= 90 + cornerThreshold) {
               return "bottom";
            }
            // Left: around 180°
            else if (angleDeg >= 180 - cornerThreshold && angleDeg <= 180 + cornerThreshold) {
               return "left";
            }

            return null;
         }

         function getPlusIconPosition(shape, side) {
            const offset = 30 / camera.scale; // Distance from shape edge

            if (shape.type === "rect" || shape.type === "diamond" || shape.type === "oval") {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);

               switch (side) {
                  case "top":
                     return { x: x + w / 2, y: y - offset };
                  case "right":
                     return { x: x + w + offset, y: y + h / 2 };
                  case "bottom":
                     return { x: x + w / 2, y: y + h + offset };
                  case "left":
                     return { x: x - offset, y: y + h / 2 };
                  default:
                     return null;
               }
            } else if (shape.type === "rhombus") {
               // Parallelogram plus icons
               const x = shape.x;
               const y = shape.y;
               const w = shape.w;
               const h = shape.h;
               const skew = w * 0.1;

               // Note: coordinates might be negative if drawn backwards, but shape.x is start.
               // Assuming standard drawing for now, or normalization.
               // Let's use bounding box center logic but shifted.

               // Top edge center: x + skew + (w-skew)/2 = x + skew/2 + w/2
               // Bottom edge center: x + (w-skew)/2 = x + w/2 - skew/2
               // Left edge vertical center: y + h/2. X at center height: x + skew * 0.5? No.
               // Left edge goes from (x, y+h) to (x+skew, y).
               // At y+h/2, x is (x + (x+skew))/2 = x + skew/2.
               // Right edge goes from (x+w-skew, y+h) to (x+w, y).
               // At y+h/2, x is x + w - skew/2.

               switch (side) {
                  case "top":
                     return { x: x + w / 2 + skew / 2, y: y - offset };
                  case "bottom":
                     return { x: x + w / 2 - skew / 2, y: y + h + offset };
                  case "left":
                     return { x: x + skew / 2 - offset, y: y + h / 2 };
                  case "right":
                     return { x: x + w - skew / 2 + offset, y: y + h / 2 };
                  default:
                     return null;
               }
            } else if (shape.type === "circle") {
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               const rx = Math.abs(shape.w / 2);
               const ry = Math.abs(shape.h / 2);
               const radius = Math.max(rx, ry);

               switch (side) {
                  case "top":
                     return { x: cx, y: cy - radius - offset };
                  case "right":
                     return { x: cx + radius + offset, y: cy };
                  case "bottom":
                     return { x: cx, y: cy + radius + offset };
                  case "left":
                     return { x: cx - radius - offset, y: cy };
                  default:
                     return null;
               }
            }

            return null;
         }

         function isPointOnPlusIcon(pos, iconPos) {
            if (!iconPos) return false;
            const iconSize = 20 / camera.scale;
            const radius = iconSize / 2;
            return Math.hypot(pos.x - iconPos.x, pos.y - iconPos.y) < radius * 1.5;
         }

         // Create a new linked shape (rect/circle) on a given side of the selected shape
         function createLinkedShapeOnSide(side) {
            if (!side) return false;
            if (selectedIndices.size !== 1) return false;

            const idx = selectedIndices.values().next().value;
            const shape = shapes[idx];
            if (
               !shape ||
               (shape.type !== "rect" &&
                  shape.type !== "circle" &&
                  shape.type !== "oval" &&
                  shape.type !== "rhombus" &&
                  shape.type !== "diamond")
            )
               return false;

            const offset = 60 / camera.scale; // Distance from original shape
            let newShapeX, newShapeY, newShapeW, newShapeH;
            let arrowStartX, arrowStartY, arrowEndX, arrowEndY;

            if (
               shape.type === "rect" ||
               shape.type === "rhombus" ||
               shape.type === "diamond" ||
               shape.type === "oval"
            ) {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);

               const newRectWidth = w;
               const newRectHeight = h;

               switch (side) {
                  case "top":
                     newShapeX = x + w / 2 - newRectWidth / 2;
                     newShapeY = y - offset - newRectHeight;
                     arrowStartX = x + w / 2;
                     arrowStartY = y;
                     arrowEndX = newShapeX + newRectWidth / 2;
                     arrowEndY = newShapeY + newRectHeight;
                     break;
                  case "right":
                     newShapeX = x + w + offset;
                     newShapeY = y + h / 2 - newRectHeight / 2;
                     arrowStartX = x + w;
                     arrowStartY = y + h / 2;
                     arrowEndX = newShapeX;
                     arrowEndY = newShapeY + newRectHeight / 2;
                     break;
                  case "bottom":
                     newShapeX = x + w / 2 - newRectWidth / 2;
                     newShapeY = y + h + offset;
                     arrowStartX = x + w / 2;
                     arrowStartY = y + h;
                     arrowEndX = newShapeX + newRectWidth / 2;
                     arrowEndY = newShapeY;
                     break;
                  case "left":
                     newShapeX = x - offset - newRectWidth;
                     newShapeY = y + h / 2 - newRectHeight / 2;
                     arrowStartX = x;
                     arrowStartY = y + h / 2;
                     arrowEndX = newShapeX + newRectWidth;
                     arrowEndY = newShapeY + newRectHeight / 2;
                     break;
                  default:
                     return false;
               }

               newShapeW = newRectWidth;
               newShapeH = newRectHeight;
            } else if (shape.type === "circle" || shape.type === "oval") {
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               const absW = Math.abs(shape.w);
               const absH = Math.abs(shape.h);
               const rx = absW / 2;
               const ry = absH / 2;

               let newCenterX = cx;
               let newCenterY = cy;

               switch (side) {
                  case "top":
                     newCenterX = cx;
                     newCenterY = cy - ry - offset - ry;
                     arrowStartX = cx;
                     arrowStartY = cy - ry;
                     arrowEndX = newCenterX;
                     arrowEndY = newCenterY + ry;
                     break;
                  case "right":
                     newCenterX = cx + rx + offset + rx;
                     newCenterY = cy;
                     arrowStartX = cx + rx;
                     arrowStartY = cy;
                     arrowEndX = newCenterX - rx;
                     arrowEndY = newCenterY;
                     break;
                  case "bottom":
                     newCenterX = cx;
                     newCenterY = cy + ry + offset + ry;
                     arrowStartX = cx;
                     arrowStartY = cy + ry;
                     arrowEndX = newCenterX;
                     arrowEndY = newCenterY - ry;
                     break;
                  case "left":
                     newCenterX = cx - rx - offset - rx;
                     newCenterY = cy;
                     arrowStartX = cx - rx;
                     arrowStartY = cy;
                     arrowEndX = newCenterX + rx;
                     arrowEndY = newCenterY;
                     break;
                  default:
                     return false;
               }

               newShapeX = newCenterX - rx;
               newShapeY = newCenterY - ry;
               // New circle should be identical size to original
               newShapeW = shape.w;
               newShapeH = shape.h;
            } else {
               return false;
            }

            const newShapeId = generateId();
            const newShape = {
               id: newShapeId,
               type: shape.type,
               x: newShapeX,
               y: newShapeY,
               w: newShapeW,
               h: newShapeH,
               color: shape.color || currentColor,
               fillColor: shape.fillColor || currentFillColor,
               width: shape.width || currentWidth,
            };

            shapes.push(newShape);
            const newShapeIndex = shapes.length - 1;

            const arrowId = generateId();
            const arrowMidX = (arrowStartX + arrowEndX) / 2;
            const arrowMidY = (arrowStartY + arrowEndY) / 2;
            const arrow = {
               id: arrowId,
               type: "arrow",
               start: { x: arrowStartX, y: arrowStartY },
               end: { x: arrowEndX, y: arrowEndY },
               control: { x: arrowMidX, y: arrowMidY },
               color: shape.color || currentColor,
               fillColor: shape.fillColor || currentFillColor,
               width: shape.width || currentWidth,
               startConnected: attachToShape({ x: arrowStartX, y: arrowStartY }, shape, idx),
               endConnected: attachToShape({ x: arrowEndX, y: arrowEndY }, newShape, newShapeIndex),
            };

            shapes.push(arrow);
            updateConnections();

            clearSelection();
            addToSelection(newShapeIndex);

            hoveredSide = null;
            hoveredRectIndex = null;

            saveHistory();
            render();
            return true;
         }

         // --- Interaction Logic ---

         function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches
               ? e.touches[0]
                  ? e.touches[0].clientX
                  : e.changedTouches[0].clientX
               : e.clientX;
            const clientY = e.touches
               ? e.touches[0]
                  ? e.touches[0].clientY
                  : e.changedTouches[0].clientY
               : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
         }

         function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
         }

         function onMouseDown(e) {
            if (isTyping || isFinishingText) return;

            const screenPos = getPointerPos(e);
            const pos = toWorld(screenPos.x, screenPos.y);

            // Middle button or Ctrl+Left click for Panning
            if (e.button === 1 || (e.ctrlKey && e.button === 0)) {
               camera.isPanning = true;
               startPos = screenPos; // Store screen pos for panning delta
               canvas.style.cursor = "grabbing";
               return;
            }

            // Block right-click (button 2) and middle-click (button 1) for drawing
            // Only allow left-click (button 0)
            if (e.button !== 0) {
               return;
            }

            if (currentTool === "arrow" && arrowCreationPhase === "bending") {
               shapes.push(currentShape);
               saveHistory();
               currentShape = null;
               arrowCreationPhase = "idle";
               render();
               return;
            }

            startPos = pos; // World start pos
            isDragging = true;

            // --- SELECT TOOL LOGIC ---
            if (currentTool === "select") {
               // 0. Check for plus icon click (create new rectangle/circle with arrow)
               if (selectedIndices.size === 1 && hoveredSide && hoveredRectIndex !== null) {
                  const idx = hoveredRectIndex;
                  const shape = shapes[idx];
                  const iconPos = getPlusIconPosition(shape, hoveredSide);

                  if (iconPos && isPointOnPlusIcon(pos, iconPos)) {
                     if (createLinkedShapeOnSide(hoveredSide)) {
                        isDragging = false;
                        return;
                     }
                     isDragging = false;
                     return;
                  }
               }

               // 1. Check Resizing Handles
               if (selectedIndices.size === 1) {
                  const idx = selectedIndices.values().next().value;
                  const handle = getHitHandle(pos, shapes[idx]);
                  if (handle) {
                     isManipulatingHandle = true;
                     activeHandle = handle;
                     initialShapeState = JSON.parse(JSON.stringify(shapes[idx]));
                     // Store world start pos for delta calculations during resize
                     startPos = pos;
                     return;
                  }
               }

               // 2. Check Hit on Shapes
               let hitIndex = -1;
               for (let i = shapes.length - 1; i >= 0; i--) {
                  if (isPointInShape(pos, shapes[i])) {
                     hitIndex = i;
                     break;
                  }
               }

               if (hitIndex !== -1) {
                  // ALT KEY LOGIC - Duplicate objects
                  if (e.altKey) {
                     // Ensure the clicked shape is selected
                     if (!selectedIndices.has(hitIndex)) {
                        selectedIndices.forEach((idx) => restoreConnectionsForShape(shapes[idx]));
                        clearSelection();
                        addToSelection(hitIndex);
                     }

                     // Duplicate all selected shapes
                     const duplicatedShapes = [];
                     const oldToNewIndexMap = new Map();

                     selectedIndices.forEach((idx) => {
                        const original = shapes[idx];
                        const duplicate = JSON.parse(
                           JSON.stringify(original, (key, value) => {
                              if (key === "image") return undefined; // Don't stringify Image objects
                              return value;
                           })
                        );

                        // Generate new ID for duplicate
                        duplicate.id = generateId();

                        // Re-hydrate image if needed
                        if (original.type === "image" && original.src) {
                           const img = new Image();
                           img.src = original.src;
                           duplicate.image = img;
                        }

                        duplicatedShapes.push(duplicate);
                        oldToNewIndexMap.set(idx, shapes.length + duplicatedShapes.length - 1);
                     });

                     // Add duplicates to shapes array
                     shapes.push(...duplicatedShapes);

                     // Update selection to the new duplicates
                     clearSelection();
                     for (let i = shapes.length - duplicatedShapes.length; i < shapes.length; i++) {
                        addToSelection(i);
                     }

                     // Start moving the duplicates
                     isDuplicating = true;
                     isMovingSelection = true;
                     moveOffset = pos;

                     // Temporarily break connections for duplicated shapes
                     selectedIndices.forEach((idx) => temporarilyBreakConnections(shapes[idx]));
                  }
                  // SHIFT KEY LOGIC
                  else if (e.shiftKey) {
                     if (selectedIndices.has(hitIndex)) {
                        removeFromSelection(hitIndex);
                        isMovingSelection = false;
                        // Restore connections if this shape was temporarily disconnected
                        restoreConnectionsForShape(shapes[hitIndex]);
                     } else {
                        addToSelection(hitIndex);
                        isMovingSelection = true;
                        moveOffset = pos;
                        // Temporarily break connections for shapes being moved
                        temporarilyBreakConnections(shapes[hitIndex]);
                     }
                  } else {
                     // Check if the hit shape is already in selection
                     const wasAlreadySelected = selectedIndices.has(hitIndex);

                     if (!wasAlreadySelected) {
                        // Restore connections for previously selected shapes
                        selectedIndices.forEach((idx) => restoreConnectionsForShape(shapes[idx]));
                        clearSelection();
                        addToSelection(hitIndex);
                     }

                     // Always allow moving when clicking on any shape (filled or not)
                     isMovingSelection = true;
                     moveOffset = pos;

                     // Temporarily break connections for all selected shapes
                     selectedIndices.forEach((idx) => temporarilyBreakConnections(shapes[idx]));
                  }
               } else {
                  if (!e.shiftKey) {
                     // Restore connections for previously selected shapes
                     selectedIndices.forEach((idx) => restoreConnectionsForShape(shapes[idx]));
                     clearSelection();
                  }
                  isBoxSelecting = true;
                  selectionBox = { start: pos, end: pos };
               }
               render();
            }
            // --- OTHER TOOLS ---
            else if (currentTool === "eraser") {
               handleEraser(pos);
            } else if (currentTool === "text") {
               createTextInput(pos.x, pos.y);
               isDragging = false;
            } else {
               clearSelection();
               const newId = generateId();
               let startConn = null;

               if (
                  currentTool === "line" ||
                  currentTool === "arrow" ||
                  currentTool === "pencil" ||
                  currentTool === "pencil-arrow"
               ) {
                  for (let i = shapes.length - 1; i >= 0; i--) {
                     if (isPointInShape(pos, shapes[i])) {
                        startConn = attachToShape(pos, shapes[i], i);
                        break;
                     }
                  }
               }

               // Hide shape recognition panel when starting a new drawing
               hideShapeRecognitionPanel();

               if (currentTool === "pencil") {
                  currentShape = {
                     id: newId,
                     type: "pencil",
                     points: [pos],
                     color: currentColor,
                     fillColor: currentFillColor,
                     width: currentWidth,
                     startConnected: startConn,
                  };
               } else if (currentTool === "pencil-arrow") {
                  currentShape = {
                     id: newId,
                     type: "pencil-arrow",
                     points: [pos],
                     color: currentColor,
                     fillColor: currentFillColor,
                     width: currentWidth,
                     startConnected: startConn,
                  };
               } else if (currentTool === "laser") {
                  currentShape = {
                     id: newId,
                     type: "laser",
                     points: [pos],
                     color: "#ff0000", // Pure red for laser
                     width: currentWidth,
                     createdAt: Date.now(),
                  };
               } else if (currentTool === "line") {
                  currentShape = {
                     id: newId,
                     type: "line",
                     start: pos,
                     end: pos,
                     color: currentColor,
                     fillColor: currentFillColor,
                     width: currentWidth,
                     startConnected: startConn,
                  };
               } else if (currentTool === "arrow") {
                  arrowCreationPhase = "drawing_line";
                  currentShape = {
                     id: newId,
                     type: "arrow",
                     start: pos,
                     end: pos,
                     control: pos,
                     color: currentColor,
                     fillColor: currentFillColor,
                     width: currentWidth,
                     startConnected: startConn,
                  };
               } else {
                  currentShape = {
                     id: newId,
                     type: currentTool,
                     x: pos.x,
                     y: pos.y,
                     w: 0,
                     h: 0,
                     color: currentColor,
                     fillColor: currentFillColor,
                     width: currentWidth,
                  };
               }
            }
         }

         function onMouseMove(e) {
            const screenPos = getPointerPos(e);
            const pos = toWorld(screenPos.x, screenPos.y);

            if (camera.isPanning) {
               const dx = screenPos.x - startPos.x;
               const dy = screenPos.y - startPos.y;
               camera.x += dx;
               camera.y += dy;
               startPos = screenPos;
               render();
               return;
            }

            if (currentTool === "arrow" && arrowCreationPhase === "bending" && currentShape) {
               currentShape.control = pos;
               render();
               return;
            }

            // Update cursor for resize handles when in select tool
            if (currentTool === "select" && !isDragging && selectedIndices.size === 1) {
               const idx = selectedIndices.values().next().value;
               const shape = shapes[idx];
               const handle = getHitHandle(pos, shape);

               if (handle) {
                  // Set appropriate cursor based on handle position
                  if (handle === "tl" || handle === "br") {
                     canvas.style.cursor = "nwse-resize";
                  } else if (handle === "tr" || handle === "bl") {
                     canvas.style.cursor = "nesw-resize";
                  } else if (handle === "top" || handle === "bottom") {
                     canvas.style.cursor = "ns-resize";
                  } else if (handle === "left" || handle === "right") {
                     canvas.style.cursor = "ew-resize";
                  } else if (handle === "start" || handle === "end" || handle === "control") {
                     canvas.style.cursor = "move";
                  }
                  // Reset hover state when over handle
                  hoveredSide = null;
                  hoveredRectIndex = null;
               } else {
                  // Check for hover over rectangle/circle sides, or near the existing plus icon
                  if (
                     shape &&
                     (shape.type === "rect" ||
                        shape.type === "circle" ||
                        shape.type === "oval" ||
                        shape.type === "rhombus" ||
                        shape.type === "diamond")
                  ) {
                     const side = detectHoveredSide(pos, shape);
                     if (side) {
                        // Fresh side hover – update state and show icon
                        hoveredSide = side;
                        hoveredRectIndex = idx;
                        canvas.style.cursor = "pointer";
                        render(); // Re-render to show plus icon
                     } else if (hoveredSide !== null && hoveredRectIndex === idx) {
                        // No side directly under cursor, but keep icon active while near it
                        const iconPos = getPlusIconPosition(shape, hoveredSide);
                        if (iconPos && isPointOnPlusIcon(pos, iconPos)) {
                           canvas.style.cursor = "pointer";
                           // Keep hoveredSide/hoveredRectIndex as-is so icon stays visible
                        } else {
                           hoveredSide = null;
                           hoveredRectIndex = null;
                           canvas.style.cursor = "default";
                           render(); // Re-render to hide plus icon
                        }
                     } else {
                        if (hoveredSide !== null || hoveredRectIndex !== null) {
                           hoveredSide = null;
                           hoveredRectIndex = null;
                           render(); // Re-render to hide plus icon
                        }
                        canvas.style.cursor = "default";
                     }
                  } else {
                     if (hoveredSide !== null || hoveredRectIndex !== null) {
                        hoveredSide = null;
                        hoveredRectIndex = null;
                        render(); // Re-render to hide plus icon
                     }
                     canvas.style.cursor = "default";
                  }
               }
            } else if (currentTool !== "select" || isDragging) {
               // Reset to default cursor for non-select tool or when dragging
               if (!isDragging && currentTool !== "select") {
                  updateCursor();
               }
               // Reset hover state when not in select tool or when dragging
               if (hoveredSide !== null || hoveredRectIndex !== null) {
                  hoveredSide = null;
                  hoveredRectIndex = null;
                  render();
               }
            } else {
               // Reset hover state when no selection
               if (hoveredSide !== null || hoveredRectIndex !== null) {
                  hoveredSide = null;
                  hoveredRectIndex = null;
                  render();
               }
            }

            if (!isDragging) return;
            e.preventDefault();

            if (currentTool === "select") {
               if (isManipulatingHandle) {
                  const idx = selectedIndices.values().next().value;
                  const shape = shapes[idx];
                  resizeShape(shape, initialShapeState, pos);
                  updateConnections();
               } else if (isMovingSelection) {
                  const dx = pos.x - moveOffset.x;
                  const dy = pos.y - moveOffset.y;
                  selectedIndices.forEach((idx) => moveShape(shapes[idx], dx, dy));
                  moveOffset = pos;
                  updateConnections();
               } else if (isBoxSelecting) {
                  selectionBox.end = pos;
               }
               render();
            } else if (currentTool === "eraser") {
               handleEraser(pos);
            } else if (currentShape) {
               if (currentTool === "arrow" && arrowCreationPhase === "drawing_line") {
                  currentShape.end = pos;
                  currentShape.control = {
                     x: (currentShape.start.x + pos.x) / 2,
                     y: (currentShape.start.y + pos.y) / 2,
                  };
               } else if (currentShape.type === "pencil" || currentShape.type === "pencil-arrow") {
                  const lastPt = currentShape.points[currentShape.points.length - 1];
                  if (lastPt) {
                     const dist = Math.hypot(pos.x - lastPt.x, pos.y - lastPt.y);
                     if (dist > 5 / camera.scale) {
                        currentShape.points.push(pos);
                     }
                  } else {
                     currentShape.points.push(pos);
                  }
               } else if (currentShape.type === "laser") {
                  const lastPt = currentShape.points[currentShape.points.length - 1];
                  if (lastPt) {
                     const dist = Math.hypot(pos.x - lastPt.x, pos.y - lastPt.y);
                     if (dist > 1 / camera.scale) {
                        currentShape.points.push(pos);
                        // Limit tail length for snake effect
                        if (currentShape.points.length > LASER_MAX_TAIL) {
                           currentShape.points.shift();
                        }
                     }
                  } else {
                     currentShape.points.push(pos);
                  }
               } else if (currentShape.type === "line") {
                  currentShape.end = pos;
               } else {
                  currentShape.w = pos.x - startPos.x;
                  currentShape.h = pos.y - startPos.y;
               }
               render();
            }
         }

         // --- Shape Detection & Conversion ---

         function detectShapeType(pencilShape) {
            if (!pencilShape.points || pencilShape.points.length < 4) {
               return null;
            }

            const points = pencilShape.points;
            const firstPt = points[0];
            const lastPt = points[points.length - 1];

            // Get bounding box first to calculate relative closure distance
            let minX = points[0].x,
               maxX = points[0].x;
            let minY = points[0].y,
               maxY = points[0].y;
            points.forEach((p) => {
               minX = Math.min(minX, p.x);
               maxX = Math.max(maxX, p.x);
               minY = Math.min(minY, p.y);
               maxY = Math.max(maxY, p.y);
            });

            const width = maxX - minX;
            const height = maxY - minY;
            const shapeSize = Math.max(width, height);

            // Check if shape is closed (first and last points are close)
            // Use relative distance based on shape size (more lenient for larger shapes)
            const closureDist = Math.hypot(lastPt.x - firstPt.x, lastPt.y - firstPt.y);
            const closureThreshold = Math.max(50, shapeSize * 0.1); // At least 50px or 10% of shape size
            const isClosedShape = closureDist < closureThreshold;
            if (!isClosedShape) return null;

            const centerX = minX + width / 2;
            const centerY = minY + height / 2;

            // Calculate average distance from center to determine if it's a circle
            let sumDistFromCenter = 0;
            points.forEach((p) => {
               sumDistFromCenter += Math.hypot(p.x - centerX, p.y - centerY);
            });
            const avgDistFromCenter = sumDistFromCenter / points.length;

            // Circle detection: variance in distance from center should be low
            let radiusVariance = 0;
            points.forEach((p) => {
               const dist = Math.hypot(p.x - centerX, p.y - centerY);
               radiusVariance += Math.pow(dist - avgDistFromCenter, 2);
            });
            radiusVariance = Math.sqrt(radiusVariance / points.length);
            const radiusVarianceRatio = radiusVariance / avgDistFromCenter;

            // Detect major direction changes (corners) using curvature
            const corners = [];
            // Use smaller step for better corner detection
            const step = Math.max(1, Math.floor(points.length / 80)); // More samples for better detection

            for (let i = step * 2; i < points.length - step * 2; i += step) {
               const prev = points[i - step * 2];
               const curr = points[i];
               const next = points[i + step * 2];

               const v1 = { x: curr.x - prev.x, y: curr.y - prev.y };
               const v2 = { x: next.x - curr.x, y: next.y - curr.y };

               const len1 = Math.hypot(v1.x, v1.y);
               const len2 = Math.hypot(v2.x, v2.y);

               if (len1 > 1 && len2 > 1) {
                  const norm1 = { x: v1.x / len1, y: v1.y / len1 };
                  const norm2 = { x: v2.x / len2, y: v2.y / len2 };
                  const dot = norm1.x * norm2.x + norm1.y * norm2.y;

                  // More sensitive corner detection: angle change > ~80 degrees (dot product < -0.1)
                  // This will catch more corners including softer ones
                  if (dot < -0.1) {
                     corners.push({ x: curr.x, y: curr.y, angle: dot });
                  }
               }
            }

            // Remove duplicate/adjacent corners (cluster them)
            const filteredCorners = [];
            const minCornerDistance = Math.max(10, Math.min(width, height) * 0.12); // At least 10px or 12% of smallest dimension

            corners.forEach((corner) => {
               let isNearExisting = false;
               for (let existing of filteredCorners) {
                  if (
                     Math.hypot(corner.x - existing.x, corner.y - existing.y) < minCornerDistance
                  ) {
                     isNearExisting = true;
                     break;
                  }
               }
               if (!isNearExisting) {
                  filteredCorners.push(corner);
               }
            });

            const cornerCount = filteredCorners.length;

            // Determine shape type based on detection criteria
            // Circle detection takes priority (lowest variance)
            if (radiusVarianceRatio < 0.12) {
               return { type: "circle", confidence: 0.9 };
            }

            // Rectangle detection: improved algorithm
            // Check if points are mostly aligned to form a rectangle
            const edgeThreshold = Math.max(10, Math.min(width, height) * 0.2); // At least 10px or 20% of smallest dimension
            let pointsNearEdges = 0;

            points.forEach((p) => {
               const distToLeft = Math.abs(p.x - minX);
               const distToRight = Math.abs(p.x - maxX);
               const distToTop = Math.abs(p.y - minY);
               const distToBottom = Math.abs(p.y - maxY);

               // Check if point is near any edge of the bounding box
               if (
                  distToLeft < edgeThreshold ||
                  distToRight < edgeThreshold ||
                  distToTop < edgeThreshold ||
                  distToBottom < edgeThreshold
               ) {
                  pointsNearEdges++;
               }
            });

            const edgeAlignmentRatio = pointsNearEdges / points.length;
            const aspectRatio = Math.max(width, height) / Math.min(width, height);

            // Rectangle detection: More lenient criteria
            // - Should have 2-8 corners (very forgiving for messy drawings)
            // - At least 50% of points should be near the edges (lowered from 60%)
            // - Aspect ratio should be reasonable (not too extreme)
            // - Shape should have reasonable size (not too small)
            const minSize = 20; // Minimum size for a valid rectangle
            if (
               shapeSize >= minSize &&
               cornerCount >= 2 &&
               cornerCount <= 8 &&
               edgeAlignmentRatio >= 0.5 &&
               aspectRatio < 10.0
            ) {
               // Higher confidence for 4 corners
               if (cornerCount === 4) {
                  return { type: "rectangle", confidence: 0.95 };
               } else if (cornerCount === 3 || cornerCount === 5) {
                  return { type: "rectangle", confidence: 0.85 };
               } else if (cornerCount === 2 || cornerCount === 6) {
                  return { type: "rectangle", confidence: 0.75 };
               } else {
                  // Even with 7-8 corners, if edges align well, it's likely a rectangle
                  return { type: "rectangle", confidence: 0.65 };
               }
            }

            // Alternative rectangle detection: if edge alignment is very high,
            // it's likely a rectangle even with fewer corners
            if (
               shapeSize >= minSize &&
               edgeAlignmentRatio >= 0.7 &&
               aspectRatio < 10.0 &&
               cornerCount >= 0
            ) {
               return { type: "rectangle", confidence: 0.8 };
            }

            return null;
         }

         function convertPencilToShape(pencilShape, detectedShape) {
            const points = pencilShape.points;
            let minX = points[0].x,
               maxX = points[0].x;
            let minY = points[0].y,
               maxY = points[0].y;
            points.forEach((p) => {
               minX = Math.min(minX, p.x);
               maxX = Math.max(maxX, p.x);
               minY = Math.min(minY, p.y);
               maxY = Math.max(maxY, p.y);
            });

            const width = maxX - minX;
            const height = maxY - minY;

            // Map detected shape type to actual shape type used in rendering
            const shapeTypeMap = {
               rectangle: "rect",
               circle: "circle",
               triangle: "triangle",
            };
            const mappedType = shapeTypeMap[detectedShape.type] || detectedShape.type;

            const newShape = {
               id: generateId(),
               type: mappedType,
               x: minX,
               y: minY,
               w: width,
               h: height,
               color: pencilShape.color,
               fillColor: "transparent",
               width: pencilShape.width,
               startConnected: pencilShape.startConnected,
               endConnected: pencilShape.endConnected,
            };

            return newShape;
         }

         function showShapeConversionPrompt(pencilShape, detectedShape) {
            // Create a modal for shape conversion
            const overlay = document.createElement("div");
            overlay.id = "conversion-overlay";
            overlay.style.cssText = `
               position: fixed;
               top: 0;
               left: 0;
               width: 100%;
               height: 100%;
               background: rgba(0, 0, 0, 0.5);
               display: flex;
               align-items: center;
               justify-content: center;
               z-index: 999;
            `;

            const modal = document.createElement("div");
            modal.style.cssText = `
               background: white;
               padding: 24px;
               border-radius: 12px;
               box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
               max-width: 400px;
               text-align: center;
               font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            `;

            const shapeNameMap = {
               circle: "Circle",
               rectangle: "Rectangle",
               triangle: "Triangle",
            };

            const title = document.createElement("h2");
            title.textContent = "Convert to Shape?";
            title.style.cssText = "margin: 0 0 12px 0; font-size: 20px; color: #1f2937;";
            modal.appendChild(title);

            const message = document.createElement("p");
            message.textContent = `Looks like you drew a ${
               shapeNameMap[detectedShape.type]
            }! Would you like to convert it to a shape?`;
            message.style.cssText =
               "margin: 0 0 20px 0; font-size: 14px; color: #6b7280; line-height: 1.5;";
            modal.appendChild(message);

            const confidence = document.createElement("p");
            confidence.textContent = `Confidence: ${Math.round(detectedShape.confidence * 100)}%`;
            confidence.style.cssText = "margin: 0 0 20px 0; font-size: 12px; color: #9ca3af;";
            modal.appendChild(confidence);

            const buttonContainer = document.createElement("div");
            buttonContainer.style.cssText = "display: flex; gap: 12px; justify-content: center;";

            const cancelBtn = document.createElement("button");
            cancelBtn.textContent = "Keep as Drawing";
            cancelBtn.style.cssText = `
               padding: 8px 16px;
               border: 1px solid #d1d5db;
               background: white;
               border-radius: 6px;
               cursor: pointer;
               font-size: 14px;
               color: #6b7280;
               transition: all 0.2s;
            `;
            cancelBtn.onmouseover = () => (cancelBtn.style.background = "#f9fafb");
            cancelBtn.onmouseout = () => (cancelBtn.style.background = "white");
            cancelBtn.onclick = () => {
               overlay.remove();
            };
            buttonContainer.appendChild(cancelBtn);

            const convertBtn = document.createElement("button");
            convertBtn.textContent = "Convert";
            convertBtn.style.cssText = `
               padding: 8px 16px;
               border: none;
               background: #3b82f6;
               color: white;
               border-radius: 6px;
               cursor: pointer;
               font-size: 14px;
               font-weight: 600;
               transition: all 0.2s;
            `;
            convertBtn.onmouseover = () => (convertBtn.style.background = "#2563eb");
            convertBtn.onmouseout = () => (convertBtn.style.background = "#3b82f6");
            convertBtn.onclick = () => {
               // Remove the pencil shape from shapes array
               const pencilIndex = shapes.indexOf(pencilShape);
               if (pencilIndex > -1) {
                  shapes.splice(pencilIndex, 1);
               }

               // Add the converted shape
               const newShape = convertPencilToShape(pencilShape, detectedShape);
               shapes.push(newShape);

               // Update selection
               clearSelection();
               addToSelection(shapes.length - 1);

               // Save history and render
               saveHistory();
               render();
               showToast(`Converted to ${shapeNameMap[detectedShape.type]}`);
               overlay.remove();
            };
            buttonContainer.appendChild(convertBtn);

            modal.appendChild(buttonContainer);
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
         }

         function onMouseUp(e) {
            if (camera.isPanning) {
               camera.isPanning = false;
               updateCursor();
               return;
            }

            if (!isDragging) return;
            isDragging = false;

            const screenPos = getPointerPos(e);
            const pos = toWorld(screenPos.x, screenPos.y);

            if (isBoxSelecting) {
               finishBoxSelection();
               isBoxSelecting = false;
               render();
            } else if (isMovingSelection || isManipulatingHandle) {
               // Re-evaluate connections for moved shapes
               if (isMovingSelection) {
                  selectedIndices.forEach((idx) => {
                     const shape = shapes[idx];
                     reEvaluateConnections(shape);
                  });

                  // Show toast if we just duplicated
                  if (isDuplicating) {
                     const count = selectedIndices.size;
                     showToast(`Duplicated ${count} object${count !== 1 ? "s" : ""}`);
                     isDuplicating = false;
                  }
               }
               saveHistory();
               isMovingSelection = false;
               isManipulatingHandle = false;
               activeHandle = null;
            }

            if (currentShape) {
               if (currentTool === "arrow" && arrowCreationPhase === "drawing_line") {
                  const pos = getPointerPos(e);
                  for (let i = shapes.length - 1; i >= 0; i--) {
                     if (isPointInShape(pos, shapes[i])) {
                        currentShape.endConnected = attachToShape(pos, shapes[i], i);
                        break;
                     }
                  }
                  arrowCreationPhase = "bending";
                  return;
               }

               if (
                  currentTool === "line" ||
                  currentTool === "pencil" ||
                  currentTool === "pencil-arrow"
               ) {
                  const pos = getPointerPos(e);
                  for (let i = shapes.length - 1; i >= 0; i--) {
                     if (isPointInShape(pos, shapes[i])) {
                        currentShape.endConnected = attachToShape(pos, shapes[i], i);
                        break;
                     }
                  }
               }

               const isTiny =
                  currentShape.type === "pencil" || currentShape.type === "pencil-arrow"
                     ? currentShape.points.length < 2
                     : currentShape.type === "laser"
                     ? currentShape.points.length < 2
                     : currentShape.type === "line"
                     ? Math.hypot(
                          currentShape.end.x - currentShape.start.x,
                          currentShape.end.y - currentShape.start.y
                       ) < 5
                     : Math.abs(currentShape.w) < 5 && Math.abs(currentShape.h) < 5;
               if (!isTiny) {
                  // Laser shapes are temporary and auto-delete
                  if (currentShape.type === "laser") {
                     const laserShape = currentShape; // Capture reference for closure
                     laserShape.deletedCount = 0; // Track how many points have been deleted
                     laserShapes.push(laserShape);

                     // Fade out from tail to head
                     const startTime = Date.now();
                     const fadeInterval = setInterval(() => {
                        const elapsed = Date.now() - startTime;

                        if (elapsed >= LASER_LIFETIME) {
                           // Complete deletion
                           const index = laserShapes.indexOf(laserShape);
                           if (index > -1) {
                              laserShapes.splice(index, 1);
                           }
                           clearInterval(fadeInterval);
                           render();
                        } else if (elapsed > LASER_DELETE_DELAY) {
                           // Start deletion after delay
                           const deleteElapsed = elapsed - LASER_DELETE_DELAY;
                           const deleteProgress = Math.min(
                              1,
                              deleteElapsed / LASER_DELETE_DURATION
                           );

                           // Gradually delete from start (tail) toward end (head)
                           const pointsToDelete = Math.floor(
                              laserShape.points.length * deleteProgress
                           );
                           laserShape.deletedCount = pointsToDelete;

                           // Also gradually reduce opacity after deletion starts
                           laserShape.tailOpacity = 1 - deleteProgress;
                           render();
                        } else {
                           // Before delay - just render fully opaque
                           laserShape.deletedCount = 0;
                           laserShape.tailOpacity = 1;
                           render();
                        }
                     }, 16); // ~60fps
                     // Don't save to history or shapes array
                  } else {
                     // Check if pencil shape looks like a closed shape
                     if (currentShape.type === "pencil" || currentShape.type === "pencil-arrow") {
                        const detectedShape = detectShapeType(currentShape);
                        if (detectedShape) {
                           // Convert and show undo panel
                           const newShape = convertPencilToShape(currentShape, detectedShape);
                           shapes.push(newShape);
                           const convertedIndex = shapes.length - 1;
                           clearSelection();
                           addToSelection(convertedIndex);
                           saveHistory();
                           render();

                           // Show the undo panel with the original shape
                           showShapeRecognitionPanel(currentShape, convertedIndex);
                        } else {
                           // No shape detected, keep as pencil drawing
                           shapes.push(currentShape);
                           saveHistory();
                        }
                     } else {
                        shapes.push(currentShape);
                        // Keep pencil and pencil-arrow tools active for continuous drawing
                        // Don't switch tool, don't select - just continue drawing
                        clearSelection();
                        selectedIndices.add(shapes.length - 1);
                        setTool("select", true); // Switch tool while keeping the new selection
                        saveHistory();
                     }
                  }
               }
               currentShape = null;
               render();
            }
         }

         // --- Connection Logic ---

         function temporarilyBreakConnections(shape) {
            if (
               !shape ||
               (shape.type !== "arrow" &&
                  shape.type !== "line" &&
                  shape.type !== "pencil" &&
                  shape.type !== "pencil-arrow")
            ) {
               return;
            }
            if (!temporarilyDisconnectedShapes.has(shape.id)) {
               // Store the connections before breaking them
               temporarilyDisconnectedShapes.set(shape.id, {
                  startConnected: shape.startConnected,
                  endConnected: shape.endConnected,
               });
               // Actually break the connections so the shape can move freely
               shape.startConnected = null;
               shape.endConnected = null;
            }
         }

         function restoreConnectionsForShape(shape) {
            if (!shape) return;
            const stored = temporarilyDisconnectedShapes.get(shape.id);
            if (stored) {
               shape.startConnected = stored.startConnected;
               shape.endConnected = stored.endConnected;
               temporarilyDisconnectedShapes.delete(shape.id);
            }
         }

         function reEvaluateConnections(shape) {
            if (
               !shape ||
               (shape.type !== "arrow" &&
                  shape.type !== "line" &&
                  shape.type !== "pencil" &&
                  shape.type !== "pencil-arrow")
            ) {
               return;
            }

            // Check if start point is near a shape
            let startPos, endPos;
            if (shape.type === "pencil" || shape.type === "pencil-arrow") {
               if (shape.points.length === 0) return;
               startPos = shape.points[0];
               endPos = shape.points[shape.points.length - 1];
            } else {
               startPos = shape.start;
               endPos = shape.end;
            }

            // Check for start connection
            let foundStart = false;
            for (let i = shapes.length - 1; i >= 0; i--) {
               if (shapes[i].id === shape.id) continue;
               if (isPointInShape(startPos, shapes[i])) {
                  shape.startConnected = attachToShape(startPos, shapes[i], i);
                  foundStart = true;
                  break;
               }
            }
            if (!foundStart) {
               shape.startConnected = null;
            }

            // Check for end connection
            let foundEnd = false;
            for (let i = shapes.length - 1; i >= 0; i--) {
               if (shapes[i].id === shape.id) continue;
               if (isPointInShape(endPos, shapes[i])) {
                  shape.endConnected = attachToShape(endPos, shapes[i], i);
                  foundEnd = true;
                  break;
               }
            }
            if (!foundEnd) {
               shape.endConnected = null;
            }

            // Remove from temporarily disconnected list
            temporarilyDisconnectedShapes.delete(shape.id);
         }

         function attachToShape(pos, shape, index) {
            const b = getBoundingBox(shape);
            const u = (pos.x - b.x) / Math.max(1, b.w);
            const v = (pos.y - b.y) / Math.max(1, b.h);
            return { id: shape.id, u, v };
         }

         // Helper function to get optimal edge connection point on a shape
         // given a direction point (typically the center of the other connected shape)
         function getEdgeConnectionPoint(shape, directionX, directionY) {
            const b = getBoundingBox(shape);
            const centerX = b.x + b.w / 2;
            const centerY = b.y + b.h / 2;

            // Calculate direction from shape center to the target point
            const dx = directionX - centerX;
            const dy = directionY - centerY;

            if (shape.type === "circle") {
               // For circles, find the point on the ellipse edge
               const rx = b.w / 2;
               const ry = b.h / 2;

               if (dx === 0 && dy === 0) {
                  // Default to right edge if centers overlap
                  return { x: centerX + rx, y: centerY };
               }

               // Normalize and scale to ellipse edge
               const angle = Math.atan2(dy, dx);
               return {
                  x: centerX + rx * Math.cos(angle),
                  y: centerY + ry * Math.sin(angle),
               };
            } else {
               // For rectangles and other shapes, find the edge intersection
               if (dx === 0 && dy === 0) {
                  // Default to right edge if centers overlap
                  return { x: b.x + b.w, y: centerY };
               }

               // Calculate intersection with rectangle edges
               let t = Infinity;
               let edgePoint = { x: centerX, y: centerY };

               // Check each edge
               // Right edge (x = b.x + b.w)
               if (dx > 0) {
                  const tRight = (b.x + b.w - centerX) / dx;
                  const yIntersect = centerY + tRight * dy;
                  if (yIntersect >= b.y && yIntersect <= b.y + b.h && tRight < t) {
                     t = tRight;
                     edgePoint = { x: b.x + b.w, y: yIntersect };
                  }
               }
               // Left edge (x = b.x)
               if (dx < 0) {
                  const tLeft = (b.x - centerX) / dx;
                  const yIntersect = centerY + tLeft * dy;
                  if (yIntersect >= b.y && yIntersect <= b.y + b.h && tLeft < t) {
                     t = tLeft;
                     edgePoint = { x: b.x, y: yIntersect };
                  }
               }
               // Bottom edge (y = b.y + b.h)
               if (dy > 0) {
                  const tBottom = (b.y + b.h - centerY) / dy;
                  const xIntersect = centerX + tBottom * dx;
                  if (xIntersect >= b.x && xIntersect <= b.x + b.w && tBottom < t) {
                     t = tBottom;
                     edgePoint = { x: xIntersect, y: b.y + b.h };
                  }
               }
               // Top edge (y = b.y)
               if (dy < 0) {
                  const tTop = (b.y - centerY) / dy;
                  const xIntersect = centerX + tTop * dx;
                  if (xIntersect >= b.x && xIntersect <= b.x + b.w && tTop < t) {
                     t = tTop;
                     edgePoint = { x: xIntersect, y: b.y };
                  }
               }

               return edgePoint;
            }
         }

         function updateConnections() {
            const shapeMap = new Map();
            shapes.forEach((s) => shapeMap.set(s.id, s));

            shapes.forEach((shape) => {
               // Skip updating connections for shapes that are temporarily disconnected (being moved)
               if (temporarilyDisconnectedShapes.has(shape.id)) {
                  return;
               }

               if (
                  shape.type === "line" ||
                  shape.type === "arrow" ||
                  shape.type === "pencil" ||
                  shape.type === "pencil-arrow"
               ) {
                  // Get both connected shapes first
                  const startTarget = shape.startConnected
                     ? shapeMap.get(shape.startConnected.id)
                     : null;
                  const endTarget = shape.endConnected ? shapeMap.get(shape.endConnected.id) : null;

                  // Calculate optimal connection points
                  let startPoint = null;
                  let endPoint = null;

                  if (startTarget && endTarget) {
                     // Both ends connected to shapes - always use center-to-center for edge calculation
                     const startBox = getBoundingBox(startTarget);
                     const endBox = getBoundingBox(endTarget);
                     const startCenterX = startBox.x + startBox.w / 2;
                     const startCenterY = startBox.y + startBox.h / 2;
                     const endCenterX = endBox.x + endBox.w / 2;
                     const endCenterY = endBox.y + endBox.h / 2;

                     // Always use center-to-center direction for edge connection points
                     // This ensures edges update correctly when shapes swap positions
                     startPoint = getEdgeConnectionPoint(startTarget, endCenterX, endCenterY);
                     endPoint = getEdgeConnectionPoint(endTarget, startCenterX, startCenterY);
                  } else if (startTarget) {
                     // Only start connected - use control point or end point as direction
                     let directionPos;
                     if (shape.type === "pencil" || shape.type === "pencil-arrow") {
                        directionPos = shape.points[shape.points.length - 1];
                     } else if (shape.type === "arrow" && shape.control) {
                        // For curved arrows, start should point towards control
                        directionPos = shape.control;
                     } else {
                        directionPos = shape.end;
                     }
                     startPoint = getEdgeConnectionPoint(
                        startTarget,
                        directionPos.x,
                        directionPos.y
                     );
                  } else if (endTarget) {
                     // Only end connected - use control point or start point as direction
                     let directionPos;
                     if (shape.type === "pencil" || shape.type === "pencil-arrow") {
                        directionPos = shape.points[0];
                     } else if (shape.type === "arrow" && shape.control) {
                        // For curved arrows, end should point towards control
                        directionPos = shape.control;
                     } else {
                        directionPos = shape.start;
                     }
                     endPoint = getEdgeConnectionPoint(endTarget, directionPos.x, directionPos.y);
                  }

                  // Apply the calculated connection points
                  if (startPoint && startTarget) {
                     if (shape.type === "pencil" || shape.type === "pencil-arrow") {
                        const dx = startPoint.x - shape.points[0].x;
                        const dy = startPoint.y - shape.points[0].y;
                        const range = Math.min(shape.points.length, 12);
                        for (let i = 0; i < range; i++) {
                           const influence = 1 - i / range;
                           shape.points[i].x += dx * influence;
                           shape.points[i].y += dy * influence;
                        }
                     } else {
                        shape.start.x = startPoint.x;
                        shape.start.y = startPoint.y;
                     }

                     // Update stored u,v values
                     const b = getBoundingBox(startTarget);
                     shape.startConnected.u = (startPoint.x - b.x) / Math.max(1, b.w);
                     shape.startConnected.v = (startPoint.y - b.y) / Math.max(1, b.h);
                  } else if (shape.startConnected && !startTarget) {
                     shape.startConnected = null;
                  }

                  if (endPoint && endTarget) {
                     if (shape.type === "pencil" || shape.type === "pencil-arrow") {
                        const last = shape.points.length - 1;
                        const dx = endPoint.x - shape.points[last].x;
                        const dy = endPoint.y - shape.points[last].y;
                        const range = Math.min(shape.points.length, 12);
                        for (let i = 0; i < range; i++) {
                           const idx = last - i;
                           const influence = 1 - i / range;
                           shape.points[idx].x += dx * influence;
                           shape.points[idx].y += dy * influence;
                        }
                     } else {
                        shape.end.x = endPoint.x;
                        shape.end.y = endPoint.y;
                     }

                     // Update stored u,v values
                     const b = getBoundingBox(endTarget);
                     shape.endConnected.u = (endPoint.x - b.x) / Math.max(1, b.w);
                     shape.endConnected.v = (endPoint.y - b.y) / Math.max(1, b.h);
                  } else if (shape.endConnected && !endTarget) {
                     shape.endConnected = null;
                  }

                  // Update control point for arrows when both ends are connected
                  // This keeps the curve properly centered between the shapes
                  if (
                     shape.type === "arrow" &&
                     shape.control &&
                     startPoint &&
                     endPoint &&
                     startTarget &&
                     endTarget
                  ) {
                     shape.control.x = (startPoint.x + endPoint.x) / 2;
                     shape.control.y = (startPoint.y + endPoint.y) / 2;
                  }
               }
            });
         }

         // --- Alignment Logic ---

         function alignSelected(mode) {
            if (selectedIndices.size < 2) return;

            // Get the LAST selected object as the anchor (reference point)
            // Use explicit selectionQueue to guarantee chronological order
            // Fallback to Array.from(selectedIndices) if queue is empty (e.g. legacy selection)
            let anchorIdx;
            if (selectionQueue.length > 0) {
               anchorIdx = selectionQueue[selectionQueue.length - 1];
            } else {
               const indices = Array.from(selectedIndices);
               anchorIdx = indices[indices.length - 1];
            }
            const anchorShape = shapes[anchorIdx];
            const anchorBox = getBoundingBox(anchorShape);
            const anchorX = Math.min(anchorBox.x, anchorBox.x + anchorBox.w);
            const anchorY = Math.min(anchorBox.y, anchorBox.y + anchorBox.h);
            const anchorW = Math.abs(anchorBox.w);
            const anchorH = Math.abs(anchorBox.h);

            // Calculate reference positions from the anchor object
            let refLeft = anchorX;
            let refRight = anchorX + anchorW;
            let refTop = anchorY;
            let refBottom = anchorY + anchorH;
            let refCenterH = anchorX + anchorW / 2;
            let refMiddleV = anchorY + anchorH / 2;

            // Align all other objects to the anchor
            selectedIndices.forEach((idx) => {
               // Skip the anchor object itself
               if (idx === anchorIdx) return;

               const shape = shapes[idx];
               const b = getBoundingBox(shape);
               const bx = Math.min(b.x, b.x + b.w);
               const by = Math.min(b.y, b.y + b.h);
               const bw = Math.abs(b.w);
               const bh = Math.abs(b.h);

               let dx = 0;
               let dy = 0;

               if (mode === "left") dx = refLeft - bx;
               else if (mode === "center-h") dy = refMiddleV - (by + bh / 2);
               else if (mode === "right") dx = refRight - (bx + bw);
               else if (mode === "top") dy = refTop - by;
               else if (mode === "middle-v") dx = refCenterH - (bx + bw / 2);
               else if (mode === "bottom") dy = refBottom - (by + bh);

               moveShape(shape, dx, dy);
            });

            updateConnections();
            render();
            saveHistory();
         }

         // --- Helper: Movement & Resizing ---

         function moveShape(shape, dx, dy) {
            if (shape.type === "pencil" || shape.type === "pencil-arrow") {
               shape.points.forEach((p) => {
                  p.x += dx;
                  p.y += dy;
               });
            } else if (shape.type === "line" || shape.type === "arrow") {
               shape.start.x += dx;
               shape.start.y += dy;
               shape.end.x += dx;
               shape.end.y += dy;
               if (shape.control) {
                  shape.control.x += dx;
                  shape.control.y += dy;
               }
            } else {
               shape.x += dx;
               shape.y += dy;
            }
         }

         function resizeShape(shape, init, pos) {
            if (shape.type === "arrow" || shape.type === "line") {
               if (activeHandle === "start") shape.start = pos;
               else if (activeHandle === "end") shape.end = pos;
               else if (activeHandle === "control") shape.control = pos;
               return;
            }

            let initX = init.x;
            let initY = init.y;
            let initW = init.w;
            let initH = init.h;

            if (
               shape.type === "text" ||
               shape.type === "pencil" ||
               shape.type === "pencil-arrow" ||
               shape.type === "image"
            ) {
               const b = getBoundingBox(init);
               initX = b.x;
               initY = b.y;
               initW = b.w;
               initH = b.h;
            }

            const dx = pos.x - startPos.x;
            const dy = pos.y - startPos.y;

            let newX = initX,
               newY = initY,
               newW = initW,
               newH = initH;

            if (activeHandle === "br") {
               newW = initW + dx;
               newH = initH + dy;
            } else if (activeHandle === "bl") {
               newX = initX + dx;
               newW = initW - dx;
               newH = initH + dy;
            } else if (activeHandle === "tr") {
               newY = initY + dy;
               newW = initW + dx;
               newH = initH - dy;
            } else if (activeHandle === "tl") {
               newX = initX + dx;
               newY = initY + dy;
               newW = initW - dx;
               newH = initH - dy;
            } else if (activeHandle === "top") {
               // Top side: resize height from top
               newY = initY + dy;
               newH = initH - dy;
            } else if (activeHandle === "bottom") {
               // Bottom side: resize height from bottom
               newH = initH + dy;
            } else if (activeHandle === "left") {
               // Left side: resize width from left
               newX = initX + dx;
               newW = initW - dx;
            } else if (activeHandle === "right") {
               // Right side: resize width from right
               newW = initW + dx;
            }

            if (shape.type === "text") {
               if (newH < 5) {
                  newH = 5;
                  if (activeHandle.includes("t")) newY = initY + initH - 5;
               }
               shape.size = Math.abs(newH);
               shape.x = newX;
               shape.y = newY;
            } else if (shape.type === "pencil" || shape.type === "pencil-arrow") {
               const scaleX = initW === 0 ? 1 : newW / initW;
               const scaleY = initH === 0 ? 1 : newH / initH;

               shape.points = init.points.map((p) => ({
                  x: newX + (p.x - initX) * scaleX,
                  y: newY + (p.y - initY) * scaleY,
               }));
            } else if (shape.type === "image") {
               // Maintain aspect ratio when resizing
               if (shape.aspectRatio) {
                  if (activeHandle === "br") {
                     // Bottom-right: expand both dimensions
                     newH = newW / shape.aspectRatio;
                  } else if (activeHandle === "bl") {
                     // Bottom-left: maintain ratio with height change
                     newH = (initW - dx) / shape.aspectRatio;
                     newW = initW - dx;
                     newX = initX + dx;
                  } else if (activeHandle === "tr") {
                     // Top-right: maintain ratio with width change
                     newH = newW / shape.aspectRatio;
                     newY = initY + initH - newH;
                  } else if (activeHandle === "tl") {
                     // Top-left: maintain ratio with width change
                     newW = initW - dx;
                     newH = newW / shape.aspectRatio;
                     newX = initX + dx;
                     newY = initY + initH - newH;
                  } else if (activeHandle === "top" || activeHandle === "bottom") {
                     // Top/Bottom side: maintain aspect ratio with height change
                     newW = Math.abs(newH * shape.aspectRatio);
                     const centerX = initX + initW / 2;
                     newX = centerX - newW / 2;
                  } else if (activeHandle === "left" || activeHandle === "right") {
                     // Left/Right side: maintain aspect ratio with width change
                     newH = Math.abs(newW / shape.aspectRatio);
                     const centerY = initY + initH / 2;
                     newY = centerY - newH / 2;
                  }
               }
               shape.x = newX;
               shape.y = newY;
               shape.w = newW;
               shape.h = newH;
            } else {
               shape.x = newX;
               shape.y = newY;
               shape.w = newW;
               shape.h = newH;
            }
         }

         function finishBoxSelection() {
            if (!selectionBox) return;
            const x1 = Math.min(selectionBox.start.x, selectionBox.end.x);
            const x2 = Math.max(selectionBox.start.x, selectionBox.end.x);
            const y1 = Math.min(selectionBox.start.y, selectionBox.end.y);
            const y2 = Math.max(selectionBox.start.y, selectionBox.end.y);

            shapes.forEach((shape, index) => {
               const b = getBoundingBox(shape);
               const bx = Math.min(b.x, b.x + b.w);
               const by = Math.min(b.y, b.y + b.h);
               const bw = Math.abs(b.w);
               const bh = Math.abs(b.h);

               if (bx < x2 && bx + bw > x1 && by < y2 && by + bh > y1) {
                  addToSelection(index);
               }
            });
            selectionBox = null;
         }

         // --- Text Tool ---

         function createTextInput(x, y, text = "", size = null, color = null) {
            if (activeInput) cleanupInput();

            isTyping = true;
            const input = document.createElement("input");
            input.type = "text";
            input.id = "text-input";

            // Transform world coordinates to screen coordinates for the HTML element
            const screenPos = toScreen(x, y);
            input.style.left = screenPos.x + "px";
            input.style.top = screenPos.y + "px";

            const useColor = color || currentColor;
            const useSize = size || currentWidth * 5 + 10;
            const displaySize = useSize * camera.scale;

            input.style.color = useColor;
            input.style.fontSize = displaySize + "px";
            input.style.lineHeight = "1";
            input.value = text;

            document.body.appendChild(input);

            // Function to update input width based on text content
            const updateInputWidth = () => {
               // Create a temporary span to measure text width
               const measureSpan = document.createElement("span");
               measureSpan.style.font = `bold ${displaySize}px 'Caveat', cursive`;
               measureSpan.style.visibility = "hidden";
               measureSpan.style.position = "absolute";
               measureSpan.style.whiteSpace = "pre";
               measureSpan.textContent = input.value || " ";
               document.body.appendChild(measureSpan);

               const textWidth = measureSpan.offsetWidth;
               document.body.removeChild(measureSpan);

               // Set input width with some padding (add 10px for cursor and breathing room)
               input.style.width = Math.max(50, textWidth + 10) + "px";
            };

            // Update width initially
            updateInputWidth();

            // Update width as user types
            input.addEventListener("input", updateInputWidth);

            setTimeout(() => {
               input.focus();
               if (text) input.select();
            }, 10);
            activeInput = input;

            const finish = () => {
               if (!activeInput) return;

               if (input.value.trim() !== "") {
                  shapes.push({
                     id: generateId(),
                     type: "text",
                     x: x,
                     y: y,
                     text: input.value,
                     size: useSize,
                     color: useColor,
                     fillColor: currentFillColor,
                     width: 1,
                  });
                  clearSelection();
                  addToSelection(shapes.length - 1);
                  setTool("select", true);
                  saveHistory();
                  render();
               }
               cleanupInput();
            };

            input.addEventListener("keydown", (e) => {
               if (e.key === "Enter") finish();
            });
            input.addEventListener("blur", finish);
         }

         function cleanupInput() {
            if (activeInput) {
               activeInput.remove();
               activeInput = null;
            }
            isTyping = false;
            isFinishingText = true;
            setTimeout(() => {
               isFinishingText = false;
            }, 200);
         }

         function createTextInputForShape(
            x,
            y,
            text = "",
            size = null,
            color = null,
            shapeIndex = -1
         ) {
            if (activeInput) cleanupInput();

            // Mark the shape as being edited
            if (shapeIndex >= 0 && shapeIndex < shapes.length) {
               shapes[shapeIndex].isEditingText = true;
               render(); // Redraw without the old text
            }

            isTyping = true;
            const input = document.createElement("input");
            input.type = "text";
            input.id = "text-input";

            // Transform world coordinates to screen coordinates for the HTML element
            const screenPos = toScreen(x, y);

            const useColor = color || currentColor;
            const useSize = size || currentWidth * 5 + 10;
            const displaySize = useSize * camera.scale;

            input.style.color = useColor;
            input.style.fontSize = displaySize + "px";
            input.style.lineHeight = "1";
            input.style.textAlign = "center";
            input.value = text;

            // Position the input centered
            input.style.left = screenPos.x + "px";
            input.style.top = screenPos.y + "px";
            input.style.transform = "translate(-50%, -50%)";

            document.body.appendChild(input);

            // Function to update input width based on text content
            const updateInputWidth = () => {
               // Create a temporary span to measure text width
               const measureSpan = document.createElement("span");
               measureSpan.style.font = `bold ${displaySize}px 'Caveat', cursive`;
               measureSpan.style.visibility = "hidden";
               measureSpan.style.position = "absolute";
               measureSpan.style.whiteSpace = "pre";
               measureSpan.textContent = input.value || " ";
               document.body.appendChild(measureSpan);

               const textWidth = measureSpan.offsetWidth;
               document.body.removeChild(measureSpan);

               // Set input width with some padding (add 10px for cursor and breathing room)
               input.style.width = Math.max(50, textWidth + 10) + "px";
            };

            // Update width initially
            updateInputWidth();

            // Update width as user types
            input.addEventListener("input", updateInputWidth);

            setTimeout(() => {
               input.focus();
               if (text) input.select();
            }, 10);
            activeInput = input;

            const finish = () => {
               if (!activeInput) return;

               if (shapeIndex >= 0 && shapeIndex < shapes.length) {
                  const shape = shapes[shapeIndex];
                  // Update the shape's inner text properties
                  shape.innerText = input.value;
                  shape.innerTextSize = useSize;
                  shape.innerTextColor = useColor;
                  // Mark as no longer editing
                  shape.isEditingText = false;

                  // Select the shape after editing
                  clearSelection();
                  selectedIndices.add(shapeIndex);
                  setTool("select", true);
                  saveHistory();
                  render();
               }
               cleanupInput();
            };

            input.addEventListener("keydown", (e) => {
               if (e.key === "Enter") finish();
            });
            input.addEventListener("blur", finish);
         }

         // --- Helpers: Eraser & Hit Testing ---

         function handleEraser(pos) {
            let erased = false;
            for (let i = shapes.length - 1; i >= 0; i--) {
               if (isPointInShape(pos, shapes[i])) {
                  shapes.splice(i, 1);
                  erased = true;
                  break;
               }
            }
            if (erased) {
               clearSelection();
               updateConnections();
               render();
               saveHistory();
            }
         }

         function getHitHandle(pos, shape) {
            const r = 12 / camera.scale;
            if (shape.type === "arrow" || shape.type === "line") {
               if (dist(pos, shape.start) < r) return "start";
               if (dist(pos, shape.end) < r) return "end";
               if (shape.type === "arrow" && shape.control && dist(pos, shape.control) < r)
                  return "control";
            } else {
               let x, y, w, h;
               if (
                  shape.type === "text" ||
                  shape.type === "pencil" ||
                  shape.type === "pencil-arrow" ||
                  shape.type === "image"
               ) {
                  const b = getBoundingBox(shape);
                  x = b.x;
                  y = b.y;
                  w = b.w;
                  h = b.h;
               } else {
                  x = shape.x;
                  y = shape.y;
                  w = shape.w;
                  h = shape.h;
               }

               // Corners (larger hit area)
               if (dist(pos, { x: x, y: y }) < r) return "tl";
               if (dist(pos, { x: x + w, y: y }) < r) return "tr";
               if (dist(pos, { x: x, y: y + h }) < r) return "bl";
               if (dist(pos, { x: x + w, y: y + h }) < r) return "br";

               // Sides (smaller hit area - check for proximity to edge)
               const sideR = 8 / camera.scale;
               // Top side
               if (Math.abs(pos.y - y) < sideR && pos.x > x + r && pos.x < x + w - r) return "top";
               // Bottom side
               if (Math.abs(pos.y - (y + h)) < sideR && pos.x > x + r && pos.x < x + w - r)
                  return "bottom";
               // Left side
               if (Math.abs(pos.x - x) < sideR && pos.y > y + r && pos.y < y + h - r) return "left";
               // Right side
               if (Math.abs(pos.x - (x + w)) < sideR && pos.y > y + r && pos.y < y + h - r)
                  return "right";
            }
            return null;
         }

         function bringToFront() {
            if (selectedIndices.size === 0) return;
            const selectedShapes = [];
            const remainingShapes = [];
            shapes.forEach((s, i) => {
               if (selectedIndices.has(i)) selectedShapes.push(s);
               else remainingShapes.push(s);
            });
            shapes = [...remainingShapes, ...selectedShapes];
            clearSelection();
            for (let i = shapes.length - selectedShapes.length; i < shapes.length; i++) {
               addToSelection(i);
            }
            saveHistory();
            render();
            showToast("Brought to Front");
         }

         function sendToBack() {
            if (selectedIndices.size === 0) return;
            const selectedShapes = [];
            const remainingShapes = [];
            shapes.forEach((s, i) => {
               if (selectedIndices.has(i)) selectedShapes.push(s);
               else remainingShapes.push(s);
            });
            shapes = [...selectedShapes, ...remainingShapes];
            clearSelection();
            for (let i = 0; i < selectedShapes.length; i++) {
               addToSelection(i);
            }
            saveHistory();
            render();
            showToast("Sent to Back");
         }

         function isPointInShape(pos, shape) {
            const t = Math.max(10, (shape.width || 2) * 1.5) / camera.scale;
            const isFilled = shape.fillColor && shape.fillColor !== "transparent";

            if (shape.type === "rect") {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);

               const isInside = pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
               if (isFilled && isInside) return true;

               // For unfilled shapes, allow clicking anywhere inside the bounding box
               if (!isFilled) {
                  return isInside;
               }

               // For stroked shapes, check the stroke area
               return (
                  pos.x > x - t &&
                  pos.x < x + w + t &&
                  pos.y > y - t &&
                  pos.y < y + h + t &&
                  !(pos.x > x + t && pos.x < x + w - t && pos.y > y + t && pos.y < y + h - t)
               );
            } else if (shape.type === "circle") {
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               const rx = Math.abs(shape.w / 2);
               const ry = Math.abs(shape.h / 2);
               const normalizedX = (pos.x - cx) / rx;
               const normalizedY = (pos.y - cy) / ry;
               const distSq = normalizedX * normalizedX + normalizedY * normalizedY;

               if (isFilled && distSq <= 1.05) return true;

               // For unfilled circles, allow clicking anywhere inside
               if (!isFilled && distSq <= 1.0) return true;

               // For stroked circles, check the stroke area
               return Math.abs(Math.sqrt(distSq) - 1) * Math.max(rx, ry) < t;
            } else if (shape.type === "triangle") {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);

               // For filled triangles, check if inside the bounding box
               const isInside = pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
               if (isFilled && isInside) return true;

               // For unfilled triangles, allow clicking anywhere inside the bounding box
               if (!isFilled && isInside) return true;

               return pos.x > x - t && pos.x < x + w + t && pos.y > y - t && pos.y < y + h + t;
            } else if (shape.type === "oval") {
               // Stadium hit detection
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);
               const radius = Math.min(w, h) / 2;

               // Normalize x,y to top-left
               let x = shape.x;
               let y = shape.y;
               if (shape.w < 0) x += shape.w;
               if (shape.h < 0) y += shape.h;

               let dist = 0;
               if (w > h) {
                  // Horizontal stadium - distance to central horizontal segment
                  const segmentStart = { x: x + radius, y: y + h / 2 };
                  const segmentEnd = { x: x + w - radius, y: y + h / 2 };
                  dist = distToSegment(pos, segmentStart, segmentEnd);
               } else {
                  // Vertical stadium - distance to central vertical segment
                  const segmentStart = { x: x + w / 2, y: y + radius };
                  const segmentEnd = { x: x + w / 2, y: y + h - radius };
                  dist = distToSegment(pos, segmentStart, segmentEnd);
               }

               return dist <= radius + (isFilled ? 0 : t); // Add stroke width
            } else if (shape.type === "rhombus") {
               // Parallelogram hit detection (Point in Polygon)
               const skew = Math.abs(shape.w) * 0.1;

               // Vertices logic matching drawShape
               // Let's rely on convex logic: on same side of all lines?
               // Or easier: Ray casting or generic func?
               // Let's implement helper for point in polygon if not exists, or just logic here.
               // Since it's just 4 points, barycentric not great.
               // Let's use generic pointInPolygon logic (even-odd rule) or convex logic.

               const x = shape.x;
               const y = shape.y;
               const w = shape.w;
               const h = shape.h;

               const p1 = { x: x + skew, y: y };
               const p2 = { x: x + w, y: y };
               const p3 = { x: x + w - skew, y: y + h };
               const p4 = { x: x, y: y + h };

               const poly = [p1, p2, p3, p4];

               let inside = false;
               for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                  const xi = poly[i].x,
                     yi = poly[i].y;
                  const xj = poly[j].x,
                     yj = poly[j].y;

                  const intersect =
                     yi > pos.y !== yj > pos.y &&
                     pos.x < ((xj - xi) * (pos.y - yi)) / (yj - yi) + xi;
                  if (intersect) inside = !inside;
               }
               return inside;
            } else if (shape.type === "diamond") {
               // Diamond basic hit detection (rotated square)
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);
               // Check if point inside rotated square
               // Transform point to unrotated space? No, simple Manhattan distance check relative to center
               // |x - cx| / (w/2) + |y - cy| / (h/2) <= 1
               return Math.abs(pos.x - cx) / (w / 2) + Math.abs(pos.y - cy) / (h / 2) <= 1;
            } else if (shape.type === "text") {
               ctx.font = `bold ${shape.size}px 'Caveat', cursive`;
               const m = ctx.measureText(shape.text);
               return (
                  pos.x >= shape.x &&
                  pos.x <= shape.x + m.width &&
                  pos.y >= shape.y &&
                  pos.y <= shape.y + shape.size
               );
            } else if (shape.type === "pencil" || shape.type === "pencil-arrow") {
               for (let i = 0; i < shape.points.length - 1; i++) {
                  if (distToSegment(pos, shape.points[i], shape.points[i + 1]) < t) return true;
               }
               return false;
            } else if (shape.type === "line") {
               return distToSegment(pos, shape.start, shape.end) < t;
            } else if (shape.type === "arrow") {
               const cp = shape.control || {
                  x: (shape.start.x + shape.end.x) / 2,
                  y: (shape.start.y + shape.end.y) / 2,
               };
               for (let i = 0; i <= 20; i++) {
                  const time = i / 20;
                  const mt = 1 - time;
                  const x =
                     mt * mt * shape.start.x + 2 * mt * time * cp.x + time * time * shape.end.x;
                  const y =
                     mt * mt * shape.start.y + 2 * mt * time * cp.y + time * time * shape.end.y;
                  if (dist(pos, { x, y }) < t) return true;
               }
               return false;
            } else if (shape.type === "image") {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);
               return pos.x > x && pos.x < x + w && pos.y > y && pos.y < y + h;
            }
            return false;
         }

         function dist(p1, p2) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y);
         }

         function distToSegment(p, v, w) {
            const l2 = (w.x - v.x) ** 2 + (w.y - v.y) ** 2;
            if (l2 === 0) return dist(p, v);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
         }

         function getBoundingBox(shape) {
            if (shape.points) {
               let mx = Infinity,
                  my = Infinity,
                  Mx = -Infinity,
                  My = -Infinity;
               shape.points.forEach((p) => {
                  mx = Math.min(mx, p.x);
                  my = Math.min(my, p.y);
                  Mx = Math.max(Mx, p.x);
                  My = Math.max(My, p.y);
               });
               return { x: mx, y: my, w: Mx - mx, h: My - my };
            }
            if (shape.type === "line" || shape.type === "arrow") {
               const mx = Math.min(shape.start.x, shape.end.x);
               const my = Math.min(shape.start.y, shape.end.y);
               const Mx = Math.max(shape.start.x, shape.end.x);
               const My = Math.max(shape.start.y, shape.end.y);
               return { x: mx, y: my, w: Mx - mx, h: My - my };
            }
            if (shape.type === "text") {
               ctx.save();
               ctx.setTransform(1, 0, 0, 1, 0, 0); // Measure in unscaled pixels for accuracy
               ctx.font = `bold ${shape.size}px 'Caveat', cursive`;
               const m = ctx.measureText(shape.text);
               ctx.restore();
               return { x: shape.x, y: shape.y, w: m.width, h: shape.size };
            }
            // Normalize rect-like shapes to have positive w/h for alignment logic
            const x = Math.min(shape.x, shape.x + shape.w);
            const y = Math.min(shape.y, shape.y + shape.h);
            const w = Math.abs(shape.w);
            const h = Math.abs(shape.h);
            return { x, y, w, h };
         }

         // --- Tool & UI Functions ---

         function updateCursor() {
            if (currentTool === "select") {
               canvas.style.cursor = "default";
            } else if (currentTool === "eraser") {
               canvas.style.cursor = "cell";
            } else {
               canvas.style.cursor = "crosshair";
            }
         }

         function setTool(tool, keepSelection = false) {
            // Hide shape recognition panel when switching tools
            hideShapeRecognitionPanel();

            currentTool = tool;
            document.querySelectorAll(".tool-btn").forEach((btn) => btn.classList.remove("active"));
            document
               .querySelectorAll(".shape-dropdown-item")
               .forEach((btn) => btn.classList.remove("active"));

            const toolMap = {
               select: "btn-select",
               pencil: "btn-pencil",
               "pencil-arrow": "btn-pencil-arrow",
               laser: "btn-laser",
               eraser: "btn-eraser",
               line: "btn-line",
               arrow: "btn-arrow",
               text: "btn-text",
               rect: "btn-rect",
               circle: "btn-circle",
               triangle: "btn-triangle",
               oval: "btn-oval",
               rhombus: "btn-rhombus",
               diamond: "btn-diamond",
            };

            const btnId = toolMap[tool];
            if (btnId) {
               const btn = document.getElementById(btnId);
               if (btn) btn.classList.add("active");
            }

            // Also highlight the more-shapes button if a dropdown shape is selected
            if (tool === "oval" || tool === "rhombus" || tool === "diamond") {
               const moreBtn = document.getElementById("btn-more-shapes");
               if (moreBtn) moreBtn.classList.add("active");
            }

            updateCursor();

            if (!keepSelection) clearSelection();
            currentShape = null;
            render();
         }

         function toggleShapeDropdown() {
            const menu = document.getElementById("shape-dropdown-menu");
            if (menu) {
               menu.classList.toggle("visible");
            }
         }

         function hideShapeDropdown() {
            const menu = document.getElementById("shape-dropdown-menu");
            if (menu) {
               menu.classList.remove("visible");
            }
         }

         // Close dropdown when clicking elsewhere
         document.addEventListener("click", (e) => {
            const dropdown = document.querySelector(".shape-dropdown");
            if (dropdown && !dropdown.contains(e.target)) {
               hideShapeDropdown();
            }
         });

         function checkAndSetPencilIfEmpty() {
            // If canvas is completely empty, switch to Pencil tool
            if (shapes.length === 0) {
               setTool("pencil");
            }
         }

         let isPickingFill = false;

         function handleCustomColorChange(e) {
            isPickingFill = false;
         }

         function handleCustomColorMouseDown(e) {
            // Left-click (button 0) on the input itself opens color picker in fill mode
            if (e.button === 0) {
               isPickingFill = true;
            }
         }

         function handleCustomColorContextMenu(e) {
            e.preventDefault();
            isPickingFill = false;
            const picker = document.getElementById("customColorPicker");

            // Trigger the color picker with stroke mode (right-click = stroke)
            if (picker) picker.click();
         }

         function handleCustomColorPickerMouseDown(e) {
            // Right-click (button 2) on the visual picker div
            if (e.button === 2) {
               e.preventDefault();
               isPickingFill = false;
               const picker = document.getElementById("customColorPicker");
               if (picker) picker.click();
            }
         }

         function handleCustomColorInput(value, e) {
            if (isPickingFill) {
               handleColorClick(value, {
                  type: "contextmenu",
                  button: 2,
                  preventDefault: () => {},
               });
            } else {
               handleColorClick(value, e);
            }
         }

         function handleColorClick(color, event) {
            const isRightClick = event.type === "contextmenu" || event.button === 2;

            if (selectedIndices.size > 0) {
               // Apply to selected shapes ONLY, do not change defaults
               selectedIndices.forEach((idx) => {
                  const shape = shapes[idx];
                  if (isRightClick) {
                     // Constraint: prevent invisible shapes
                     if (color === "transparent" && shape.color === "transparent") {
                        return; // Skip this shape
                     }
                     shape.fillColor = color;

                     // Auto-toggle text color for shapes with inner text
                     if (
                        shape.type === "rect" ||
                        shape.type === "circle" ||
                        shape.type === "triangle"
                     ) {
                        if (color === "transparent") {
                           // Set text color to black when fill is transparent
                           shape.innerTextColor = "#000000";
                        } else {
                           // Determine if color is light or dark
                           const isLightColor = isColorLight(color);
                           shape.innerTextColor = isLightColor ? "#000000" : "#ffffff";
                        }
                     }
                  } else {
                     if (color === "transparent" && shape.fillColor === "transparent") {
                        return; // Skip
                     }
                     shape.color = color;
                  }
               });
               showToast("Applied " + (isRightClick ? "Fill" : "Stroke") + " color to selection");
               saveHistory();
               render();
            } else {
               // No selection: update default colors for new shapes
               if (isRightClick) {
                  if (color === "transparent" && currentColor === "transparent") {
                     showToast("At least one color must be visible");
                     return;
                  }
                  currentFillColor = color;
                  showToast("Default Fill color set to " + color);
               } else {
                  if (color === "transparent" && currentFillColor === "transparent") {
                     showToast("At least one color must be visible");
                     return;
                  }
                  currentColor = color;
                  showToast("Default Stroke color set to " + color);
               }
               updateColorUI();
            }
         }

         function isColorLight(color) {
            if (color === "transparent") return false;

            let r, g, b;
            if (color.startsWith("#")) {
               r = parseInt(color.slice(1, 3), 16);
               g = parseInt(color.slice(3, 5), 16);
               b = parseInt(color.slice(5, 7), 16);
            } else if (color.startsWith("rgb")) {
               const matches = color.match(/\d+/g);
               r = parseInt(matches[0]);
               g = parseInt(matches[1]);
               b = parseInt(matches[2]);
            } else {
               return false;
            }

            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.5;
         }

         function updateColorUI() {
            // No longer adding active-stroke/active-fill outlines as per user request

            const strokePreview = document.getElementById("stroke-preview");
            const fillPreview = document.getElementById("fill-preview");

            if (currentColor === "transparent") {
               strokePreview.style.backgroundColor = "";
               strokePreview.classList.add("transparent-swatch");
            } else {
               strokePreview.style.backgroundColor = currentColor;
               strokePreview.classList.remove("transparent-swatch");
            }

            if (currentFillColor === "transparent") {
               fillPreview.style.backgroundColor = "";
               fillPreview.classList.add("transparent-swatch");
            } else {
               fillPreview.style.backgroundColor = currentFillColor;
               fillPreview.classList.remove("transparent-swatch");
            }
         }

         function showContextMenu(x, y) {
            const menu = document.getElementById("context-menu");
            menu.style.left = x + "px";
            menu.style.top = y + "px";
            menu.classList.remove("hidden");
         }

         function hideContextMenu() {
            document.getElementById("context-menu").classList.add("hidden");
         }

         window.addEventListener("contextmenu", (e) => {
            // Don't show context menu if right-clicked on toolbar or other UI elements
            if (e.target !== canvas && !canvas.contains(e.target)) {
               return;
            }

            const screenPos = getPointerPos(e);
            const pos = toWorld(screenPos.x, screenPos.y);

            // Check if we right-clicked on a shape
            let hitIndex = -1;
            for (let i = shapes.length - 1; i >= 0; i--) {
               if (isPointInShape(pos, shapes[i])) {
                  hitIndex = i;
                  break;
               }
            }

            e.preventDefault();

            // Show/hide paste option based on whether we right-clicked on a shape
            const pasteItem = document.getElementById("paste-menu-item");
            const pasteSeparator = document.getElementById("paste-separator");
            const toDottedItem = document.getElementById("to-dotted-line-item");
            const editingLayeringSeparator = document.getElementById("editing-layering-separator");
            const bringToFront = document.getElementById("bring-to-front-item");
            const sendToBack = document.getElementById("send-to-back-item");
            const layeringDeleteSeparator = document.getElementById("layering-delete-separator");
            const deleteItem = document.getElementById("delete-item");
            const shapeConversionSeparator = document.getElementById("shape-conversion-separator");
            const changeToRectangleItem = document.getElementById("change-to-rectangle-item");
            const changeToCircleItem = document.getElementById("change-to-circle-item");
            const changeToTriangleItem = document.getElementById("change-to-triangle-item");
            const changeToOvalItem = document.getElementById("change-to-oval-item");
            const changeToRhombusItem = document.getElementById("change-to-rhombus-item");
            const changeToDiamondItem = document.getElementById("change-to-diamond-item");

            if (hitIndex !== -1) {
               // Right-clicked on a shape - hide paste, show shape options
               pasteItem.style.display = "none";
               pasteSeparator.style.display = "none";
               if (toDottedItem) toDottedItem.style.display = "flex";
               if (editingLayeringSeparator) editingLayeringSeparator.style.display = "block";
               if (bringToFront) bringToFront.style.display = "flex";
               if (sendToBack) sendToBack.style.display = "flex";
               if (layeringDeleteSeparator) layeringDeleteSeparator.style.display = "block";
               if (deleteItem) deleteItem.style.display = "flex";
               // Show shape conversion items
               if (shapeConversionSeparator) shapeConversionSeparator.style.display = "block";
               if (changeToRectangleItem) changeToRectangleItem.style.display = "flex";
               if (changeToCircleItem) changeToCircleItem.style.display = "flex";
               if (changeToTriangleItem) changeToTriangleItem.style.display = "flex";
               if (changeToOvalItem) changeToOvalItem.style.display = "flex";
               if (changeToRhombusItem) changeToRhombusItem.style.display = "flex";
               if (changeToDiamondItem) changeToDiamondItem.style.display = "flex";

               if (!selectedIndices.has(hitIndex)) {
                  clearSelection();
                  selectedIndices.add(hitIndex);
                  render();
               }
               // Switch to select tool when right-clicking on a shape
               setTool("select", true);
            } else {
               // Right-clicked on empty canvas - show paste, hide shape options
               pasteItem.style.display = "flex";
               pasteSeparator.style.display = "block";
               if (toDottedItem) toDottedItem.style.display = "none";
               if (editingLayeringSeparator) editingLayeringSeparator.style.display = "none";
               if (bringToFront) bringToFront.style.display = "none";
               if (sendToBack) sendToBack.style.display = "none";
               if (layeringDeleteSeparator) layeringDeleteSeparator.style.display = "none";
               if (deleteItem) deleteItem.style.display = "none";
               if (shapeConversionSeparator) shapeConversionSeparator.style.display = "none";
               if (changeToRectangleItem) changeToRectangleItem.style.display = "none";
               if (changeToCircleItem) changeToCircleItem.style.display = "none";
               if (changeToTriangleItem) changeToTriangleItem.style.display = "none";
               if (changeToOvalItem) changeToOvalItem.style.display = "none";
               if (changeToRhombusItem) changeToRhombusItem.style.display = "none";
               if (changeToDiamondItem) changeToDiamondItem.style.display = "none";
            }

            showContextMenu(e.clientX, e.clientY);
         });

         window.addEventListener("click", () => {
            hideContextMenu();
         });

         function setCustomColor(color) {
            setColor(color);
            const swatch = document.createElement("button");
            swatch.className = "color-swatch w-5 h-5 rounded-full";
            swatch.style.backgroundColor = color;
            swatch.dataset.color = color;
            swatch.onclick = function () {
               setColor(color, this);
            };
            // Optionally add the custom color to the palette
         }

         function setLineWidth(width) {
            currentWidth = parseInt(width);
            const widthValDesk = document.getElementById("width-val-desk");
            const widthValMob = document.getElementById("width-val-mob");
            const widthSliderDesk = document.getElementById("width-slider-desk");
            const widthSliderMob = document.getElementById("width-slider-mob");

            if (widthValDesk) widthValDesk.textContent = currentWidth;
            if (widthValMob) widthValMob.textContent = currentWidth;
            if (widthSliderDesk) widthSliderDesk.value = currentWidth;
            if (widthSliderMob) widthSliderMob.value = currentWidth;
         }

         function deleteSelected() {
            if (selectedIndices.size === 0) return;

            const sortedIndices = Array.from(selectedIndices).sort((a, b) => b - a);
            sortedIndices.forEach((idx) => {
               shapes.splice(idx, 1);
            });

            clearSelection();
            updateConnections();
            saveHistory();
            render();
            showToast("Deleted");
            checkAndSetPencilIfEmpty();
         }

         function toggleDottedLine() {
            if (selectedIndices.size === 0) return;

            selectedIndices.forEach((idx) => {
               if (shapes[idx]) {
                  shapes[idx].isDotted = !shapes[idx].isDotted;
               }
            });

            saveHistory();
            render();
            showToast(shapes[Array.from(selectedIndices)[0]].isDotted ? "To Dotted" : "To Solid");
         }

         function clearBoard() {
            shapes = [];
            clearSelection();
            currentShape = null;
            camera.x = 0;
            camera.y = 0;
            camera.scale = 1;
            saveHistory();
            render();
            showToast("Board Cleared");
            checkAndSetPencilIfEmpty();
         }

         function resetView() {
            camera.x = 0;
            camera.y = 0;
            camera.scale = 1;
            render();
            showToast("View Reset");
         }

         function downloadImage() {
            const link = document.createElement("a");
            link.download = "scribble-" + Date.now() + ".png";
            link.href = canvas.toDataURL();
            link.click();
            showToast("Image Downloaded");
         }

         function showToast(message) {
            if (toastEl) {
               toastEl.textContent = message;
               toastEl.classList.remove("opacity-0");
               setTimeout(() => {
                  toastEl.classList.add("opacity-0");
               }, 2000);
            }
         }

         // --- Shape Recognition Undo Panel Functions ---

         function showShapeRecognitionPanel(originalShape, convertedIndex) {
            const panel = document.getElementById("shape-recognition-panel");
            if (!panel) return;

            // Store the original shape and converted index
            originalPencilShape = JSON.parse(JSON.stringify(originalShape)); // Deep copy
            convertedShapeIndex = convertedIndex;

            // Clear any existing timer
            if (shapeRecognitionPanelTimer) {
               clearTimeout(shapeRecognitionPanelTimer);
               shapeRecognitionPanelTimer = null;
            }

            // Show the panel with animation
            panel.classList.remove("hidden");
            setTimeout(() => {
               panel.style.opacity = "1";
               panel.style.transform = "translate(-50%, 0)";
            }, 10);

            // Auto-hide after 4 seconds
            shapeRecognitionPanelTimer = setTimeout(() => {
               hideShapeRecognitionPanel();
            }, 4000);
         }

         function hideShapeRecognitionPanel() {
            const panel = document.getElementById("shape-recognition-panel");
            if (!panel) return;

            // Clear timer
            if (shapeRecognitionPanelTimer) {
               clearTimeout(shapeRecognitionPanelTimer);
               shapeRecognitionPanelTimer = null;
            }

            // Hide with animation
            panel.style.opacity = "0";
            panel.style.transform = "translate(-50%, -10px)";
            setTimeout(() => {
               panel.classList.add("hidden");
               originalPencilShape = null;
               convertedShapeIndex = -1;
            }, 300);
         }

         function undoShapeRecognition() {
            if (originalPencilShape === null || convertedShapeIndex === -1) {
               hideShapeRecognitionPanel();
               return;
            }

            // Remove the converted shape
            if (shapes[convertedShapeIndex]) {
               shapes.splice(convertedShapeIndex, 1);
            }

            // Restore the original pencil shape
            shapes.push(originalPencilShape);
            clearSelection();
            addToSelection(shapes.length - 1);
            saveHistory();
            render();

            hideShapeRecognitionPanel();
            showToast("Reverted to original drawing");
         }

         function convertToShape(shapeType) {
            if (originalPencilShape === null || convertedShapeIndex === -1) {
               hideShapeRecognitionPanel();
               return;
            }

            // Remove the current converted shape
            if (shapes[convertedShapeIndex]) {
               shapes.splice(convertedShapeIndex, 1);
            }

            // Convert to the requested shape type
            const detectedShape = { type: shapeType };
            const newShape = convertPencilToShape(originalPencilShape, detectedShape);
            shapes.push(newShape);

            // Update the converted shape index
            convertedShapeIndex = shapes.length - 1;

            clearSelection();
            addToSelection(convertedShapeIndex);
            saveHistory();
            render();

            const shapeNameMap = {
               rectangle: "Rectangle",
               circle: "Circle",
               triangle: "Triangle",
            };
            const shapeName = shapeNameMap[shapeType] || shapeType;
            showToast(`Converted to ${shapeName}`);

            // Keep panel open for further conversions
            // Reset the timer
            if (shapeRecognitionPanelTimer) {
               clearTimeout(shapeRecognitionPanelTimer);
            }
            shapeRecognitionPanelTimer = setTimeout(() => {
               hideShapeRecognitionPanel();
            }, 4000);
         }

         // Change currently selected shapes to a specific basic shape type
         function changeSelectedShapesType(targetType) {
            if (!selectedIndices || selectedIndices.size === 0) return;

            selectedIndices.forEach((idx) => {
               const shape = shapes[idx];
               if (!shape) return;

               // Only convert compatible shapes (basic shapes and pencil strokes)
               if (
                  shape.type === "rect" ||
                  shape.type === "circle" ||
                  shape.type === "triangle" ||
                  shape.type === "oval" ||
                  shape.type === "rhombus" ||
                  shape.type === "diamond"
               ) {
                  shape.type = targetType;
               } else if (
                  shape.type === "pencil" &&
                  Array.isArray(shape.points) &&
                  shape.points.length > 1
               ) {
                  // Reuse pencil-to-shape conversion to create a new shape from the stroke
                  const detectedShape = {
                     type: targetType === "rect" ? "rectangle" : targetType,
                  };
                  const newShape = convertPencilToShape(shape, detectedShape);
                  // Preserve some visual properties
                  newShape.fillColor = shape.fillColor || "transparent";
                  newShape.innerText = shape.innerText || "";
                  newShape.innerTextColor = shape.innerTextColor || "#000000";
                  newShape.innerTextSize = shape.innerTextSize || 20;
                  shapes[idx] = newShape;
               }
            });

            saveHistory();
            render();
         }

         // --- Image Upload Logic ---

         function handleImageFile(file) {
            if (!file || !file.type.startsWith("image/")) return;

            const reader = new FileReader();
            reader.onload = (e) => {
               const img = new Image();
               img.onload = () => {
                  // Calculate dimensions to fit in view
                  let w = img.width;
                  let h = img.height;
                  const maxDim = 400;
                  if (w > maxDim || h > maxDim) {
                     const ratio = Math.min(maxDim / w, maxDim / h);
                     w *= ratio;
                     h *= ratio;
                  }

                  const worldCenter = toWorld(canvas.width / 2, canvas.height / 2);
                  const newShape = {
                     id: generateId(),
                     type: "image",
                     x: worldCenter.x - w / 2,
                     y: worldCenter.y - h / 2,
                     w: w,
                     h: h,
                     image: img,
                     src: e.target.result, // Store source for history/serialization
                     aspectRatio: w / h, // Store aspect ratio for resizing
                  };
                  shapes.push(newShape);
                  clearSelection();
                  addToSelection(shapes.length - 1);
                  setTool("select", true);
                  saveHistory();
                  render();
                  showToast("Image Added");
               };
               img.src = e.target.result;
            };
            reader.readAsDataURL(file);
         }

         // Paste from clipboard (context menu)
         function pasteFromClipboard() {
            // Access clipboard API
            navigator.clipboard
               .read()
               .then((items) => {
                  for (const item of items) {
                     if (item.types.some((type) => type.startsWith("image/"))) {
                        item
                           .getType(item.types.find((t) => t.startsWith("image/")))
                           .then((blob) => {
                              handleImageFile(blob);
                           });
                        return;
                     }
                  }
                  showToast("No image found in clipboard");
               })
               .catch((err) => {
                  showToast("Clipboard access denied or no image in clipboard");
                  console.error("Clipboard error:", err);
               });
         }

         // Drag and Drop
         window.addEventListener("dragover", (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
         });

         window.addEventListener("drop", (e) => {
            e.preventDefault();
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
               handleImageFile(e.dataTransfer.files[0]);
            }
         });

         // Paste
         window.addEventListener("paste", (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (const item of items) {
               if (item.type.indexOf("image") !== -1) {
                  const file = item.getAsFile();
                  handleImageFile(file);
               }
            }
         });

         // --- History & Keys ---

         function saveHistory() {
            // For images, we need to handle the Image objects specially if we were to use localStorage
            // but for in-memory history, we can just store the shapes array (with references).
            // However, to make undo/redo work correctly with object references, we should clone.
            // Special handling for image property to keep it as an Image object.
            const s = JSON.stringify(shapes, (key, value) => {
               if (key === "image") return undefined; // Don't stringify the Image object
               return value;
            });

            if (historyStack.length > 0 && historyStack[historyStep] === s) return;

            if (historyStep < historyStack.length - 1) {
               historyStack = historyStack.slice(0, historyStep + 1);
            }

            historyStack.push(s);
            if (historyStack.length > MAX_HISTORY) historyStack.shift();
            else historyStep++;
         }

         function undo() {
            if (historyStep > 0) {
               historyStep--;
               const savedShapes = JSON.parse(historyStack[historyStep]);

               // Re-hydrate images
               shapes = savedShapes.map((s) => {
                  if (s.type === "image" && s.src) {
                     const img = new Image();
                     img.src = s.src;
                     return { ...s, image: img };
                  }
                  return s;
               });

               const validSelection = new Set();
               selectedIndices.forEach((idx) => {
                  if (idx < shapes.length) {
                     validSelection.add(idx);
                  }
               });
               selectedIndices = validSelection;
               selectionQueue = Array.from(validSelection);

               updateConnections();
               render();
               showToast("Undo");
               checkAndSetPencilIfEmpty();
            } else if (historyStep === 0) {
               historyStep = -1;
               shapes = [];
               clearSelection();
               render();
               showToast("Undo");
               checkAndSetPencilIfEmpty();
            }
         }

         // Helper function to check if a point is inside a shape's bounds (for double-click)
         // This ignores fill status and always checks the interior
         function isPointInsideShapeBounds(pos, shape) {
            if (shape.type === "rect") {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);
               return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
            } else if (shape.type === "circle") {
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               const rx = Math.abs(shape.w / 2);
               const ry = Math.abs(shape.h / 2);
               const normalizedX = (pos.x - cx) / rx;
               const normalizedY = (pos.y - cy) / ry;
               const distSq = normalizedX * normalizedX + normalizedY * normalizedY;
               return distSq <= 1.05; // Slightly larger for easier clicking
            } else if (shape.type === "triangle") {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);
               return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
            } else if (shape.type === "oval") {
               const cx = shape.x + shape.w / 2;
               const cy = shape.y + shape.h / 2;
               const rx = Math.abs(shape.w / 2);
               const ry = Math.abs(shape.h / 2);
               const normalizedX = (pos.x - cx) / rx;
               const normalizedY = (pos.y - cy) / ry;
               const distSq = normalizedX * normalizedX + normalizedY * normalizedY;
               return distSq <= 1.05;
            } else if (shape.type === "rhombus" || shape.type === "diamond") {
               const x = Math.min(shape.x, shape.x + shape.w);
               const y = Math.min(shape.y, shape.y + shape.h);
               const w = Math.abs(shape.w);
               const h = Math.abs(shape.h);
               return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
            } else if (shape.type === "text") {
               ctx.font = `bold ${shape.size}px 'Caveat', cursive`;
               const m = ctx.measureText(shape.text);
               return (
                  pos.x >= shape.x &&
                  pos.x <= shape.x + m.width &&
                  pos.y >= shape.y &&
                  pos.y <= shape.y + shape.size
               );
            }
            return false;
         }

         function onDoubleClick(e) {
            const screenPos = getPointerPos(e);
            const pos = toWorld(screenPos.x, screenPos.y);

            for (let i = shapes.length - 1; i >= 0; i--) {
               const shape = shapes[i];

               // For shapes that can have text inside, use bounds checking
               if (
                  shape.type === "rect" ||
                  shape.type === "circle" ||
                  shape.type === "triangle" ||
                  shape.type === "oval" ||
                  shape.type === "rhombus" ||
                  shape.type === "diamond"
               ) {
                  if (isPointInsideShapeBounds(pos, shape)) {
                     // Handle shape objects - add text inside them
                     // Calculate center position of the shape
                     const centerX = shape.x + shape.w / 2;
                     const centerY = shape.y + shape.h / 2;

                     // Check if shape already has text
                     const existingText = shape.innerText || "";
                     const textSize = shape.innerTextSize || currentWidth * 5 + 10;
                     const textColor = shape.innerTextColor || currentColor;

                     // Store reference to the shape being edited
                     const shapeIndex = i;

                     // Create text input at center of shape
                     createTextInputForShape(
                        centerX,
                        centerY,
                        existingText,
                        textSize,
                        textColor,
                        shapeIndex
                     );
                     return;
                  }
               } else if (isPointInShape(pos, shape)) {
                  // For other shapes (text, lines, etc.), use normal hit detection
                  if (shape.type === "text") {
                     shapes.splice(i, 1);
                     clearSelection();
                     render();

                     createTextInput(shape.x, shape.y, shape.text, shape.size, shape.color);
                     return;
                  }
               }
            }
         }

         document.addEventListener("keydown", (e) => {
            if (isTyping) return;

            const isCtrl = e.ctrlKey || e.metaKey;
            const isAlt = e.altKey;
            const k = e.key.toLowerCase();

            if (isCtrl && k === "z") {
               e.preventDefault();
               undo();
            } else if (isAlt && k === "n") {
               e.preventDefault();
               clearBoard();
            } else if (isCtrl && k === "a") {
               e.preventDefault();
               clearSelection();
               shapes.forEach((_, i) => addToSelection(i));
               setTool("select", true);
               render();
               showToast(`Selected ${shapes.length} object${shapes.length !== 1 ? "s" : ""}`);
            } else if (e.key === "Escape") {
               setTool("select");
               if (selectedIndices.size > 0) {
                  clearSelection();
                  render();
                  showToast("Selection Removed");
               } else {
                  resetView();
               }
               e.preventDefault();
            } else if (isCtrl && ["arrowup", "arrowright", "arrowdown", "arrowleft"].includes(k)) {
               e.preventDefault();
               const sideMap = {
                  arrowup: "top",
                  arrowright: "right",
                  arrowdown: "bottom",
                  arrowleft: "left",
               };
               createLinkedShapeOnSide(sideMap[k]);
            } else if (
               !isCtrl &&
               !isAlt &&
               selectedIndices.size > 1 &&
               ["l", "r", "t", "b", "c", "v", "h", "e"].includes(k)
            ) {
               e.preventDefault();
               if (k === "l") alignSelected("left");
               else if (k === "r") alignSelected("right");
               else if (k === "t") alignSelected("top");
               else if (k === "b") alignSelected("bottom");
               else if (k === "h" || k === "e")
                  alignSelected("center-h"); // H or E for horizontal center
               else if (k === "c" || k === "v") alignSelected("middle-v"); // C or V for vertical center
               showToast("Aligned " + k.toUpperCase());
            } else if (isCtrl && k === "k") {
               e.preventDefault();
               handleColorClick("#000000", { type: "click", button: 0, preventDefault: () => {} });
            } else if (isCtrl && k === "r") {
               e.preventDefault();
               handleColorClick("#ef4444", { type: "click", button: 0, preventDefault: () => {} });
            } else if (isCtrl && k === "g") {
               e.preventDefault();
               handleColorClick("#22c55e", { type: "click", button: 0, preventDefault: () => {} });
            } else if (isCtrl && k === "b") {
               e.preventDefault();
               handleColorClick("#3b82f6", { type: "click", button: 0, preventDefault: () => {} });
            } else if (e.key === "Delete" || e.key === "Backspace") {
               deleteSelected();
            } else if (e.key === "[") setLineWidth(Math.max(1, currentWidth - 1));
            else if (e.key === "]") setLineWidth(Math.min(50, currentWidth + 1));
            // Single-letter tool shortcuts (only when Ctrl/Alt are not pressed)
            else if (!isCtrl && !isAlt && k === "s") setTool("select");
            else if (!isCtrl && !isAlt && k === "e") setTool("eraser");
            else if (!isCtrl && !isAlt && k === "p") setTool("pencil");
            else if (!isCtrl && !isAlt && k === "f") setTool("pencil-arrow");
            else if (!isCtrl && !isAlt && k === "z") setTool("laser");
            else if (!isCtrl && !isAlt && k === "l") setTool("line");
            else if (!isCtrl && !isAlt && k === "a") setTool("arrow");
            else if (!isCtrl && !isAlt && k === "r") setTool("rect");
            else if (!isCtrl && !isAlt && k === "t") setTool("text");
            else if (!isCtrl && !isAlt && k === "n") setTool("triangle");
            else if (!isCtrl && !isAlt && k === "c") setTool("circle");
         });

         canvas.addEventListener("mousedown", onMouseDown);
         canvas.addEventListener("mousemove", onMouseMove);
         window.addEventListener("mouseup", onMouseUp);
         canvas.addEventListener("touchstart", onMouseDown, { passive: false });
         canvas.addEventListener("touchmove", onMouseMove, { passive: false });
         window.addEventListener("touchend", onMouseUp);
         canvas.addEventListener("dblclick", onDoubleClick);

         resizeCanvas();
         saveHistory();

         // Fix ReferenceError by exposing functions to window
         window.setTool = setTool;
         window.setLineWidth = setLineWidth;
         window.undo = undo;
         window.deleteSelected = deleteSelected;
         window.clearBoard = clearBoard;
         window.downloadImage = downloadImage;
         window.alignSelected = alignSelected;
         window.resetView = resetView;
         window.handleImageFile = handleImageFile;
         window.handleColorClick = handleColorClick;
         window.bringToFront = bringToFront;
         window.sendToBack = sendToBack;
         window.undoShapeRecognition = undoShapeRecognition;
         window.convertToShape = convertToShape;
         window.pasteFromClipboard = pasteFromClipboard;
         window.toggleDottedLine = toggleDottedLine;
         window.setColor = (c) => handleColorClick(c, { button: 0 }); // Fallback for any old calls
         window.hideContextMenu = hideContextMenu;
         window.toggleShapeDropdown = toggleShapeDropdown;
         window.hideShapeDropdown = hideShapeDropdown;
         window.changeSelectedShapesType = changeSelectedShapesType;

         updateColorUI();
      </script>
   </body>
</html>
